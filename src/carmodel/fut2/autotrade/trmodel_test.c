
// We need to define _GNU_SOURCE before
// _any_ headers files are imported to get
// the usage statistics of a thread (i.e. have RUSAGE_THREAD) on GNU/Linux
// https://manpages.courier-mta.org/htmlman2/getrusage.2.html
#ifndef _GNU_SOURCE // Avoid possible double-definition warning.
#define _GNU_SOURCE
#endif

#ifdef __clang__
#pragma clang diagnostic ignored "-Wunused-function"
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wunused-const-variable"
#pragma clang diagnostic ignored "-Wparentheses"
#pragma clang diagnostic ignored "-Wunused-label"
#pragma clang diagnostic ignored "-Wunused-but-set-variable"
#elif __GNUC__
#pragma GCC diagnostic ignored "-Wunused-function"
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-const-variable"
#pragma GCC diagnostic ignored "-Wparentheses"
#pragma GCC diagnostic ignored "-Wunused-label"
#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
#endif

// Headers
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <stdio.h>
#include <float.h>

#ifdef __cplusplus
extern "C" {
#endif

// Initialisation
struct futhark_context_config;
struct futhark_context_config *futhark_context_config_new(void);
void futhark_context_config_free(struct futhark_context_config *cfg);
int futhark_context_config_set_tuning_param(struct futhark_context_config *cfg, const char *param_name, size_t new_value);
struct futhark_context;
struct futhark_context *futhark_context_new(struct futhark_context_config *cfg);
void futhark_context_free(struct futhark_context *ctx);
void futhark_context_config_set_debugging(struct futhark_context_config *cfg, int flag);
void futhark_context_config_set_profiling(struct futhark_context_config *cfg, int flag);
void futhark_context_config_set_logging(struct futhark_context_config *cfg, int flag);
int futhark_get_tuning_param_count(void);
const char *futhark_get_tuning_param_name(int);
const char *futhark_get_tuning_param_class(int);

// Arrays
struct futhark_f64_1d;
struct futhark_f64_1d *futhark_new_f64_1d(struct futhark_context *ctx, const double *data, int64_t dim0);
struct futhark_f64_1d *futhark_new_raw_f64_1d(struct futhark_context *ctx, unsigned char *data, int64_t dim0);
int futhark_free_f64_1d(struct futhark_context *ctx, struct futhark_f64_1d *arr);
int futhark_values_f64_1d(struct futhark_context *ctx, struct futhark_f64_1d *arr, double *data);
int futhark_index_f64_1d(struct futhark_context *ctx, double *out, struct futhark_f64_1d *arr, int64_t i0);
unsigned char *futhark_values_raw_f64_1d(struct futhark_context *ctx, struct futhark_f64_1d *arr);
const int64_t *futhark_shape_f64_1d(struct futhark_context *ctx, struct futhark_f64_1d *arr);
struct futhark_f64_2d;
struct futhark_f64_2d *futhark_new_f64_2d(struct futhark_context *ctx, const double *data, int64_t dim0, int64_t dim1);
struct futhark_f64_2d *futhark_new_raw_f64_2d(struct futhark_context *ctx, unsigned char *data, int64_t dim0, int64_t dim1);
int futhark_free_f64_2d(struct futhark_context *ctx, struct futhark_f64_2d *arr);
int futhark_values_f64_2d(struct futhark_context *ctx, struct futhark_f64_2d *arr, double *data);
int futhark_index_f64_2d(struct futhark_context *ctx, double *out, struct futhark_f64_2d *arr, int64_t i0, int64_t i1);
unsigned char *futhark_values_raw_f64_2d(struct futhark_context *ctx, struct futhark_f64_2d *arr);
const int64_t *futhark_shape_f64_2d(struct futhark_context *ctx, struct futhark_f64_2d *arr);

// Opaque values



// Entry points
int futhark_entry_test_acc_prob(struct futhark_context *ctx, struct futhark_f64_1d **out0, const int64_t in0, const int64_t in1, const int64_t in2);
int futhark_entry_test_acc_prob_mat(struct futhark_context *ctx, struct futhark_f64_2d **out0, const int64_t in0, const int64_t in1, const int64_t in2);
int futhark_entry_test_bellman(struct futhark_context *ctx, struct futhark_f64_1d **out0, const int64_t in0, const struct futhark_f64_1d *in1, const int64_t in2);
int futhark_entry_test_bellmanN(struct futhark_context *ctx, struct futhark_f64_1d **out0, const int64_t in0, const struct futhark_f64_1d *in1, const int64_t in2, const int64_t in3);
int futhark_entry_test_carprice_buy(struct futhark_context *ctx, struct futhark_f64_1d **out0, const int64_t in0, const struct futhark_f64_1d *in1, const int64_t in2);
int futhark_entry_test_carprice_sell(struct futhark_context *ctx, struct futhark_f64_1d **out0, const int64_t in0, const struct futhark_f64_1d *in1, const int64_t in2);
int futhark_entry_test_ev_scrap(struct futhark_context *ctx, struct futhark_f64_1d **out0, const int64_t in0, const struct futhark_f64_1d *in1, const int64_t in2);
int futhark_entry_test_notrade(struct futhark_context *ctx, struct futhark_f64_2d **out0, const int64_t in0, const int64_t in1, const int64_t in2);
int futhark_entry_test_simple_prices(struct futhark_context *ctx, struct futhark_f64_2d **out0, const int64_t in0, const struct futhark_f64_1d *in1, const int64_t in2);
int futhark_entry_test_trade(struct futhark_context *ctx, struct futhark_f64_2d **out0, const int64_t in0, const int64_t in1, const int64_t in2);
int futhark_entry_test_utility(struct futhark_context *ctx, struct futhark_f64_2d **out0, const int64_t in0, const struct futhark_f64_1d *in1, const int64_t in2);
int futhark_entry_test_utility_2(struct futhark_context *ctx, struct futhark_f64_2d **out0, const int64_t in0, const struct futhark_f64_1d *in1, const int64_t in2, const struct futhark_f64_2d *in3);

// Miscellaneous
int futhark_context_sync(struct futhark_context *ctx);
void futhark_context_config_set_cache_file(struct futhark_context_config *cfg, const char *f);
char *futhark_context_get_error(struct futhark_context *ctx);
void futhark_context_set_logging_file(struct futhark_context *ctx, FILE *f);
void futhark_context_pause_profiling(struct futhark_context *ctx);
void futhark_context_unpause_profiling(struct futhark_context *ctx);
char *futhark_context_report(struct futhark_context *ctx);
int futhark_context_clear_caches(struct futhark_context *ctx);
#define FUTHARK_BACKEND_c
#define FUTHARK_SUCCESS 0
#define FUTHARK_PROGRAM_ERROR 2
#define FUTHARK_OUT_OF_MEMORY 3

#ifdef __cplusplus
}
#endif

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include <stdint.h>
// If NDEBUG is set, the assert() macro will do nothing. Since Futhark
// (unfortunately) makes use of assert() for error detection (and even some
// side effects), we want to avoid that.
#undef NDEBUG
#include <assert.h>
#include <stdarg.h>
#define SCALAR_FUN_ATTR static inline
// Start of util.h.
//
// Various helper functions that are useful in all generated C code.

#include <errno.h>
#include <string.h>

static const char *fut_progname = "(embedded Futhark)";

static void futhark_panic(int eval, const char *fmt, ...) __attribute__((noreturn));
static char* msgprintf(const char *s, ...);
static void* slurp_file(const char *filename, size_t *size);
static int dump_file(const char *file, const void *buf, size_t n);
struct str_builder;
static void str_builder_init(struct str_builder *b);
static void str_builder(struct str_builder *b, const char *s, ...);
static char *strclone(const char *str);

static void futhark_panic(int eval, const char *fmt, ...) {
  va_list ap;
  va_start(ap, fmt);
  fprintf(stderr, "%s: ", fut_progname);
  vfprintf(stderr, fmt, ap);
  va_end(ap);
  exit(eval);
}

// For generating arbitrary-sized error messages.  It is the callers
// responsibility to free the buffer at some point.
static char* msgprintf(const char *s, ...) {
  va_list vl;
  va_start(vl, s);
  size_t needed = 1 + (size_t)vsnprintf(NULL, 0, s, vl);
  char *buffer = (char*) malloc(needed);
  va_start(vl, s); // Must re-init.
  vsnprintf(buffer, needed, s, vl);
  return buffer;
}

static inline void check_err(int errval, int sets_errno, const char *fun, int line,
                             const char *msg, ...) {
  if (errval) {
    char errnum[10];

    va_list vl;
    va_start(vl, msg);

    fprintf(stderr, "ERROR: ");
    vfprintf(stderr, msg, vl);
    fprintf(stderr, " in %s() at line %d with error code %s\n",
            fun, line,
            sets_errno ? strerror(errno) : errnum);
    exit(errval);
  }
}

#define CHECK_ERR(err, ...) check_err(err, 0, __func__, __LINE__, __VA_ARGS__)
#define CHECK_ERRNO(err, ...) check_err(err, 1, __func__, __LINE__, __VA_ARGS__)

// Read the rest of an open file into a NUL-terminated string; returns
// NULL on error.
static void* fslurp_file(FILE *f, size_t *size) {
  long start = ftell(f);
  fseek(f, 0, SEEK_END);
  long src_size = ftell(f)-start;
  fseek(f, start, SEEK_SET);
  unsigned char *s = (unsigned char*) malloc((size_t)src_size + 1);
  if (fread(s, 1, (size_t)src_size, f) != (size_t)src_size) {
    free(s);
    s = NULL;
  } else {
    s[src_size] = '\0';
  }

  if (size) {
    *size = (size_t)src_size;
  }

  return s;
}

// Read a file into a NUL-terminated string; returns NULL on error.
static void* slurp_file(const char *filename, size_t *size) {
  FILE *f = fopen(filename, "rb"); // To avoid Windows messing with linebreaks.
  if (f == NULL) return NULL;
  unsigned char *s = fslurp_file(f, size);
  fclose(f);
  return s;
}

// Dump 'n' bytes from 'buf' into the file at the designated location.
// Returns 0 on success.
static int dump_file(const char *file, const void *buf, size_t n) {
  FILE *f = fopen(file, "w");

  if (f == NULL) {
    return 1;
  }

  if (fwrite(buf, sizeof(char), n, f) != n) {
    return 1;
  }

  if (fclose(f) != 0) {
    return 1;
  }

  return 0;
}

struct str_builder {
  char *str;
  size_t capacity; // Size of buffer.
  size_t used; // Bytes used, *not* including final zero.
};

static void str_builder_init(struct str_builder *b) {
  b->capacity = 10;
  b->used = 0;
  b->str = malloc(b->capacity);
  b->str[0] = 0;
}

static void str_builder(struct str_builder *b, const char *s, ...) {
  va_list vl;
  va_start(vl, s);
  size_t needed = (size_t)vsnprintf(NULL, 0, s, vl);

  while (b->capacity < b->used + needed + 1) {
    b->capacity *= 2;
    b->str = realloc(b->str, b->capacity);
  }

  va_start(vl, s); // Must re-init.
  vsnprintf(b->str+b->used, b->capacity-b->used, s, vl);
  b->used += needed;
}

static void str_builder_str(struct str_builder *b, const char *s) {
  size_t needed = strlen(s);
  if (b->capacity < b->used + needed + 1) {
    b->capacity *= 2;
    b->str = realloc(b->str, b->capacity);
  }
  strcpy(b->str+b->used, s);
  b->used += needed;
}

static void str_builder_char(struct str_builder *b, char c) {
  size_t needed = 1;
  if (b->capacity < b->used + needed + 1) {
    b->capacity *= 2;
    b->str = realloc(b->str, b->capacity);
  }
  b->str[b->used] = c;
  b->str[b->used+1] = 0;
  b->used += needed;
}

static void str_builder_json_str(struct str_builder* sb, const char* s) {
  str_builder_char(sb, '"');
  for (int j = 0; s[j]; j++) {
    char c = s[j];
    switch (c) {
    case '\n':
      str_builder_str(sb, "\\n");
      break;
    case '"':
      str_builder_str(sb, "\\\"");
      break;
    default:
      str_builder_char(sb, c);
    }
  }
  str_builder_char(sb, '"');
}

static char *strclone(const char *str) {
  size_t size = strlen(str) + 1;
  char *copy = (char*) malloc(size);
  if (copy == NULL) {
    return NULL;
  }

  memcpy(copy, str, size);
  return copy;
}

// Assumes NULL-terminated.
static char *strconcat(const char *src_fragments[]) {
  size_t src_len = 0;
  const char **p;

  for (p = src_fragments; *p; p++) {
    src_len += strlen(*p);
  }

  char *src = (char*) malloc(src_len + 1);
  size_t n = 0;
  for (p = src_fragments; *p; p++) {
    strcpy(src + n, *p);
    n += strlen(*p);
  }

  return src;
}

// End of util.h.
// Start of cache.h

#define CACHE_HASH_SIZE 8 // In 32-bit words.

struct cache_hash {
  uint32_t hash[CACHE_HASH_SIZE];
};

// Initialise a blank cache.
static void cache_hash_init(struct cache_hash *c);

// Hash some bytes and add them to the accumulated hash.
static void cache_hash(struct cache_hash *out, const char *in, size_t n);

// Try to restore cache contents from a file with the given name.
// Assumes the cache is invalid if it contains the given hash.
// Allocates memory and reads the cache conents, which is returned in
// *buf with size *buflen.  If the cache is successfully loaded, this
// function returns 0.  Otherwise it returns nonzero.  Errno is set if
// the failure to load the cache is due to anything except invalid
// cache conents.  Note that failing to restore the cache is not
// necessarily a problem: it might just be invalid or not created yet.
static int cache_restore(const char *fname, const struct cache_hash *hash,
                         unsigned char **buf, size_t *buflen);

// Store cache contents in the given file, with the given hash.
static int cache_store(const char *fname, const struct cache_hash *hash,
                       const unsigned char *buf, size_t buflen);

// Now for the implementation.

static void cache_hash_init(struct cache_hash *c) {
  memset(c->hash, 0, CACHE_HASH_SIZE * sizeof(uint32_t));
}

static void cache_hash(struct cache_hash *out, const char *in, size_t n) {
  // Adaptation of djb2 for larger output size by storing intermediate
  // states.
  uint32_t hash = 5381;
  for (size_t i = 0; i < n; i++) {
    hash = ((hash << 5) + hash) + in[i];
    out->hash[i % CACHE_HASH_SIZE] ^= hash;
  }
}

#define CACHE_HEADER_SIZE 8
static const char cache_header[CACHE_HEADER_SIZE] = "FUTHARK\0";

static int cache_restore(const char *fname, const struct cache_hash *hash,
                         unsigned char **buf, size_t *buflen) {
  FILE *f = fopen(fname, "rb");

  if (f == NULL) {
    return 1;
  }

  char f_header[CACHE_HEADER_SIZE];

  if (fread(f_header, sizeof(char), CACHE_HEADER_SIZE, f) != CACHE_HEADER_SIZE) {
    goto error;
  }

  if (memcmp(f_header, cache_header, CACHE_HEADER_SIZE) != 0) {
    goto error;
  }

  if (fseek(f, 0, SEEK_END) != 0) {
    goto error;
  }
  int64_t f_size = (int64_t)ftell(f);
  if (fseek(f, CACHE_HEADER_SIZE, SEEK_SET) != 0) {
    goto error;
  }

  int64_t expected_size;

  if (fread(&expected_size, sizeof(int64_t), 1, f) != 1) {
    goto error;
  }

  if (f_size != expected_size) {
    errno = 0;
    goto error;
  }

  int32_t f_hash[CACHE_HASH_SIZE];

  if (fread(f_hash, sizeof(int32_t), CACHE_HASH_SIZE, f) != CACHE_HASH_SIZE) {
    goto error;
  }

  if (memcmp(f_hash, hash->hash, CACHE_HASH_SIZE) != 0) {
    errno = 0;
    goto error;
  }

  *buflen = f_size - CACHE_HEADER_SIZE - sizeof(int64_t) - CACHE_HASH_SIZE*sizeof(int32_t);
  *buf = malloc(*buflen);
  if (fread(*buf, sizeof(char), *buflen, f) != *buflen) {
    free(*buf);
    goto error;
  }

  fclose(f);

  return 0;

 error:
  fclose(f);
  return 1;
}

static int cache_store(const char *fname, const struct cache_hash *hash,
                       const unsigned char *buf, size_t buflen) {
  FILE *f = fopen(fname, "wb");

  if (f == NULL) {
    return 1;
  }

  if (fwrite(cache_header, CACHE_HEADER_SIZE, 1, f) != 1) {
    goto error;
  }

  int64_t size = CACHE_HEADER_SIZE + sizeof(int64_t) + CACHE_HASH_SIZE*sizeof(int32_t) + buflen;

  if (fwrite(&size, sizeof(size), 1, f) != 1) {
    goto error;
  }

  if (fwrite(hash->hash, sizeof(int32_t), CACHE_HASH_SIZE, f) != CACHE_HASH_SIZE) {
    goto error;
  }

  if (fwrite(buf, sizeof(unsigned char), buflen, f) != buflen) {
    goto error;
  }

  fclose(f);

  return 0;

 error:
  fclose(f);
  return 1;
}

// End of cache.h
// Start of half.h.

// Conversion functions are from http://half.sourceforge.net/, but
// translated to C.
//
// Copyright (c) 2012-2021 Christian Rau
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

#ifndef __OPENCL_VERSION__
#define __constant
#endif

__constant static const uint16_t base_table[512] = {
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080, 0x0100,
  0x0200, 0x0400, 0x0800, 0x0C00, 0x1000, 0x1400, 0x1800, 0x1C00, 0x2000, 0x2400, 0x2800, 0x2C00, 0x3000, 0x3400, 0x3800, 0x3C00,
  0x4000, 0x4400, 0x4800, 0x4C00, 0x5000, 0x5400, 0x5800, 0x5C00, 0x6000, 0x6400, 0x6800, 0x6C00, 0x7000, 0x7400, 0x7800, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8001, 0x8002, 0x8004, 0x8008, 0x8010, 0x8020, 0x8040, 0x8080, 0x8100,
  0x8200, 0x8400, 0x8800, 0x8C00, 0x9000, 0x9400, 0x9800, 0x9C00, 0xA000, 0xA400, 0xA800, 0xAC00, 0xB000, 0xB400, 0xB800, 0xBC00,
  0xC000, 0xC400, 0xC800, 0xCC00, 0xD000, 0xD400, 0xD800, 0xDC00, 0xE000, 0xE400, 0xE800, 0xEC00, 0xF000, 0xF400, 0xF800, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00 };

__constant static const unsigned char shift_table[512] = {
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13 };

__constant static const uint32_t mantissa_table[2048] = {
  0x00000000, 0x33800000, 0x34000000, 0x34400000, 0x34800000, 0x34A00000, 0x34C00000, 0x34E00000, 0x35000000, 0x35100000, 0x35200000, 0x35300000, 0x35400000, 0x35500000, 0x35600000, 0x35700000,
  0x35800000, 0x35880000, 0x35900000, 0x35980000, 0x35A00000, 0x35A80000, 0x35B00000, 0x35B80000, 0x35C00000, 0x35C80000, 0x35D00000, 0x35D80000, 0x35E00000, 0x35E80000, 0x35F00000, 0x35F80000,
  0x36000000, 0x36040000, 0x36080000, 0x360C0000, 0x36100000, 0x36140000, 0x36180000, 0x361C0000, 0x36200000, 0x36240000, 0x36280000, 0x362C0000, 0x36300000, 0x36340000, 0x36380000, 0x363C0000,
  0x36400000, 0x36440000, 0x36480000, 0x364C0000, 0x36500000, 0x36540000, 0x36580000, 0x365C0000, 0x36600000, 0x36640000, 0x36680000, 0x366C0000, 0x36700000, 0x36740000, 0x36780000, 0x367C0000,
  0x36800000, 0x36820000, 0x36840000, 0x36860000, 0x36880000, 0x368A0000, 0x368C0000, 0x368E0000, 0x36900000, 0x36920000, 0x36940000, 0x36960000, 0x36980000, 0x369A0000, 0x369C0000, 0x369E0000,
  0x36A00000, 0x36A20000, 0x36A40000, 0x36A60000, 0x36A80000, 0x36AA0000, 0x36AC0000, 0x36AE0000, 0x36B00000, 0x36B20000, 0x36B40000, 0x36B60000, 0x36B80000, 0x36BA0000, 0x36BC0000, 0x36BE0000,
  0x36C00000, 0x36C20000, 0x36C40000, 0x36C60000, 0x36C80000, 0x36CA0000, 0x36CC0000, 0x36CE0000, 0x36D00000, 0x36D20000, 0x36D40000, 0x36D60000, 0x36D80000, 0x36DA0000, 0x36DC0000, 0x36DE0000,
  0x36E00000, 0x36E20000, 0x36E40000, 0x36E60000, 0x36E80000, 0x36EA0000, 0x36EC0000, 0x36EE0000, 0x36F00000, 0x36F20000, 0x36F40000, 0x36F60000, 0x36F80000, 0x36FA0000, 0x36FC0000, 0x36FE0000,
  0x37000000, 0x37010000, 0x37020000, 0x37030000, 0x37040000, 0x37050000, 0x37060000, 0x37070000, 0x37080000, 0x37090000, 0x370A0000, 0x370B0000, 0x370C0000, 0x370D0000, 0x370E0000, 0x370F0000,
  0x37100000, 0x37110000, 0x37120000, 0x37130000, 0x37140000, 0x37150000, 0x37160000, 0x37170000, 0x37180000, 0x37190000, 0x371A0000, 0x371B0000, 0x371C0000, 0x371D0000, 0x371E0000, 0x371F0000,
  0x37200000, 0x37210000, 0x37220000, 0x37230000, 0x37240000, 0x37250000, 0x37260000, 0x37270000, 0x37280000, 0x37290000, 0x372A0000, 0x372B0000, 0x372C0000, 0x372D0000, 0x372E0000, 0x372F0000,
  0x37300000, 0x37310000, 0x37320000, 0x37330000, 0x37340000, 0x37350000, 0x37360000, 0x37370000, 0x37380000, 0x37390000, 0x373A0000, 0x373B0000, 0x373C0000, 0x373D0000, 0x373E0000, 0x373F0000,
  0x37400000, 0x37410000, 0x37420000, 0x37430000, 0x37440000, 0x37450000, 0x37460000, 0x37470000, 0x37480000, 0x37490000, 0x374A0000, 0x374B0000, 0x374C0000, 0x374D0000, 0x374E0000, 0x374F0000,
  0x37500000, 0x37510000, 0x37520000, 0x37530000, 0x37540000, 0x37550000, 0x37560000, 0x37570000, 0x37580000, 0x37590000, 0x375A0000, 0x375B0000, 0x375C0000, 0x375D0000, 0x375E0000, 0x375F0000,
  0x37600000, 0x37610000, 0x37620000, 0x37630000, 0x37640000, 0x37650000, 0x37660000, 0x37670000, 0x37680000, 0x37690000, 0x376A0000, 0x376B0000, 0x376C0000, 0x376D0000, 0x376E0000, 0x376F0000,
  0x37700000, 0x37710000, 0x37720000, 0x37730000, 0x37740000, 0x37750000, 0x37760000, 0x37770000, 0x37780000, 0x37790000, 0x377A0000, 0x377B0000, 0x377C0000, 0x377D0000, 0x377E0000, 0x377F0000,
  0x37800000, 0x37808000, 0x37810000, 0x37818000, 0x37820000, 0x37828000, 0x37830000, 0x37838000, 0x37840000, 0x37848000, 0x37850000, 0x37858000, 0x37860000, 0x37868000, 0x37870000, 0x37878000,
  0x37880000, 0x37888000, 0x37890000, 0x37898000, 0x378A0000, 0x378A8000, 0x378B0000, 0x378B8000, 0x378C0000, 0x378C8000, 0x378D0000, 0x378D8000, 0x378E0000, 0x378E8000, 0x378F0000, 0x378F8000,
  0x37900000, 0x37908000, 0x37910000, 0x37918000, 0x37920000, 0x37928000, 0x37930000, 0x37938000, 0x37940000, 0x37948000, 0x37950000, 0x37958000, 0x37960000, 0x37968000, 0x37970000, 0x37978000,
  0x37980000, 0x37988000, 0x37990000, 0x37998000, 0x379A0000, 0x379A8000, 0x379B0000, 0x379B8000, 0x379C0000, 0x379C8000, 0x379D0000, 0x379D8000, 0x379E0000, 0x379E8000, 0x379F0000, 0x379F8000,
  0x37A00000, 0x37A08000, 0x37A10000, 0x37A18000, 0x37A20000, 0x37A28000, 0x37A30000, 0x37A38000, 0x37A40000, 0x37A48000, 0x37A50000, 0x37A58000, 0x37A60000, 0x37A68000, 0x37A70000, 0x37A78000,
  0x37A80000, 0x37A88000, 0x37A90000, 0x37A98000, 0x37AA0000, 0x37AA8000, 0x37AB0000, 0x37AB8000, 0x37AC0000, 0x37AC8000, 0x37AD0000, 0x37AD8000, 0x37AE0000, 0x37AE8000, 0x37AF0000, 0x37AF8000,
  0x37B00000, 0x37B08000, 0x37B10000, 0x37B18000, 0x37B20000, 0x37B28000, 0x37B30000, 0x37B38000, 0x37B40000, 0x37B48000, 0x37B50000, 0x37B58000, 0x37B60000, 0x37B68000, 0x37B70000, 0x37B78000,
  0x37B80000, 0x37B88000, 0x37B90000, 0x37B98000, 0x37BA0000, 0x37BA8000, 0x37BB0000, 0x37BB8000, 0x37BC0000, 0x37BC8000, 0x37BD0000, 0x37BD8000, 0x37BE0000, 0x37BE8000, 0x37BF0000, 0x37BF8000,
  0x37C00000, 0x37C08000, 0x37C10000, 0x37C18000, 0x37C20000, 0x37C28000, 0x37C30000, 0x37C38000, 0x37C40000, 0x37C48000, 0x37C50000, 0x37C58000, 0x37C60000, 0x37C68000, 0x37C70000, 0x37C78000,
  0x37C80000, 0x37C88000, 0x37C90000, 0x37C98000, 0x37CA0000, 0x37CA8000, 0x37CB0000, 0x37CB8000, 0x37CC0000, 0x37CC8000, 0x37CD0000, 0x37CD8000, 0x37CE0000, 0x37CE8000, 0x37CF0000, 0x37CF8000,
  0x37D00000, 0x37D08000, 0x37D10000, 0x37D18000, 0x37D20000, 0x37D28000, 0x37D30000, 0x37D38000, 0x37D40000, 0x37D48000, 0x37D50000, 0x37D58000, 0x37D60000, 0x37D68000, 0x37D70000, 0x37D78000,
  0x37D80000, 0x37D88000, 0x37D90000, 0x37D98000, 0x37DA0000, 0x37DA8000, 0x37DB0000, 0x37DB8000, 0x37DC0000, 0x37DC8000, 0x37DD0000, 0x37DD8000, 0x37DE0000, 0x37DE8000, 0x37DF0000, 0x37DF8000,
  0x37E00000, 0x37E08000, 0x37E10000, 0x37E18000, 0x37E20000, 0x37E28000, 0x37E30000, 0x37E38000, 0x37E40000, 0x37E48000, 0x37E50000, 0x37E58000, 0x37E60000, 0x37E68000, 0x37E70000, 0x37E78000,
  0x37E80000, 0x37E88000, 0x37E90000, 0x37E98000, 0x37EA0000, 0x37EA8000, 0x37EB0000, 0x37EB8000, 0x37EC0000, 0x37EC8000, 0x37ED0000, 0x37ED8000, 0x37EE0000, 0x37EE8000, 0x37EF0000, 0x37EF8000,
  0x37F00000, 0x37F08000, 0x37F10000, 0x37F18000, 0x37F20000, 0x37F28000, 0x37F30000, 0x37F38000, 0x37F40000, 0x37F48000, 0x37F50000, 0x37F58000, 0x37F60000, 0x37F68000, 0x37F70000, 0x37F78000,
  0x37F80000, 0x37F88000, 0x37F90000, 0x37F98000, 0x37FA0000, 0x37FA8000, 0x37FB0000, 0x37FB8000, 0x37FC0000, 0x37FC8000, 0x37FD0000, 0x37FD8000, 0x37FE0000, 0x37FE8000, 0x37FF0000, 0x37FF8000,
  0x38000000, 0x38004000, 0x38008000, 0x3800C000, 0x38010000, 0x38014000, 0x38018000, 0x3801C000, 0x38020000, 0x38024000, 0x38028000, 0x3802C000, 0x38030000, 0x38034000, 0x38038000, 0x3803C000,
  0x38040000, 0x38044000, 0x38048000, 0x3804C000, 0x38050000, 0x38054000, 0x38058000, 0x3805C000, 0x38060000, 0x38064000, 0x38068000, 0x3806C000, 0x38070000, 0x38074000, 0x38078000, 0x3807C000,
  0x38080000, 0x38084000, 0x38088000, 0x3808C000, 0x38090000, 0x38094000, 0x38098000, 0x3809C000, 0x380A0000, 0x380A4000, 0x380A8000, 0x380AC000, 0x380B0000, 0x380B4000, 0x380B8000, 0x380BC000,
  0x380C0000, 0x380C4000, 0x380C8000, 0x380CC000, 0x380D0000, 0x380D4000, 0x380D8000, 0x380DC000, 0x380E0000, 0x380E4000, 0x380E8000, 0x380EC000, 0x380F0000, 0x380F4000, 0x380F8000, 0x380FC000,
  0x38100000, 0x38104000, 0x38108000, 0x3810C000, 0x38110000, 0x38114000, 0x38118000, 0x3811C000, 0x38120000, 0x38124000, 0x38128000, 0x3812C000, 0x38130000, 0x38134000, 0x38138000, 0x3813C000,
  0x38140000, 0x38144000, 0x38148000, 0x3814C000, 0x38150000, 0x38154000, 0x38158000, 0x3815C000, 0x38160000, 0x38164000, 0x38168000, 0x3816C000, 0x38170000, 0x38174000, 0x38178000, 0x3817C000,
  0x38180000, 0x38184000, 0x38188000, 0x3818C000, 0x38190000, 0x38194000, 0x38198000, 0x3819C000, 0x381A0000, 0x381A4000, 0x381A8000, 0x381AC000, 0x381B0000, 0x381B4000, 0x381B8000, 0x381BC000,
  0x381C0000, 0x381C4000, 0x381C8000, 0x381CC000, 0x381D0000, 0x381D4000, 0x381D8000, 0x381DC000, 0x381E0000, 0x381E4000, 0x381E8000, 0x381EC000, 0x381F0000, 0x381F4000, 0x381F8000, 0x381FC000,
  0x38200000, 0x38204000, 0x38208000, 0x3820C000, 0x38210000, 0x38214000, 0x38218000, 0x3821C000, 0x38220000, 0x38224000, 0x38228000, 0x3822C000, 0x38230000, 0x38234000, 0x38238000, 0x3823C000,
  0x38240000, 0x38244000, 0x38248000, 0x3824C000, 0x38250000, 0x38254000, 0x38258000, 0x3825C000, 0x38260000, 0x38264000, 0x38268000, 0x3826C000, 0x38270000, 0x38274000, 0x38278000, 0x3827C000,
  0x38280000, 0x38284000, 0x38288000, 0x3828C000, 0x38290000, 0x38294000, 0x38298000, 0x3829C000, 0x382A0000, 0x382A4000, 0x382A8000, 0x382AC000, 0x382B0000, 0x382B4000, 0x382B8000, 0x382BC000,
  0x382C0000, 0x382C4000, 0x382C8000, 0x382CC000, 0x382D0000, 0x382D4000, 0x382D8000, 0x382DC000, 0x382E0000, 0x382E4000, 0x382E8000, 0x382EC000, 0x382F0000, 0x382F4000, 0x382F8000, 0x382FC000,
  0x38300000, 0x38304000, 0x38308000, 0x3830C000, 0x38310000, 0x38314000, 0x38318000, 0x3831C000, 0x38320000, 0x38324000, 0x38328000, 0x3832C000, 0x38330000, 0x38334000, 0x38338000, 0x3833C000,
  0x38340000, 0x38344000, 0x38348000, 0x3834C000, 0x38350000, 0x38354000, 0x38358000, 0x3835C000, 0x38360000, 0x38364000, 0x38368000, 0x3836C000, 0x38370000, 0x38374000, 0x38378000, 0x3837C000,
  0x38380000, 0x38384000, 0x38388000, 0x3838C000, 0x38390000, 0x38394000, 0x38398000, 0x3839C000, 0x383A0000, 0x383A4000, 0x383A8000, 0x383AC000, 0x383B0000, 0x383B4000, 0x383B8000, 0x383BC000,
  0x383C0000, 0x383C4000, 0x383C8000, 0x383CC000, 0x383D0000, 0x383D4000, 0x383D8000, 0x383DC000, 0x383E0000, 0x383E4000, 0x383E8000, 0x383EC000, 0x383F0000, 0x383F4000, 0x383F8000, 0x383FC000,
  0x38400000, 0x38404000, 0x38408000, 0x3840C000, 0x38410000, 0x38414000, 0x38418000, 0x3841C000, 0x38420000, 0x38424000, 0x38428000, 0x3842C000, 0x38430000, 0x38434000, 0x38438000, 0x3843C000,
  0x38440000, 0x38444000, 0x38448000, 0x3844C000, 0x38450000, 0x38454000, 0x38458000, 0x3845C000, 0x38460000, 0x38464000, 0x38468000, 0x3846C000, 0x38470000, 0x38474000, 0x38478000, 0x3847C000,
  0x38480000, 0x38484000, 0x38488000, 0x3848C000, 0x38490000, 0x38494000, 0x38498000, 0x3849C000, 0x384A0000, 0x384A4000, 0x384A8000, 0x384AC000, 0x384B0000, 0x384B4000, 0x384B8000, 0x384BC000,
  0x384C0000, 0x384C4000, 0x384C8000, 0x384CC000, 0x384D0000, 0x384D4000, 0x384D8000, 0x384DC000, 0x384E0000, 0x384E4000, 0x384E8000, 0x384EC000, 0x384F0000, 0x384F4000, 0x384F8000, 0x384FC000,
  0x38500000, 0x38504000, 0x38508000, 0x3850C000, 0x38510000, 0x38514000, 0x38518000, 0x3851C000, 0x38520000, 0x38524000, 0x38528000, 0x3852C000, 0x38530000, 0x38534000, 0x38538000, 0x3853C000,
  0x38540000, 0x38544000, 0x38548000, 0x3854C000, 0x38550000, 0x38554000, 0x38558000, 0x3855C000, 0x38560000, 0x38564000, 0x38568000, 0x3856C000, 0x38570000, 0x38574000, 0x38578000, 0x3857C000,
  0x38580000, 0x38584000, 0x38588000, 0x3858C000, 0x38590000, 0x38594000, 0x38598000, 0x3859C000, 0x385A0000, 0x385A4000, 0x385A8000, 0x385AC000, 0x385B0000, 0x385B4000, 0x385B8000, 0x385BC000,
  0x385C0000, 0x385C4000, 0x385C8000, 0x385CC000, 0x385D0000, 0x385D4000, 0x385D8000, 0x385DC000, 0x385E0000, 0x385E4000, 0x385E8000, 0x385EC000, 0x385F0000, 0x385F4000, 0x385F8000, 0x385FC000,
  0x38600000, 0x38604000, 0x38608000, 0x3860C000, 0x38610000, 0x38614000, 0x38618000, 0x3861C000, 0x38620000, 0x38624000, 0x38628000, 0x3862C000, 0x38630000, 0x38634000, 0x38638000, 0x3863C000,
  0x38640000, 0x38644000, 0x38648000, 0x3864C000, 0x38650000, 0x38654000, 0x38658000, 0x3865C000, 0x38660000, 0x38664000, 0x38668000, 0x3866C000, 0x38670000, 0x38674000, 0x38678000, 0x3867C000,
  0x38680000, 0x38684000, 0x38688000, 0x3868C000, 0x38690000, 0x38694000, 0x38698000, 0x3869C000, 0x386A0000, 0x386A4000, 0x386A8000, 0x386AC000, 0x386B0000, 0x386B4000, 0x386B8000, 0x386BC000,
  0x386C0000, 0x386C4000, 0x386C8000, 0x386CC000, 0x386D0000, 0x386D4000, 0x386D8000, 0x386DC000, 0x386E0000, 0x386E4000, 0x386E8000, 0x386EC000, 0x386F0000, 0x386F4000, 0x386F8000, 0x386FC000,
  0x38700000, 0x38704000, 0x38708000, 0x3870C000, 0x38710000, 0x38714000, 0x38718000, 0x3871C000, 0x38720000, 0x38724000, 0x38728000, 0x3872C000, 0x38730000, 0x38734000, 0x38738000, 0x3873C000,
  0x38740000, 0x38744000, 0x38748000, 0x3874C000, 0x38750000, 0x38754000, 0x38758000, 0x3875C000, 0x38760000, 0x38764000, 0x38768000, 0x3876C000, 0x38770000, 0x38774000, 0x38778000, 0x3877C000,
  0x38780000, 0x38784000, 0x38788000, 0x3878C000, 0x38790000, 0x38794000, 0x38798000, 0x3879C000, 0x387A0000, 0x387A4000, 0x387A8000, 0x387AC000, 0x387B0000, 0x387B4000, 0x387B8000, 0x387BC000,
  0x387C0000, 0x387C4000, 0x387C8000, 0x387CC000, 0x387D0000, 0x387D4000, 0x387D8000, 0x387DC000, 0x387E0000, 0x387E4000, 0x387E8000, 0x387EC000, 0x387F0000, 0x387F4000, 0x387F8000, 0x387FC000,
  0x38000000, 0x38002000, 0x38004000, 0x38006000, 0x38008000, 0x3800A000, 0x3800C000, 0x3800E000, 0x38010000, 0x38012000, 0x38014000, 0x38016000, 0x38018000, 0x3801A000, 0x3801C000, 0x3801E000,
  0x38020000, 0x38022000, 0x38024000, 0x38026000, 0x38028000, 0x3802A000, 0x3802C000, 0x3802E000, 0x38030000, 0x38032000, 0x38034000, 0x38036000, 0x38038000, 0x3803A000, 0x3803C000, 0x3803E000,
  0x38040000, 0x38042000, 0x38044000, 0x38046000, 0x38048000, 0x3804A000, 0x3804C000, 0x3804E000, 0x38050000, 0x38052000, 0x38054000, 0x38056000, 0x38058000, 0x3805A000, 0x3805C000, 0x3805E000,
  0x38060000, 0x38062000, 0x38064000, 0x38066000, 0x38068000, 0x3806A000, 0x3806C000, 0x3806E000, 0x38070000, 0x38072000, 0x38074000, 0x38076000, 0x38078000, 0x3807A000, 0x3807C000, 0x3807E000,
  0x38080000, 0x38082000, 0x38084000, 0x38086000, 0x38088000, 0x3808A000, 0x3808C000, 0x3808E000, 0x38090000, 0x38092000, 0x38094000, 0x38096000, 0x38098000, 0x3809A000, 0x3809C000, 0x3809E000,
  0x380A0000, 0x380A2000, 0x380A4000, 0x380A6000, 0x380A8000, 0x380AA000, 0x380AC000, 0x380AE000, 0x380B0000, 0x380B2000, 0x380B4000, 0x380B6000, 0x380B8000, 0x380BA000, 0x380BC000, 0x380BE000,
  0x380C0000, 0x380C2000, 0x380C4000, 0x380C6000, 0x380C8000, 0x380CA000, 0x380CC000, 0x380CE000, 0x380D0000, 0x380D2000, 0x380D4000, 0x380D6000, 0x380D8000, 0x380DA000, 0x380DC000, 0x380DE000,
  0x380E0000, 0x380E2000, 0x380E4000, 0x380E6000, 0x380E8000, 0x380EA000, 0x380EC000, 0x380EE000, 0x380F0000, 0x380F2000, 0x380F4000, 0x380F6000, 0x380F8000, 0x380FA000, 0x380FC000, 0x380FE000,
  0x38100000, 0x38102000, 0x38104000, 0x38106000, 0x38108000, 0x3810A000, 0x3810C000, 0x3810E000, 0x38110000, 0x38112000, 0x38114000, 0x38116000, 0x38118000, 0x3811A000, 0x3811C000, 0x3811E000,
  0x38120000, 0x38122000, 0x38124000, 0x38126000, 0x38128000, 0x3812A000, 0x3812C000, 0x3812E000, 0x38130000, 0x38132000, 0x38134000, 0x38136000, 0x38138000, 0x3813A000, 0x3813C000, 0x3813E000,
  0x38140000, 0x38142000, 0x38144000, 0x38146000, 0x38148000, 0x3814A000, 0x3814C000, 0x3814E000, 0x38150000, 0x38152000, 0x38154000, 0x38156000, 0x38158000, 0x3815A000, 0x3815C000, 0x3815E000,
  0x38160000, 0x38162000, 0x38164000, 0x38166000, 0x38168000, 0x3816A000, 0x3816C000, 0x3816E000, 0x38170000, 0x38172000, 0x38174000, 0x38176000, 0x38178000, 0x3817A000, 0x3817C000, 0x3817E000,
  0x38180000, 0x38182000, 0x38184000, 0x38186000, 0x38188000, 0x3818A000, 0x3818C000, 0x3818E000, 0x38190000, 0x38192000, 0x38194000, 0x38196000, 0x38198000, 0x3819A000, 0x3819C000, 0x3819E000,
  0x381A0000, 0x381A2000, 0x381A4000, 0x381A6000, 0x381A8000, 0x381AA000, 0x381AC000, 0x381AE000, 0x381B0000, 0x381B2000, 0x381B4000, 0x381B6000, 0x381B8000, 0x381BA000, 0x381BC000, 0x381BE000,
  0x381C0000, 0x381C2000, 0x381C4000, 0x381C6000, 0x381C8000, 0x381CA000, 0x381CC000, 0x381CE000, 0x381D0000, 0x381D2000, 0x381D4000, 0x381D6000, 0x381D8000, 0x381DA000, 0x381DC000, 0x381DE000,
  0x381E0000, 0x381E2000, 0x381E4000, 0x381E6000, 0x381E8000, 0x381EA000, 0x381EC000, 0x381EE000, 0x381F0000, 0x381F2000, 0x381F4000, 0x381F6000, 0x381F8000, 0x381FA000, 0x381FC000, 0x381FE000,
  0x38200000, 0x38202000, 0x38204000, 0x38206000, 0x38208000, 0x3820A000, 0x3820C000, 0x3820E000, 0x38210000, 0x38212000, 0x38214000, 0x38216000, 0x38218000, 0x3821A000, 0x3821C000, 0x3821E000,
  0x38220000, 0x38222000, 0x38224000, 0x38226000, 0x38228000, 0x3822A000, 0x3822C000, 0x3822E000, 0x38230000, 0x38232000, 0x38234000, 0x38236000, 0x38238000, 0x3823A000, 0x3823C000, 0x3823E000,
  0x38240000, 0x38242000, 0x38244000, 0x38246000, 0x38248000, 0x3824A000, 0x3824C000, 0x3824E000, 0x38250000, 0x38252000, 0x38254000, 0x38256000, 0x38258000, 0x3825A000, 0x3825C000, 0x3825E000,
  0x38260000, 0x38262000, 0x38264000, 0x38266000, 0x38268000, 0x3826A000, 0x3826C000, 0x3826E000, 0x38270000, 0x38272000, 0x38274000, 0x38276000, 0x38278000, 0x3827A000, 0x3827C000, 0x3827E000,
  0x38280000, 0x38282000, 0x38284000, 0x38286000, 0x38288000, 0x3828A000, 0x3828C000, 0x3828E000, 0x38290000, 0x38292000, 0x38294000, 0x38296000, 0x38298000, 0x3829A000, 0x3829C000, 0x3829E000,
  0x382A0000, 0x382A2000, 0x382A4000, 0x382A6000, 0x382A8000, 0x382AA000, 0x382AC000, 0x382AE000, 0x382B0000, 0x382B2000, 0x382B4000, 0x382B6000, 0x382B8000, 0x382BA000, 0x382BC000, 0x382BE000,
  0x382C0000, 0x382C2000, 0x382C4000, 0x382C6000, 0x382C8000, 0x382CA000, 0x382CC000, 0x382CE000, 0x382D0000, 0x382D2000, 0x382D4000, 0x382D6000, 0x382D8000, 0x382DA000, 0x382DC000, 0x382DE000,
  0x382E0000, 0x382E2000, 0x382E4000, 0x382E6000, 0x382E8000, 0x382EA000, 0x382EC000, 0x382EE000, 0x382F0000, 0x382F2000, 0x382F4000, 0x382F6000, 0x382F8000, 0x382FA000, 0x382FC000, 0x382FE000,
  0x38300000, 0x38302000, 0x38304000, 0x38306000, 0x38308000, 0x3830A000, 0x3830C000, 0x3830E000, 0x38310000, 0x38312000, 0x38314000, 0x38316000, 0x38318000, 0x3831A000, 0x3831C000, 0x3831E000,
  0x38320000, 0x38322000, 0x38324000, 0x38326000, 0x38328000, 0x3832A000, 0x3832C000, 0x3832E000, 0x38330000, 0x38332000, 0x38334000, 0x38336000, 0x38338000, 0x3833A000, 0x3833C000, 0x3833E000,
  0x38340000, 0x38342000, 0x38344000, 0x38346000, 0x38348000, 0x3834A000, 0x3834C000, 0x3834E000, 0x38350000, 0x38352000, 0x38354000, 0x38356000, 0x38358000, 0x3835A000, 0x3835C000, 0x3835E000,
  0x38360000, 0x38362000, 0x38364000, 0x38366000, 0x38368000, 0x3836A000, 0x3836C000, 0x3836E000, 0x38370000, 0x38372000, 0x38374000, 0x38376000, 0x38378000, 0x3837A000, 0x3837C000, 0x3837E000,
  0x38380000, 0x38382000, 0x38384000, 0x38386000, 0x38388000, 0x3838A000, 0x3838C000, 0x3838E000, 0x38390000, 0x38392000, 0x38394000, 0x38396000, 0x38398000, 0x3839A000, 0x3839C000, 0x3839E000,
  0x383A0000, 0x383A2000, 0x383A4000, 0x383A6000, 0x383A8000, 0x383AA000, 0x383AC000, 0x383AE000, 0x383B0000, 0x383B2000, 0x383B4000, 0x383B6000, 0x383B8000, 0x383BA000, 0x383BC000, 0x383BE000,
  0x383C0000, 0x383C2000, 0x383C4000, 0x383C6000, 0x383C8000, 0x383CA000, 0x383CC000, 0x383CE000, 0x383D0000, 0x383D2000, 0x383D4000, 0x383D6000, 0x383D8000, 0x383DA000, 0x383DC000, 0x383DE000,
  0x383E0000, 0x383E2000, 0x383E4000, 0x383E6000, 0x383E8000, 0x383EA000, 0x383EC000, 0x383EE000, 0x383F0000, 0x383F2000, 0x383F4000, 0x383F6000, 0x383F8000, 0x383FA000, 0x383FC000, 0x383FE000,
  0x38400000, 0x38402000, 0x38404000, 0x38406000, 0x38408000, 0x3840A000, 0x3840C000, 0x3840E000, 0x38410000, 0x38412000, 0x38414000, 0x38416000, 0x38418000, 0x3841A000, 0x3841C000, 0x3841E000,
  0x38420000, 0x38422000, 0x38424000, 0x38426000, 0x38428000, 0x3842A000, 0x3842C000, 0x3842E000, 0x38430000, 0x38432000, 0x38434000, 0x38436000, 0x38438000, 0x3843A000, 0x3843C000, 0x3843E000,
  0x38440000, 0x38442000, 0x38444000, 0x38446000, 0x38448000, 0x3844A000, 0x3844C000, 0x3844E000, 0x38450000, 0x38452000, 0x38454000, 0x38456000, 0x38458000, 0x3845A000, 0x3845C000, 0x3845E000,
  0x38460000, 0x38462000, 0x38464000, 0x38466000, 0x38468000, 0x3846A000, 0x3846C000, 0x3846E000, 0x38470000, 0x38472000, 0x38474000, 0x38476000, 0x38478000, 0x3847A000, 0x3847C000, 0x3847E000,
  0x38480000, 0x38482000, 0x38484000, 0x38486000, 0x38488000, 0x3848A000, 0x3848C000, 0x3848E000, 0x38490000, 0x38492000, 0x38494000, 0x38496000, 0x38498000, 0x3849A000, 0x3849C000, 0x3849E000,
  0x384A0000, 0x384A2000, 0x384A4000, 0x384A6000, 0x384A8000, 0x384AA000, 0x384AC000, 0x384AE000, 0x384B0000, 0x384B2000, 0x384B4000, 0x384B6000, 0x384B8000, 0x384BA000, 0x384BC000, 0x384BE000,
  0x384C0000, 0x384C2000, 0x384C4000, 0x384C6000, 0x384C8000, 0x384CA000, 0x384CC000, 0x384CE000, 0x384D0000, 0x384D2000, 0x384D4000, 0x384D6000, 0x384D8000, 0x384DA000, 0x384DC000, 0x384DE000,
  0x384E0000, 0x384E2000, 0x384E4000, 0x384E6000, 0x384E8000, 0x384EA000, 0x384EC000, 0x384EE000, 0x384F0000, 0x384F2000, 0x384F4000, 0x384F6000, 0x384F8000, 0x384FA000, 0x384FC000, 0x384FE000,
  0x38500000, 0x38502000, 0x38504000, 0x38506000, 0x38508000, 0x3850A000, 0x3850C000, 0x3850E000, 0x38510000, 0x38512000, 0x38514000, 0x38516000, 0x38518000, 0x3851A000, 0x3851C000, 0x3851E000,
  0x38520000, 0x38522000, 0x38524000, 0x38526000, 0x38528000, 0x3852A000, 0x3852C000, 0x3852E000, 0x38530000, 0x38532000, 0x38534000, 0x38536000, 0x38538000, 0x3853A000, 0x3853C000, 0x3853E000,
  0x38540000, 0x38542000, 0x38544000, 0x38546000, 0x38548000, 0x3854A000, 0x3854C000, 0x3854E000, 0x38550000, 0x38552000, 0x38554000, 0x38556000, 0x38558000, 0x3855A000, 0x3855C000, 0x3855E000,
  0x38560000, 0x38562000, 0x38564000, 0x38566000, 0x38568000, 0x3856A000, 0x3856C000, 0x3856E000, 0x38570000, 0x38572000, 0x38574000, 0x38576000, 0x38578000, 0x3857A000, 0x3857C000, 0x3857E000,
  0x38580000, 0x38582000, 0x38584000, 0x38586000, 0x38588000, 0x3858A000, 0x3858C000, 0x3858E000, 0x38590000, 0x38592000, 0x38594000, 0x38596000, 0x38598000, 0x3859A000, 0x3859C000, 0x3859E000,
  0x385A0000, 0x385A2000, 0x385A4000, 0x385A6000, 0x385A8000, 0x385AA000, 0x385AC000, 0x385AE000, 0x385B0000, 0x385B2000, 0x385B4000, 0x385B6000, 0x385B8000, 0x385BA000, 0x385BC000, 0x385BE000,
  0x385C0000, 0x385C2000, 0x385C4000, 0x385C6000, 0x385C8000, 0x385CA000, 0x385CC000, 0x385CE000, 0x385D0000, 0x385D2000, 0x385D4000, 0x385D6000, 0x385D8000, 0x385DA000, 0x385DC000, 0x385DE000,
  0x385E0000, 0x385E2000, 0x385E4000, 0x385E6000, 0x385E8000, 0x385EA000, 0x385EC000, 0x385EE000, 0x385F0000, 0x385F2000, 0x385F4000, 0x385F6000, 0x385F8000, 0x385FA000, 0x385FC000, 0x385FE000,
  0x38600000, 0x38602000, 0x38604000, 0x38606000, 0x38608000, 0x3860A000, 0x3860C000, 0x3860E000, 0x38610000, 0x38612000, 0x38614000, 0x38616000, 0x38618000, 0x3861A000, 0x3861C000, 0x3861E000,
  0x38620000, 0x38622000, 0x38624000, 0x38626000, 0x38628000, 0x3862A000, 0x3862C000, 0x3862E000, 0x38630000, 0x38632000, 0x38634000, 0x38636000, 0x38638000, 0x3863A000, 0x3863C000, 0x3863E000,
  0x38640000, 0x38642000, 0x38644000, 0x38646000, 0x38648000, 0x3864A000, 0x3864C000, 0x3864E000, 0x38650000, 0x38652000, 0x38654000, 0x38656000, 0x38658000, 0x3865A000, 0x3865C000, 0x3865E000,
  0x38660000, 0x38662000, 0x38664000, 0x38666000, 0x38668000, 0x3866A000, 0x3866C000, 0x3866E000, 0x38670000, 0x38672000, 0x38674000, 0x38676000, 0x38678000, 0x3867A000, 0x3867C000, 0x3867E000,
  0x38680000, 0x38682000, 0x38684000, 0x38686000, 0x38688000, 0x3868A000, 0x3868C000, 0x3868E000, 0x38690000, 0x38692000, 0x38694000, 0x38696000, 0x38698000, 0x3869A000, 0x3869C000, 0x3869E000,
  0x386A0000, 0x386A2000, 0x386A4000, 0x386A6000, 0x386A8000, 0x386AA000, 0x386AC000, 0x386AE000, 0x386B0000, 0x386B2000, 0x386B4000, 0x386B6000, 0x386B8000, 0x386BA000, 0x386BC000, 0x386BE000,
  0x386C0000, 0x386C2000, 0x386C4000, 0x386C6000, 0x386C8000, 0x386CA000, 0x386CC000, 0x386CE000, 0x386D0000, 0x386D2000, 0x386D4000, 0x386D6000, 0x386D8000, 0x386DA000, 0x386DC000, 0x386DE000,
  0x386E0000, 0x386E2000, 0x386E4000, 0x386E6000, 0x386E8000, 0x386EA000, 0x386EC000, 0x386EE000, 0x386F0000, 0x386F2000, 0x386F4000, 0x386F6000, 0x386F8000, 0x386FA000, 0x386FC000, 0x386FE000,
  0x38700000, 0x38702000, 0x38704000, 0x38706000, 0x38708000, 0x3870A000, 0x3870C000, 0x3870E000, 0x38710000, 0x38712000, 0x38714000, 0x38716000, 0x38718000, 0x3871A000, 0x3871C000, 0x3871E000,
  0x38720000, 0x38722000, 0x38724000, 0x38726000, 0x38728000, 0x3872A000, 0x3872C000, 0x3872E000, 0x38730000, 0x38732000, 0x38734000, 0x38736000, 0x38738000, 0x3873A000, 0x3873C000, 0x3873E000,
  0x38740000, 0x38742000, 0x38744000, 0x38746000, 0x38748000, 0x3874A000, 0x3874C000, 0x3874E000, 0x38750000, 0x38752000, 0x38754000, 0x38756000, 0x38758000, 0x3875A000, 0x3875C000, 0x3875E000,
  0x38760000, 0x38762000, 0x38764000, 0x38766000, 0x38768000, 0x3876A000, 0x3876C000, 0x3876E000, 0x38770000, 0x38772000, 0x38774000, 0x38776000, 0x38778000, 0x3877A000, 0x3877C000, 0x3877E000,
  0x38780000, 0x38782000, 0x38784000, 0x38786000, 0x38788000, 0x3878A000, 0x3878C000, 0x3878E000, 0x38790000, 0x38792000, 0x38794000, 0x38796000, 0x38798000, 0x3879A000, 0x3879C000, 0x3879E000,
  0x387A0000, 0x387A2000, 0x387A4000, 0x387A6000, 0x387A8000, 0x387AA000, 0x387AC000, 0x387AE000, 0x387B0000, 0x387B2000, 0x387B4000, 0x387B6000, 0x387B8000, 0x387BA000, 0x387BC000, 0x387BE000,
  0x387C0000, 0x387C2000, 0x387C4000, 0x387C6000, 0x387C8000, 0x387CA000, 0x387CC000, 0x387CE000, 0x387D0000, 0x387D2000, 0x387D4000, 0x387D6000, 0x387D8000, 0x387DA000, 0x387DC000, 0x387DE000,
  0x387E0000, 0x387E2000, 0x387E4000, 0x387E6000, 0x387E8000, 0x387EA000, 0x387EC000, 0x387EE000, 0x387F0000, 0x387F2000, 0x387F4000, 0x387F6000, 0x387F8000, 0x387FA000, 0x387FC000, 0x387FE000 };
__constant static const uint32_t exponent_table[64] = {
  0x00000000, 0x00800000, 0x01000000, 0x01800000, 0x02000000, 0x02800000, 0x03000000, 0x03800000, 0x04000000, 0x04800000, 0x05000000, 0x05800000, 0x06000000, 0x06800000, 0x07000000, 0x07800000,
  0x08000000, 0x08800000, 0x09000000, 0x09800000, 0x0A000000, 0x0A800000, 0x0B000000, 0x0B800000, 0x0C000000, 0x0C800000, 0x0D000000, 0x0D800000, 0x0E000000, 0x0E800000, 0x0F000000, 0x47800000,
  0x80000000, 0x80800000, 0x81000000, 0x81800000, 0x82000000, 0x82800000, 0x83000000, 0x83800000, 0x84000000, 0x84800000, 0x85000000, 0x85800000, 0x86000000, 0x86800000, 0x87000000, 0x87800000,
  0x88000000, 0x88800000, 0x89000000, 0x89800000, 0x8A000000, 0x8A800000, 0x8B000000, 0x8B800000, 0x8C000000, 0x8C800000, 0x8D000000, 0x8D800000, 0x8E000000, 0x8E800000, 0x8F000000, 0xC7800000 };
__constant static const unsigned short offset_table[64] = {
  0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024,
  0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024 };

SCALAR_FUN_ATTR uint16_t float2halfbits(float value) {
  union { float x; uint32_t y; } u;
  u.x = value;
  uint32_t bits = u.y;

  uint16_t hbits = base_table[bits>>23] + (uint16_t)((bits&0x7FFFFF)>>shift_table[bits>>23]);;

  return hbits;
}

SCALAR_FUN_ATTR float halfbits2float(uint16_t value) {
  uint32_t bits = mantissa_table[offset_table[value>>10]+(value&0x3FF)] + exponent_table[value>>10];

  union { uint32_t x; float y; } u;
  u.x = bits;
  return u.y;
}

SCALAR_FUN_ATTR uint16_t halfbitsnextafter(uint16_t from, uint16_t to) {
  int fabs = from & 0x7FFF, tabs = to & 0x7FFF;
  if(fabs > 0x7C00 || tabs > 0x7C00) {
    return ((from&0x7FFF)>0x7C00) ? (from|0x200) : (to|0x200);
  }
  if(from == to || !(fabs|tabs)) {
    return to;
  }
  if(!fabs) {
    return (to&0x8000)+1;
  }
  unsigned int out =
    from +
    (((from>>15)^(unsigned int)((from^(0x8000|(0x8000-(from>>15))))<(to^(0x8000|(0x8000-(to>>15))))))<<1)
    - 1;
  return out;
}

// End of half.h.
// Start of timing.h.

// The function get_wall_time() returns the wall time in microseconds
// (with an unspecified offset).

#ifdef _WIN32

#include <windows.h>

static int64_t get_wall_time(void) {
  LARGE_INTEGER time,freq;
  assert(QueryPerformanceFrequency(&freq));
  assert(QueryPerformanceCounter(&time));
  return ((double)time.QuadPart / freq.QuadPart) * 1000000;
}

static int64_t get_wall_time_ns(void) {
  return get_wall_time() * 1000;
}

#else
// Assuming POSIX

#include <time.h>
#include <sys/time.h>

static int64_t get_wall_time_ns(void) {
  struct timespec time;
  assert(clock_gettime(CLOCK_MONOTONIC, &time) == 0);
  return time.tv_sec * 1000000000 + time.tv_nsec;
}

static int64_t get_wall_time(void) {
  return get_wall_time_ns() / 1000;
}


#endif

// End of timing.h.
// Start of lock.h.

// A very simple cross-platform implementation of locks.  Uses
// pthreads on Unix and some Windows thing there.  Futhark's
// host-level code is not multithreaded, but user code may be, so we
// need some mechanism for ensuring atomic access to API functions.
// This is that mechanism.  It is not exposed to user code at all, so
// we do not have to worry about name collisions.

#ifdef _WIN32

typedef HANDLE lock_t;

static void create_lock(lock_t *lock) {
  *lock = CreateMutex(NULL,  // Default security attributes.
                      FALSE, // Initially unlocked.
                      NULL); // Unnamed.
}

static void lock_lock(lock_t *lock) {
  assert(WaitForSingleObject(*lock, INFINITE) == WAIT_OBJECT_0);
}

static void lock_unlock(lock_t *lock) {
  assert(ReleaseMutex(*lock));
}

static void free_lock(lock_t *lock) {
  CloseHandle(*lock);
}

#else
// Assuming POSIX

#include <pthread.h>

typedef pthread_mutex_t lock_t;

static void create_lock(lock_t *lock) {
  int r = pthread_mutex_init(lock, NULL);
  assert(r == 0);
}

static void lock_lock(lock_t *lock) {
  int r = pthread_mutex_lock(lock);
  assert(r == 0);
}

static void lock_unlock(lock_t *lock) {
  int r = pthread_mutex_unlock(lock);
  assert(r == 0);
}

static void free_lock(lock_t *lock) {
  // Nothing to do for pthreads.
  (void)lock;
}

#endif

// End of lock.h.
// Start of free_list.h.

typedef uintptr_t fl_mem;

// An entry in the free list.  May be invalid, to avoid having to
// deallocate entries as soon as they are removed.  There is also a
// tag, to help with memory reuse.
struct free_list_entry {
  size_t size;
  fl_mem mem;
  const char *tag;
  unsigned char valid;
};

struct free_list {
  struct free_list_entry *entries; // Pointer to entries.
  int capacity;                    // Number of entries.
  int used;                        // Number of valid entries.
  lock_t lock;                     // Thread safety.
};

static void free_list_init(struct free_list *l) {
  l->capacity = 30; // Picked arbitrarily.
  l->used = 0;
  l->entries = (struct free_list_entry*) malloc(sizeof(struct free_list_entry) * l->capacity);
  for (int i = 0; i < l->capacity; i++) {
    l->entries[i].valid = 0;
  }
  create_lock(&l->lock);
}

// Remove invalid entries from the free list.
static void free_list_pack(struct free_list *l) {
  lock_lock(&l->lock);
  int p = 0;
  for (int i = 0; i < l->capacity; i++) {
    if (l->entries[i].valid) {
      l->entries[p] = l->entries[i];
      if (i > p) {
        l->entries[i].valid = 0;
      }
      p++;
    }
  }

  // Now p is the number of used elements.  We don't want it to go
  // less than the default capacity (although in practice it's OK as
  // long as it doesn't become 1).
  if (p < 30) {
    p = 30;
  }
  l->entries = realloc(l->entries, p * sizeof(struct free_list_entry));
  l->capacity = p;
  lock_unlock(&l->lock);
}

static void free_list_destroy(struct free_list *l) {
  assert(l->used == 0);
  free(l->entries);
  free_lock(&l->lock);
}

// Not part of the interface, so no locking.
static int free_list_find_invalid(struct free_list *l) {
  int i;
  for (i = 0; i < l->capacity; i++) {
    if (!l->entries[i].valid) {
      break;
    }
  }
  return i;
}

static void free_list_insert(struct free_list *l, size_t size, fl_mem mem, const char *tag) {
  lock_lock(&l->lock);
  int i = free_list_find_invalid(l);

  if (i == l->capacity) {
    // List is full; so we have to grow it.
    int new_capacity = l->capacity * 2 * sizeof(struct free_list_entry);
    l->entries = realloc(l->entries, new_capacity);
    for (int j = 0; j < l->capacity; j++) {
      l->entries[j+l->capacity].valid = 0;
    }
    l->capacity *= 2;
  }

  // Now 'i' points to the first invalid entry.
  l->entries[i].valid = 1;
  l->entries[i].size = size;
  l->entries[i].mem = mem;
  l->entries[i].tag = tag;

  l->used++;
  lock_unlock(&l->lock);
}

// Determine whether this entry in the free list is acceptable for
// satisfying the request.  Not public, so no locking.
static bool free_list_acceptable(size_t size, const char* tag, struct free_list_entry *entry) {
  // We check not just the hard requirement (is the entry acceptable
  // and big enough?) but also put a cap on how much wasted space
  // (internal fragmentation) we allow.  This is necessarily a
  // heuristic, and a crude one.

  if (!entry->valid) {
    return false;
  }

  if (size > entry->size) {
    return false;
  }

  // We know the block fits.  Now the question is whether it is too
  // big.  Our policy is as follows:
  //
  // 1) We don't care about wasted space below 4096 bytes (to avoid
  // churn in tiny allocations).
  //
  // 2) If the tag matches, we allow _any_ amount of wasted space.
  //
  // 3) Otherwise we allow up to 50% wasted space.

  if (entry->size < 4096) {
    return true;
  }

  if (entry->tag == tag) {
    return true;
  }

  if (entry->size < size * 2) {
    return true;
  }

  return false;
}

// Find and remove a memory block of the indicated tag, or if that
// does not exist, another memory block with exactly the desired size.
// Returns 0 on success.
static int free_list_find(struct free_list *l, size_t size, const char *tag,
                          size_t *size_out, fl_mem *mem_out) {
  lock_lock(&l->lock);
  int size_match = -1;
  int i;
  int ret = 1;
  for (i = 0; i < l->capacity; i++) {
    if (free_list_acceptable(size, tag, &l->entries[i]) &&
        (size_match < 0 || l->entries[i].size < l->entries[size_match].size)) {
      // If this entry is valid, has sufficient size, and is smaller than the
      // best entry found so far, use this entry.
      size_match = i;
    }
  }

  if (size_match >= 0) {
    l->entries[size_match].valid = 0;
    *size_out = l->entries[size_match].size;
    *mem_out = l->entries[size_match].mem;
    l->used--;
    ret = 0;
  }
  lock_unlock(&l->lock);
  return ret;
}

// Remove the first block in the free list.  Returns 0 if a block was
// removed, and nonzero if the free list was already empty.
static int free_list_first(struct free_list *l, fl_mem *mem_out) {
  lock_lock(&l->lock);
  int ret = 1;
  for (int i = 0; i < l->capacity; i++) {
    if (l->entries[i].valid) {
      l->entries[i].valid = 0;
      *mem_out = l->entries[i].mem;
      l->used--;
      ret = 0;
      break;
    }
  }
  lock_unlock(&l->lock);
  return ret;
}

// End of free_list.h.
// Start of event_list.h

typedef int (*event_report_fn)(struct str_builder*, void*);

// A collection of key-value associations. Used to associate extra data with
// events.
struct kvs {
  // A buffer that contains all value data. Must be freed when the struct kvs is
  // no longer used.
  char *buf;

  // Size of buf in bytes.
  size_t buf_size;

  // Number of bytes used in buf.
  size_t buf_used;

  // Number of associations stored.
  size_t n;

  // Capacity of vals.
  size_t vals_capacity;

  // An array of keys.
  const char* *keys;

  // Indexes into 'buf' that contains the values as zero-terminated strings.
  size_t *vals;
};

static const size_t KVS_INIT_BUF_SIZE = 128;
static const size_t KVS_INIT_NUMKEYS = 8;

void kvs_init(struct kvs* kvs) {
  kvs->buf = malloc(KVS_INIT_BUF_SIZE);
  kvs->buf_size = KVS_INIT_BUF_SIZE;
  kvs->buf_used = 0;
  kvs->vals_capacity = KVS_INIT_NUMKEYS;
  kvs->keys = calloc(kvs->vals_capacity, sizeof(const char*));
  kvs->vals = calloc(kvs->vals_capacity, sizeof(size_t));
  kvs->n = 0;
}

struct kvs* kvs_new(void) {
  struct kvs *kvs = malloc(sizeof(struct kvs));
  kvs_init(kvs);
  return kvs;
}

void kvs_printf(struct kvs* kvs, const char* key, const char* fmt, ...) {
  va_list vl;
  va_start(vl, fmt);

  size_t needed = 1 + (size_t)vsnprintf(NULL, 0, fmt, vl);

  while (kvs->buf_used+needed > kvs->buf_size) {
    kvs->buf_size *= 2;
    kvs->buf = realloc(kvs->buf, kvs->buf_size * sizeof(const char*));
  }

  if (kvs->n == kvs->vals_capacity) {
    kvs->vals_capacity *= 2;
    kvs->vals = realloc(kvs->vals, kvs->vals_capacity * sizeof(size_t));
    kvs->keys = realloc(kvs->keys, kvs->vals_capacity * sizeof(char*));
  }

  kvs->keys[kvs->n] = key;
  kvs->vals[kvs->n] = kvs->buf_used;
  kvs->buf_used += needed;

  va_start(vl, fmt); // Must re-init.
  vsnprintf(&kvs->buf[kvs->vals[kvs->n]], needed, fmt, vl);

  kvs->n++;
}

void kvs_free(struct kvs* kvs) {
  free(kvs->vals);
  free(kvs->keys);
  free(kvs->buf);
}

// Assumes all of the values are valid JSON objects.
void kvs_json(const struct kvs* kvs, struct str_builder *sb) {
  str_builder_char(sb, '{');
  for (size_t i = 0; i < kvs->n; i++) {
    if (i != 0) {
      str_builder_str(sb, ",");
    }
    str_builder_json_str(sb, kvs->keys[i]);
    str_builder_str(sb, ":");
    str_builder_str(sb, &kvs->buf[kvs->vals[i]]);
  }
  str_builder_char(sb, '}');
}

void kvs_log(const struct kvs* kvs, const char* prefix, FILE* f) {
  for (size_t i = 0; i < kvs->n; i++) {
    fprintf(f, "%s%s: %s\n",
            prefix,
            kvs->keys[i],
            &kvs->buf[kvs->vals[i]]);
  }
}

struct event {
  void* data;
  event_report_fn f;
  const char* name;
  const char *provenance;
  // Key-value information that is also to be printed.
  struct kvs *kvs;
};

struct event_list {
  struct event *events;
  int num_events;
  int capacity;
};

static void event_list_init(struct event_list *l) {
  l->capacity = 100;
  l->num_events = 0;
  l->events = calloc(l->capacity, sizeof(struct event));
}

static void event_list_free(struct event_list *l) {
  free(l->events);
}

static void add_event_to_list(struct event_list *l,
                              const char* name,
                              const char* provenance,
                              struct kvs *kvs,
                              void* data,
                              event_report_fn f) {
  if (l->num_events == l->capacity) {
    l->capacity *= 2;
    l->events = realloc(l->events, l->capacity * sizeof(struct event));
  }
  l->events[l->num_events].name = name;
  l->events[l->num_events].provenance =
    provenance ? provenance : "unknown";
  l->events[l->num_events].kvs = kvs;
  l->events[l->num_events].data = data;
  l->events[l->num_events].f = f;
  l->num_events++;
}

static int report_events_in_list(struct event_list *l,
                                 struct str_builder* sb) {
  int ret = 0;
  for (int i = 0; i < l->num_events; i++) {
    if (i != 0) {
      str_builder_str(sb, ",");
    }
    str_builder_str(sb, "{\"name\":");
    str_builder_json_str(sb, l->events[i].name);
    str_builder_str(sb, ",\"provenance\":");
    str_builder_json_str(sb, l->events[i].provenance);
    if (l->events[i].f(sb, l->events[i].data) != 0) {
      ret = 1;
      break;
    }

    str_builder_str(sb, ",\"details\":");
    if (l->events[i].kvs) {
      kvs_json(l->events[i].kvs, sb);
      kvs_free(l->events[i].kvs);
    } else {
      str_builder_str(sb, "{}");
    }

    str_builder(sb, "}");
  }
  event_list_free(l);
  event_list_init(l);
  return ret;
}

// End of event_list.h
#include <getopt.h>
#include <ctype.h>
#include <inttypes.h>
static const char *entry_point = "main";
// Start of values.h.

//// Text I/O

typedef int (*writer)(FILE*, const void*);
typedef int (*bin_reader)(void*);
typedef int (*str_reader)(const char *, void*);

struct array_reader {
  char* elems;
  int64_t n_elems_space;
  int64_t elem_size;
  int64_t n_elems_used;
  int64_t *shape;
  str_reader elem_reader;
};

static void skipspaces(FILE *f) {
  int c;
  do {
    c = getc(f);
  } while (isspace(c));

  if (c != EOF) {
    ungetc(c, f);
  }
}

static int constituent(char c) {
  return isalnum(c) || c == '.' || c == '-' || c == '+' || c == '_';
}

// Produces an empty token only on EOF.
static void next_token(FILE *f, char *buf, int bufsize) {
 start:
  skipspaces(f);

  int i = 0;
  while (i < bufsize) {
    int c = getc(f);
    buf[i] = (char)c;

    if (c == EOF) {
      buf[i] = 0;
      return;
    } else if (c == '-' && i == 1 && buf[0] == '-') {
      // Line comment, so skip to end of line and start over.
      for (; c != '\n' && c != EOF; c = getc(f));
      goto start;
    } else if (!constituent((char)c)) {
      if (i == 0) {
        // We permit single-character tokens that are not
        // constituents; this lets things like ']' and ',' be
        // tokens.
        buf[i+1] = 0;
        return;
      } else {
        ungetc(c, f);
        buf[i] = 0;
        return;
      }
    }

    i++;
  }

  buf[bufsize-1] = 0;
}

static int next_token_is(FILE *f, char *buf, int bufsize, const char* expected) {
  next_token(f, buf, bufsize);
  return strcmp(buf, expected) == 0;
}

static void remove_underscores(char *buf) {
  char *w = buf;

  for (char *r = buf; *r; r++) {
    if (*r != '_') {
      *w++ = *r;
    }
  }

  *w++ = 0;
}

static int read_str_elem(char *buf, struct array_reader *reader) {
  int ret;
  if (reader->n_elems_used == reader->n_elems_space) {
    reader->n_elems_space *= 2;
    reader->elems = (char*) realloc(reader->elems,
                                    (size_t)(reader->n_elems_space * reader->elem_size));
  }

  ret = reader->elem_reader(buf, reader->elems + reader->n_elems_used * reader->elem_size);

  if (ret == 0) {
    reader->n_elems_used++;
  }

  return ret;
}

static int read_str_array_elems(FILE *f,
                                char *buf, int bufsize,
                                struct array_reader *reader, int64_t dims) {
  int ret = 1;
  int expect_elem = 1;
  char *knows_dimsize = (char*) calloc((size_t)dims, sizeof(char));
  int cur_dim = (int)dims-1;
  int64_t *elems_read_in_dim = (int64_t*) calloc((size_t)dims, sizeof(int64_t));

  while (1) {
    next_token(f, buf, bufsize);
    if (strcmp(buf, "]") == 0) {
      expect_elem = 0;
      if (knows_dimsize[cur_dim]) {
        if (reader->shape[cur_dim] != elems_read_in_dim[cur_dim]) {
          ret = 1;
          break;
        }
      } else {
        knows_dimsize[cur_dim] = 1;
        reader->shape[cur_dim] = elems_read_in_dim[cur_dim];
      }
      if (cur_dim == 0) {
        ret = 0;
        break;
      } else {
        cur_dim--;
        elems_read_in_dim[cur_dim]++;
      }
    } else if (!expect_elem && strcmp(buf, ",") == 0) {
      expect_elem = 1;
    } else if (expect_elem) {
      if (strcmp(buf, "[") == 0) {
        if (cur_dim == dims - 1) {
          ret = 1;
          break;
        }
        cur_dim++;
        elems_read_in_dim[cur_dim] = 0;
      } else if (cur_dim == dims - 1) {
        ret = read_str_elem(buf, reader);
        if (ret != 0) {
          break;
        }
        expect_elem = 0;
        elems_read_in_dim[cur_dim]++;
      } else {
        ret = 1;
        break;
      }
    } else {
      ret = 1;
      break;
    }
  }

  free(knows_dimsize);
  free(elems_read_in_dim);
  return ret;
}

static int read_str_empty_array(FILE *f, char *buf, int bufsize,
                                const char *type_name, int64_t *shape, int64_t dims) {
  if (strlen(buf) == 0) {
    // EOF
    return 1;
  }

  if (strcmp(buf, "empty") != 0) {
    return 1;
  }

  if (!next_token_is(f, buf, bufsize, "(")) {
    return 1;
  }

  for (int i = 0; i < dims; i++) {
    if (!next_token_is(f, buf, bufsize, "[")) {
      return 1;
    }

    next_token(f, buf, bufsize);

    if (sscanf(buf, "%"SCNu64, (uint64_t*)&shape[i]) != 1) {
      return 1;
    }

    if (!next_token_is(f, buf, bufsize, "]")) {
      return 1;
    }
  }

  if (!next_token_is(f, buf, bufsize, type_name)) {
    return 1;
  }


  if (!next_token_is(f, buf, bufsize, ")")) {
    return 1;
  }

  // Check whether the array really is empty.
  for (int i = 0; i < dims; i++) {
    if (shape[i] == 0) {
      return 0;
    }
  }

  // Not an empty array!
  return 1;
}

static int read_str_array(FILE *f,
                          int64_t elem_size, str_reader elem_reader,
                          const char *type_name,
                          void **data, int64_t *shape, int64_t dims) {
  int ret;
  struct array_reader reader;
  char buf[100];

  int dims_seen;
  for (dims_seen = 0; dims_seen < dims; dims_seen++) {
    if (!next_token_is(f, buf, sizeof(buf), "[")) {
      break;
    }
  }

  if (dims_seen == 0) {
    return read_str_empty_array(f, buf, sizeof(buf), type_name, shape, dims);
  }

  if (dims_seen != dims) {
    return 1;
  }

  reader.shape = shape;
  reader.n_elems_used = 0;
  reader.elem_size = elem_size;
  reader.n_elems_space = 16;
  reader.elems = (char*) realloc(*data, (size_t)(elem_size*reader.n_elems_space));
  reader.elem_reader = elem_reader;

  ret = read_str_array_elems(f, buf, sizeof(buf), &reader, dims);

  *data = reader.elems;

  return ret;
}

#define READ_STR(MACRO, PTR, SUFFIX)                                   \
  remove_underscores(buf);                                              \
  int j;                                                                \
  if (sscanf(buf, "%"MACRO"%n", (PTR*)dest, &j) == 1) {                 \
    return !(strcmp(buf+j, "") == 0 || strcmp(buf+j, SUFFIX) == 0);     \
  } else {                                                              \
    return 1;                                                           \
  }

static int read_str_i8(char *buf, void* dest) {
  // Some platforms (WINDOWS) does not support scanf %hhd or its
  // cousin, %SCNi8.  Read into int first to avoid corrupting
  // memory.
  //
  // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63417
  remove_underscores(buf);
  int j, x;
  if (sscanf(buf, "%i%n", &x, &j) == 1) {
    *(int8_t*)dest = (int8_t)x;
    return !(strcmp(buf+j, "") == 0 || strcmp(buf+j, "i8") == 0);
  } else {
    return 1;
  }
}

static int read_str_u8(char *buf, void* dest) {
  // Some platforms (WINDOWS) does not support scanf %hhd or its
  // cousin, %SCNu8.  Read into int first to avoid corrupting
  // memory.
  //
  // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63417
  remove_underscores(buf);
  int j, x;
  if (sscanf(buf, "%i%n", &x, &j) == 1) {
    *(uint8_t*)dest = (uint8_t)x;
    return !(strcmp(buf+j, "") == 0 || strcmp(buf+j, "u8") == 0);
  } else {
    return 1;
  }
}

static int read_str_i16(char *buf, void* dest) {
  READ_STR(SCNi16, int16_t, "i16");
}

static int read_str_u16(char *buf, void* dest) {
  READ_STR(SCNi16, int16_t, "u16");
}

static int read_str_i32(char *buf, void* dest) {
  READ_STR(SCNi32, int32_t, "i32");
}

static int read_str_u32(char *buf, void* dest) {
  READ_STR(SCNi32, int32_t, "u32");
}

static int read_str_i64(char *buf, void* dest) {
  READ_STR(SCNi64, int64_t, "i64");
}

static int read_str_u64(char *buf, void* dest) {
  // FIXME: This is not correct, as SCNu64 only permits decimal
  // literals.  However, SCNi64 does not handle very large numbers
  // correctly (it's really for signed numbers, so that's fair).
  READ_STR(SCNu64, uint64_t, "u64");
}

static int read_str_f16(char *buf, void* dest) {
  remove_underscores(buf);
  if (strcmp(buf, "f16.nan") == 0) {
    *(uint16_t*)dest = float2halfbits(NAN);
    return 0;
  } else if (strcmp(buf, "f16.inf") == 0) {
    *(uint16_t*)dest = float2halfbits(INFINITY);
    return 0;
  } else if (strcmp(buf, "-f16.inf") == 0) {
    *(uint16_t*)dest = float2halfbits(-INFINITY);
    return 0;
  } else {
    int j;
    float x;
    if (sscanf(buf, "%f%n", &x, &j) == 1) {
      if (strcmp(buf+j, "") == 0 || strcmp(buf+j, "f16") == 0) {
        *(uint16_t*)dest = float2halfbits(x);
        return 0;
      }
    }
    return 1;
  }
}

static int read_str_f32(char *buf, void* dest) {
  remove_underscores(buf);
  if (strcmp(buf, "f32.nan") == 0) {
    *(float*)dest = (float)NAN;
    return 0;
  } else if (strcmp(buf, "f32.inf") == 0) {
    *(float*)dest = (float)INFINITY;
    return 0;
  } else if (strcmp(buf, "-f32.inf") == 0) {
    *(float*)dest = (float)-INFINITY;
    return 0;
  } else {
    READ_STR("f", float, "f32");
  }
}

static int read_str_f64(char *buf, void* dest) {
  remove_underscores(buf);
  if (strcmp(buf, "f64.nan") == 0) {
    *(double*)dest = (double)NAN;
    return 0;
  } else if (strcmp(buf, "f64.inf") == 0) {
    *(double*)dest = (double)INFINITY;
    return 0;
  } else if (strcmp(buf, "-f64.inf") == 0) {
    *(double*)dest = (double)-INFINITY;
    return 0;
  } else {
    READ_STR("lf", double, "f64");
  }
}

static int read_str_bool(char *buf, void* dest) {
  if (strcmp(buf, "true") == 0) {
    *(char*)dest = 1;
    return 0;
  } else if (strcmp(buf, "false") == 0) {
    *(char*)dest = 0;
    return 0;
  } else {
    return 1;
  }
}

static int write_str_i8(FILE *out, int8_t *src) {
  return fprintf(out, "%hhdi8", *src);
}

static int write_str_u8(FILE *out, uint8_t *src) {
  return fprintf(out, "%hhuu8", *src);
}

static int write_str_i16(FILE *out, int16_t *src) {
  return fprintf(out, "%hdi16", *src);
}

static int write_str_u16(FILE *out, uint16_t *src) {
  return fprintf(out, "%huu16", *src);
}

static int write_str_i32(FILE *out, int32_t *src) {
  return fprintf(out, "%di32", *src);
}

static int write_str_u32(FILE *out, uint32_t *src) {
  return fprintf(out, "%uu32", *src);
}

static int write_str_i64(FILE *out, int64_t *src) {
  return fprintf(out, "%"PRIi64"i64", *src);
}

static int write_str_u64(FILE *out, uint64_t *src) {
  return fprintf(out, "%"PRIu64"u64", *src);
}

static int write_str_f16(FILE *out, uint16_t *src) {
  float x = halfbits2float(*src);
  if (isnan(x)) {
    return fprintf(out, "f16.nan");
  } else if (isinf(x) && x >= 0) {
    return fprintf(out, "f16.inf");
  } else if (isinf(x)) {
    return fprintf(out, "-f16.inf");
  } else {
    return fprintf(out, "%.*ff16", FLT_DIG, x);
  }
}

static int write_str_f32(FILE *out, float *src) {
  float x = *src;
  if (isnan(x)) {
    return fprintf(out, "f32.nan");
  } else if (isinf(x) && x >= 0) {
    return fprintf(out, "f32.inf");
  } else if (isinf(x)) {
    return fprintf(out, "-f32.inf");
  } else {
    return fprintf(out, "%.*ff32", FLT_DIG, x);
  }
}

static int write_str_f64(FILE *out, double *src) {
  double x = *src;
  if (isnan(x)) {
    return fprintf(out, "f64.nan");
  } else if (isinf(x) && x >= 0) {
    return fprintf(out, "f64.inf");
  } else if (isinf(x)) {
    return fprintf(out, "-f64.inf");
  } else {
    return fprintf(out, "%.*ff64", DBL_DIG, x);
  }
}

static int write_str_bool(FILE *out, void *src) {
  return fprintf(out, *(char*)src ? "true" : "false");
}

//// Binary I/O

#define BINARY_FORMAT_VERSION 2
#define IS_BIG_ENDIAN (!*(unsigned char *)&(uint16_t){1})

static void flip_bytes(size_t elem_size, unsigned char *elem) {
  for (size_t j=0; j<elem_size/2; j++) {
    unsigned char head = elem[j];
    size_t tail_index = elem_size-1-j;
    elem[j] = elem[tail_index];
    elem[tail_index] = head;
  }
}

// On Windows we need to explicitly set the file mode to not mangle
// newline characters.  On *nix there is no difference.
#ifdef _WIN32
#include <io.h>
#include <fcntl.h>
static void set_binary_mode(FILE *f) {
  setmode(fileno(f), O_BINARY);
}
#else
static void set_binary_mode(FILE *f) {
  (void)f;
}
#endif

static int read_byte(FILE *f, void* dest) {
  size_t num_elems_read = fread(dest, 1, 1, f);
  return num_elems_read == 1 ? 0 : 1;
}

//// Types

struct primtype_info_t {
  const char binname[4]; // Used for parsing binary data.
  const char* type_name; // Same name as in Futhark.
  const int64_t size; // in bytes
  const writer write_str; // Write in text format.
  const str_reader read_str; // Read in text format.
};

static const struct primtype_info_t i8_info =
  {.binname = "  i8", .type_name = "i8",   .size = 1,
   .write_str = (writer)write_str_i8, .read_str = (str_reader)read_str_i8};
static const struct primtype_info_t i16_info =
  {.binname = " i16", .type_name = "i16",  .size = 2,
   .write_str = (writer)write_str_i16, .read_str = (str_reader)read_str_i16};
static const struct primtype_info_t i32_info =
  {.binname = " i32", .type_name = "i32",  .size = 4,
   .write_str = (writer)write_str_i32, .read_str = (str_reader)read_str_i32};
static const struct primtype_info_t i64_info =
  {.binname = " i64", .type_name = "i64",  .size = 8,
   .write_str = (writer)write_str_i64, .read_str = (str_reader)read_str_i64};
static const struct primtype_info_t u8_info =
  {.binname = "  u8", .type_name = "u8",   .size = 1,
   .write_str = (writer)write_str_u8, .read_str = (str_reader)read_str_u8};
static const struct primtype_info_t u16_info =
  {.binname = " u16", .type_name = "u16",  .size = 2,
   .write_str = (writer)write_str_u16, .read_str = (str_reader)read_str_u16};
static const struct primtype_info_t u32_info =
  {.binname = " u32", .type_name = "u32",  .size = 4,
   .write_str = (writer)write_str_u32, .read_str = (str_reader)read_str_u32};
static const struct primtype_info_t u64_info =
  {.binname = " u64", .type_name = "u64",  .size = 8,
   .write_str = (writer)write_str_u64, .read_str = (str_reader)read_str_u64};
static const struct primtype_info_t f16_info =
  {.binname = " f16", .type_name = "f16",  .size = 2,
   .write_str = (writer)write_str_f16, .read_str = (str_reader)read_str_f16};
static const struct primtype_info_t f32_info =
  {.binname = " f32", .type_name = "f32",  .size = 4,
   .write_str = (writer)write_str_f32, .read_str = (str_reader)read_str_f32};
static const struct primtype_info_t f64_info =
  {.binname = " f64", .type_name = "f64",  .size = 8,
   .write_str = (writer)write_str_f64, .read_str = (str_reader)read_str_f64};
static const struct primtype_info_t bool_info =
  {.binname = "bool", .type_name = "bool", .size = 1,
   .write_str = (writer)write_str_bool, .read_str = (str_reader)read_str_bool};

static const struct primtype_info_t* primtypes[] = {
  &i8_info, &i16_info, &i32_info, &i64_info,
  &u8_info, &u16_info, &u32_info, &u64_info,
  &f16_info, &f32_info, &f64_info,
  &bool_info,
  NULL // NULL-terminated
};

// General value interface.  All endian business taken care of at
// lower layers.

static int read_is_binary(FILE *f) {
  skipspaces(f);
  int c = getc(f);
  if (c == 'b') {
    int8_t bin_version;
    int ret = read_byte(f, &bin_version);

    if (ret != 0) { futhark_panic(1, "binary-input: could not read version.\n"); }

    if (bin_version != BINARY_FORMAT_VERSION) {
      futhark_panic(1, "binary-input: File uses version %i, but I only understand version %i.\n",
            bin_version, BINARY_FORMAT_VERSION);
    }

    return 1;
  }
  ungetc(c, f);
  return 0;
}

static const struct primtype_info_t* read_bin_read_type_enum(FILE *f) {
  char read_binname[4];

  int num_matched = fscanf(f, "%4c", read_binname);
  if (num_matched != 1) { futhark_panic(1, "binary-input: Couldn't read element type.\n"); }

  const struct primtype_info_t **type = primtypes;

  for (; *type != NULL; type++) {
    // I compare the 4 characters manually instead of using strncmp because
    // this allows any value to be used, also NULL bytes
    if (memcmp(read_binname, (*type)->binname, 4) == 0) {
      return *type;
    }
  }
  futhark_panic(1, "binary-input: Did not recognize the type '%s'.\n", read_binname);
  return NULL;
}

static void read_bin_ensure_scalar(FILE *f, const struct primtype_info_t *expected_type) {
  int8_t bin_dims;
  int ret = read_byte(f, &bin_dims);
  if (ret != 0) { futhark_panic(1, "binary-input: Couldn't get dims.\n"); }

  if (bin_dims != 0) {
    futhark_panic(1, "binary-input: Expected scalar (0 dimensions), but got array with %i dimensions.\n",
          bin_dims);
  }

  const struct primtype_info_t *bin_type = read_bin_read_type_enum(f);
  if (bin_type != expected_type) {
    futhark_panic(1, "binary-input: Expected scalar of type %s but got scalar of type %s.\n",
          expected_type->type_name,
          bin_type->type_name);
  }
}

//// High-level interface

static int read_bin_array(FILE *f,
                          const struct primtype_info_t *expected_type, void **data, int64_t *shape, int64_t dims) {
  int ret;

  int8_t bin_dims;
  ret = read_byte(f, &bin_dims);
  if (ret != 0) { futhark_panic(1, "binary-input: Couldn't get dims.\n"); }

  if (bin_dims != dims) {
    futhark_panic(1, "binary-input: Expected %i dimensions, but got array with %i dimensions.\n",
          dims, bin_dims);
  }

  const struct primtype_info_t *bin_primtype = read_bin_read_type_enum(f);
  if (expected_type != bin_primtype) {
    futhark_panic(1, "binary-input: Expected %iD-array with element type '%s' but got %iD-array with element type '%s'.\n",
          dims, expected_type->type_name, dims, bin_primtype->type_name);
  }

  int64_t elem_count = 1;
  for (int i=0; i<dims; i++) {
    int64_t bin_shape;
    ret = (int)fread(&bin_shape, sizeof(bin_shape), 1, f);
    if (ret != 1) {
      futhark_panic(1, "binary-input: Couldn't read size for dimension %i of array.\n", i);
    }
    if (IS_BIG_ENDIAN) {
      flip_bytes(sizeof(bin_shape), (unsigned char*) &bin_shape);
    }
    elem_count *= bin_shape;
    shape[i] = bin_shape;
  }

  int64_t elem_size = expected_type->size;
  void* tmp = realloc(*data, (size_t)(elem_count * elem_size));
  if (tmp == NULL) {
    futhark_panic(1, "binary-input: Failed to allocate array of size %i.\n",
          elem_count * elem_size);
  }
  *data = tmp;

  int64_t num_elems_read = (int64_t)fread(*data, (size_t)elem_size, (size_t)elem_count, f);
  if (num_elems_read != elem_count) {
    futhark_panic(1, "binary-input: tried to read %i elements of an array, but only got %i elements.\n",
          elem_count, num_elems_read);
  }

  // If we're on big endian platform we must change all multibyte elements
  // from using little endian to big endian
  if (IS_BIG_ENDIAN && elem_size != 1) {
    flip_bytes((size_t)elem_size, (unsigned char*) *data);
  }

  return 0;
}

static int read_array(FILE *f, const struct primtype_info_t *expected_type, void **data, int64_t *shape, int64_t dims) {
  if (!read_is_binary(f)) {
    return read_str_array(f, expected_type->size, (str_reader)expected_type->read_str, expected_type->type_name, data, shape, dims);
  } else {
    return read_bin_array(f, expected_type, data, shape, dims);
  }
}

static int end_of_input(FILE *f) {
  skipspaces(f);
  char token[2];
  next_token(f, token, sizeof(token));
  if (strcmp(token, "") == 0) {
    return 0;
  } else {
    return 1;
  }
}

static int write_str_array(FILE *out,
                           const struct primtype_info_t *elem_type,
                           const unsigned char *data,
                           const int64_t *shape,
                           int8_t rank) {
  if (rank==0) {
    elem_type->write_str(out, (const void*)data);
  } else {
    int64_t len = (int64_t)shape[0];
    int64_t slice_size = 1;

    int64_t elem_size = elem_type->size;
    for (int8_t i = 1; i < rank; i++) {
      slice_size *= shape[i];
    }

    if (len*slice_size == 0) {
      fprintf(out, "empty(");
      for (int64_t i = 0; i < rank; i++) {
        fprintf(out, "[%"PRIi64"]", shape[i]);
      }
      fprintf(out, "%s", elem_type->type_name);
      fprintf(out, ")");
    } else if (rank==1) {
      fputc('[', out);
      for (int64_t i = 0; i < len; i++) {
        elem_type->write_str(out, (const void*) (data + i * elem_size));
        if (i != len-1) {
          fprintf(out, ", ");
        }
      }
      fputc(']', out);
    } else {
      fputc('[', out);
      for (int64_t i = 0; i < len; i++) {
        write_str_array(out, elem_type, data + i * slice_size * elem_size, shape+1, rank-1);
        if (i != len-1) {
          fprintf(out, ", ");
        }
      }
      fputc(']', out);
    }
  }
  return 0;
}

static int write_bin_array(FILE *out,
                           const struct primtype_info_t *elem_type,
                           const unsigned char *data,
                           const int64_t *shape,
                           int8_t rank) {
  int64_t num_elems = 1;
  for (int64_t i = 0; i < rank; i++) {
    num_elems *= shape[i];
  }

  fputc('b', out);
  fputc((char)BINARY_FORMAT_VERSION, out);
  fwrite(&rank, sizeof(int8_t), 1, out);
  fwrite(elem_type->binname, 4, 1, out);
  if (shape != NULL) {
    fwrite(shape, sizeof(int64_t), (size_t)rank, out);
  }

  if (IS_BIG_ENDIAN) {
    for (int64_t i = 0; i < num_elems; i++) {
      const unsigned char *elem = data+i*elem_type->size;
      for (int64_t j = 0; j < elem_type->size; j++) {
        fwrite(&elem[elem_type->size-j], 1, 1, out);
      }
    }
  } else {
    fwrite(data, (size_t)elem_type->size, (size_t)num_elems, out);
  }

  return 0;
}

static int write_array(FILE *out, int write_binary,
                       const struct primtype_info_t *elem_type,
                       const void *data,
                       const int64_t *shape,
                       const int8_t rank) {
  if (write_binary) {
    return write_bin_array(out, elem_type, data, shape, rank);
  } else {
    return write_str_array(out, elem_type, data, shape, rank);
  }
}

static int read_scalar(FILE *f,
                       const struct primtype_info_t *expected_type, void *dest) {
  if (!read_is_binary(f)) {
    char buf[100];
    next_token(f, buf, sizeof(buf));
    return expected_type->read_str(buf, dest);
  } else {
    read_bin_ensure_scalar(f, expected_type);
    size_t elem_size = (size_t)expected_type->size;
    size_t num_elems_read = fread(dest, elem_size, 1, f);
    if (IS_BIG_ENDIAN) {
      flip_bytes(elem_size, (unsigned char*) dest);
    }
    return num_elems_read == 1 ? 0 : 1;
  }
}

static int write_scalar(FILE *out, int write_binary, const struct primtype_info_t *type, void *src) {
  if (write_binary) {
    return write_bin_array(out, type, src, NULL, 0);
  } else {
    return type->write_str(out, src);
  }
}

// End of values.h.

// Start of server.h.

// Forward declarations of things that we technically don't know until
// the application header file is included, but which we need.
struct futhark_context_config;
struct futhark_context;
char *futhark_context_get_error(struct futhark_context *ctx);
int futhark_context_sync(struct futhark_context *ctx);
int futhark_context_clear_caches(struct futhark_context *ctx);
int futhark_context_config_set_tuning_param(struct futhark_context_config *cfg,
                                            const char *param_name,
                                            size_t new_value);
int futhark_get_tuning_param_count(void);
const char* futhark_get_tuning_param_name(int i);
const char* futhark_get_tuning_param_class(int i);

typedef int (*restore_fn)(const void*, FILE *, struct futhark_context*, void*);
typedef void (*store_fn)(const void*, FILE *, struct futhark_context*, void*);
typedef int (*free_fn)(const void*, struct futhark_context*, void*);
typedef int (*project_fn)(struct futhark_context*, void*, const void*);
typedef int (*new_fn)(struct futhark_context*, void**, const void*[]);

struct field {
  const char *name;
  const struct type *type;
  project_fn project;
};

struct record {
  int num_fields;
  const struct field* fields;
  new_fn new;
};

struct type {
  const char *name;
  restore_fn restore;
  store_fn store;
  free_fn free;
  const void *aux;
  const struct record *record;
};

int free_scalar(const void *aux, struct futhark_context *ctx, void *p) {
  (void)aux;
  (void)ctx;
  (void)p;
  // Nothing to do.
  return 0;
}

#define DEF_SCALAR_TYPE(T)                                      \
  int restore_##T(const void *aux, FILE *f,                     \
                  struct futhark_context *ctx, void *p) {       \
    (void)aux;                                                  \
    (void)ctx;                                                  \
    return read_scalar(f, &T##_info, p);                        \
  }                                                             \
                                                                \
  void store_##T(const void *aux, FILE *f,                      \
                 struct futhark_context *ctx, void *p) {        \
    (void)aux;                                                  \
    (void)ctx;                                                  \
    write_scalar(f, 1, &T##_info, p);                           \
  }                                                             \
                                                                \
  struct type type_##T =                                        \
    { .name = #T,                                               \
      .restore = restore_##T,                                   \
      .store = store_##T,                                       \
      .free = free_scalar                                       \
    }                                                           \

DEF_SCALAR_TYPE(i8);
DEF_SCALAR_TYPE(i16);
DEF_SCALAR_TYPE(i32);
DEF_SCALAR_TYPE(i64);
DEF_SCALAR_TYPE(u8);
DEF_SCALAR_TYPE(u16);
DEF_SCALAR_TYPE(u32);
DEF_SCALAR_TYPE(u64);
DEF_SCALAR_TYPE(f16);
DEF_SCALAR_TYPE(f32);
DEF_SCALAR_TYPE(f64);
DEF_SCALAR_TYPE(bool);

struct value {
  const struct type *type;
  union {
    void *v_ptr;
    int8_t  v_i8;
    int16_t v_i16;
    int32_t v_i32;
    int64_t v_i64;

    uint8_t  v_u8;
    uint16_t v_u16;
    uint32_t v_u32;
    uint64_t v_u64;

    uint16_t v_f16;
    float v_f32;
    double v_f64;

    bool v_bool;
  } value;
};

void* value_ptr(struct value *v) {
  if (v->type == &type_i8) {
    return &v->value.v_i8;
  }
  if (v->type == &type_i16) {
    return &v->value.v_i16;
  }
  if (v->type == &type_i32) {
    return &v->value.v_i32;
  }
  if (v->type == &type_i64) {
    return &v->value.v_i64;
  }
  if (v->type == &type_u8) {
    return &v->value.v_u8;
  }
  if (v->type == &type_u16) {
    return &v->value.v_u16;
  }
  if (v->type == &type_u32) {
    return &v->value.v_u32;
  }
  if (v->type == &type_u64) {
    return &v->value.v_u64;
  }
  if (v->type == &type_f16) {
    return &v->value.v_f16;
  }
  if (v->type == &type_f32) {
    return &v->value.v_f32;
  }
  if (v->type == &type_f64) {
    return &v->value.v_f64;
  }
  if (v->type == &type_bool) {
    return &v->value.v_bool;
  }
  return &v->value.v_ptr;
}

struct variable {
  // NULL name indicates free slot.  Name is owned by this struct.
  char *name;
  struct value value;
};

typedef int (*entry_point_fn)(struct futhark_context*, void**, void**);

struct entry_point {
  const char *name;
  entry_point_fn f;
  const char** tuning_params;
  const struct type **out_types;
  bool *out_unique;
  const struct type **in_types;
  bool *in_unique;
};

int entry_num_ins(struct entry_point *e) {
  int count = 0;
  while (e->in_types[count]) {
    count++;
  }
  return count;
}

int entry_num_outs(struct entry_point *e) {
  int count = 0;
  while (e->out_types[count]) {
    count++;
  }
  return count;
}

struct futhark_prog {
  // Last entry point identified by NULL name.
  struct entry_point *entry_points;
  // Last type identified by NULL name.
  const struct type **types;
};

struct server_state {
  struct futhark_prog prog;
  struct futhark_context_config *cfg;
  struct futhark_context *ctx;
  int variables_capacity;
  struct variable *variables;
};

struct variable* get_variable(struct server_state *s,
                              const char *name) {
  for (int i = 0; i < s->variables_capacity; i++) {
    if (s->variables[i].name != NULL &&
        strcmp(s->variables[i].name, name) == 0) {
      return &s->variables[i];
    }
  }

  return NULL;
}

struct variable* create_variable(struct server_state *s,
                                 const char *name,
                                 const struct type *type) {
  int found = -1;
  for (int i = 0; i < s->variables_capacity; i++) {
    if (found == -1 && s->variables[i].name == NULL) {
      found = i;
    } else if (s->variables[i].name != NULL &&
               strcmp(s->variables[i].name, name) == 0) {
      return NULL;
    }
  }

  if (found != -1) {
    // Found a free spot.
    s->variables[found].name = strdup(name);
    s->variables[found].value.type = type;
    return &s->variables[found];
  }

  // Need to grow the buffer.
  found = s->variables_capacity;
  s->variables_capacity *= 2;
  s->variables = realloc(s->variables,
                         s->variables_capacity * sizeof(struct variable));

  s->variables[found].name = strdup(name);
  s->variables[found].value.type = type;

  for (int i = found+1; i < s->variables_capacity; i++) {
    s->variables[i].name = NULL;
  }

  return &s->variables[found];
}

void drop_variable(struct variable *v) {
  free(v->name);
  v->name = NULL;
}

int arg_exists(const char *args[], int i) {
  return args[i] != NULL;
}

const char* get_arg(const char *args[], int i) {
  if (!arg_exists(args, i)) {
    futhark_panic(1, "Insufficient command args.\n");
  }
  return args[i];
}

const struct type* get_type(struct server_state *s, const char *name) {
  for (int i = 0; s->prog.types[i]; i++) {
    if (strcmp(s->prog.types[i]->name, name) == 0) {
      return s->prog.types[i];
    }
  }

  futhark_panic(1, "Unknown type %s\n", name);
  return NULL;
}

struct entry_point* get_entry_point(struct server_state *s, const char *name) {
  for (int i = 0; s->prog.entry_points[i].name; i++) {
    if (strcmp(s->prog.entry_points[i].name, name) == 0) {
      return &s->prog.entry_points[i];
    }
  }

  return NULL;
}

// Print the command-done marker, indicating that we are ready for
// more input.
void ok(void) {
  printf("%%%%%% OK\n");
  fflush(stdout);
}

// Print the failure marker.  Output is now an error message until the
// next ok().
void failure(void) {
  printf("%%%%%% FAILURE\n");
}

void error_check(struct server_state *s, int err) {
  if (err != 0) {
    failure();
    char *error = futhark_context_get_error(s->ctx);
    if (error != NULL) {
      puts(error);
    }
    free(error);
  }
}

void cmd_call(struct server_state *s, const char *args[]) {
  const char *name = get_arg(args, 0);

  struct entry_point *e = get_entry_point(s, name);

  if (e == NULL) {
    failure();
    printf("Unknown entry point: %s\n", name);
    return;
  }

  int num_outs = entry_num_outs(e);
  int num_ins = entry_num_ins(e);
  // +1 to avoid zero-size arrays, which is UB.
  void* outs[num_outs+1];
  void* ins[num_ins+1];

  for (int i = 0; i < num_ins; i++) {
    const char *in_name = get_arg(args, 1+num_outs+i);
    struct variable *v = get_variable(s, in_name);
    if (v == NULL) {
      failure();
      printf("Unknown variable: %s\n", in_name);
      return;
    }
    if (v->value.type != e->in_types[i]) {
      failure();
      printf("Wrong input type.  Expected %s, got %s.\n",
             e->in_types[i]->name, v->value.type->name);
      return;
    }
    ins[i] = value_ptr(&v->value);
  }

  for (int i = 0; i < num_outs; i++) {
    const char *out_name = get_arg(args, 1+i);
    struct variable *v = create_variable(s, out_name, e->out_types[i]);
    if (v == NULL) {
      failure();
      printf("Variable already exists: %s\n", out_name);
      return;
    }
    outs[i] = value_ptr(&v->value);
  }

  int64_t t_start = get_wall_time();
  int err = e->f(s->ctx, outs, ins);
  err |= futhark_context_sync(s->ctx);
  int64_t t_end = get_wall_time();
  long long int elapsed_usec = t_end - t_start;
  printf("runtime: %lld\n", elapsed_usec);

  error_check(s, err);
  if (err != 0) {
    // Need to uncreate the output variables, which would otherwise be left
    // in an uninitialised state.
    for (int i = 0; i < num_outs; i++) {
      const char *out_name = get_arg(args, 1+i);
      struct variable *v = get_variable(s, out_name);
      if (v) {
        drop_variable(v);
      }
    }
  }
}

void cmd_restore(struct server_state *s, const char *args[]) {
  const char *fname = get_arg(args, 0);

  FILE *f = fopen(fname, "rb");
  if (f == NULL) {
    failure();
    printf("Failed to open %s: %s\n", fname, strerror(errno));
    return;
  }

  int bad = 0;
  int values = 0;
  for (int i = 1; arg_exists(args, i); i+=2, values++) {
    const char *vname = get_arg(args, i);
    const char *type = get_arg(args, i+1);

    const struct type *t = get_type(s, type);
    struct variable *v = create_variable(s, vname, t);

    if (v == NULL) {
      bad = 1;
      failure();
      printf("Variable already exists: %s\n", vname);
      break;
    }

    errno = 0;
    if (t->restore(t->aux, f, s->ctx, value_ptr(&v->value)) != 0) {
      bad = 1;
      failure();
      printf("Failed to restore variable %s.\n"
             "Possibly malformed data in %s (errno: %s)\n",
             vname, fname, strerror(errno));
      drop_variable(v);
      break;
    }
  }

  if (!bad && end_of_input(f) != 0) {
    failure();
    printf("Expected EOF after reading %d values from %s\n",
           values, fname);
  }

  fclose(f);

  if (!bad) {
    int err = futhark_context_sync(s->ctx);
    error_check(s, err);
  }
}

void cmd_store(struct server_state *s, const char *args[]) {
  const char *fname = get_arg(args, 0);

  FILE *f = fopen(fname, "wb");
  if (f == NULL) {
    failure();
    printf("Failed to open %s: %s\n", fname, strerror(errno));
  } else {
    for (int i = 1; arg_exists(args, i); i++) {
      const char *vname = get_arg(args, i);
      struct variable *v = get_variable(s, vname);

      if (v == NULL) {
        failure();
        printf("Unknown variable: %s\n", vname);
        return;
      }

      const struct type *t = v->value.type;
      t->store(t->aux, f, s->ctx, value_ptr(&v->value));
    }
    fclose(f);
  }
}

void cmd_free(struct server_state *s, const char *args[]) {
  for (int i = 0; arg_exists(args, i); i++) {
    const char *name = get_arg(args, i);
    struct variable *v = get_variable(s, name);

    if (v == NULL) {
      failure();
      printf("Unknown variable: %s\n", name);
      return;
    }

    const struct type *t = v->value.type;

    int err = t->free(t->aux, s->ctx, value_ptr(&v->value));
    error_check(s, err);
    drop_variable(v);
  }
}

void cmd_rename(struct server_state *s, const char *args[]) {
  const char *oldname = get_arg(args, 0);
  const char *newname = get_arg(args, 1);
  struct variable *old = get_variable(s, oldname);
  struct variable *new = get_variable(s, newname);

  if (old == NULL) {
    failure();
    printf("Unknown variable: %s\n", oldname);
    return;
  }

  if (new != NULL) {
    failure();
    printf("Variable already exists: %s\n", newname);
    return;
  }

  free(old->name);
  old->name = strdup(newname);
}

void cmd_inputs(struct server_state *s, const char *args[]) {
  const char *name = get_arg(args, 0);
  struct entry_point *e = get_entry_point(s, name);

  if (e == NULL) {
    failure();
    printf("Unknown entry point: %s\n", name);
    return;
  }

  int num_ins = entry_num_ins(e);
  for (int i = 0; i < num_ins; i++) {
    if (e->in_unique[i]) {
      putchar('*');
    }
    puts(e->in_types[i]->name);
  }
}

void cmd_outputs(struct server_state *s, const char *args[]) {
  const char *name = get_arg(args, 0);
  struct entry_point *e = get_entry_point(s, name);

  if (e == NULL) {
    failure();
    printf("Unknown entry point: %s\n", name);
    return;
  }

  int num_outs = entry_num_outs(e);
  for (int i = 0; i < num_outs; i++) {
    if (e->out_unique[i]) {
      putchar('*');
    }
    puts(e->out_types[i]->name);
  }
}

void cmd_clear(struct server_state *s, const char *args[]) {
  (void)args;
  int err = 0;
  for (int i = 0; i < s->variables_capacity; i++) {
    struct variable *v = &s->variables[i];
    if (v->name != NULL) {
      err |= v->value.type->free(v->value.type->aux, s->ctx, value_ptr(&v->value));
      drop_variable(v);
    }
  }
  err |= futhark_context_clear_caches(s->ctx);
  error_check(s, err);
}

void cmd_pause_profiling(struct server_state *s, const char *args[]) {
  (void)args;
  futhark_context_pause_profiling(s->ctx);
}

void cmd_unpause_profiling(struct server_state *s, const char *args[]) {
  (void)args;
  futhark_context_unpause_profiling(s->ctx);
}

void cmd_report(struct server_state *s, const char *args[]) {
  (void)args;
  char *report = futhark_context_report(s->ctx);
  if (report) {
    puts(report);
  } else {
    failure();
    report = futhark_context_get_error(s->ctx);
    if (report) {
      puts(report);
    } else {
      puts("Failed to produce profiling report.\n");
    }
  }
  free(report);
}

void cmd_set_tuning_param(struct server_state *s, const char *args[]) {
  const char *param = get_arg(args, 0);
  const char *val_s = get_arg(args, 1);
  size_t val = atol(val_s);
  int err = futhark_context_config_set_tuning_param(s->cfg, param, val);

  error_check(s, err);

  if (err != 0) {
    printf("Failed to set tuning parameter %s to %ld\n", param, (long)val);
  }
}

void cmd_tuning_params(struct server_state *s, const char *args[]) {
  const char *name = get_arg(args, 0);
  struct entry_point *e = get_entry_point(s, name);

  if (e == NULL) {
    failure();
    printf("Unknown entry point: %s\n", name);
    return;
  }

  const char **params = e->tuning_params;
  for (int i = 0; params[i] != NULL; i++) {
    printf("%s\n", params[i]);
  }
}

void cmd_tuning_param_class(struct server_state *s, const char *args[]) {
  (void)s;
  const char *param = get_arg(args, 0);

  int n = futhark_get_tuning_param_count();

  for (int i = 0; i < n; i++) {
    if (strcmp(futhark_get_tuning_param_name(i), param) == 0) {
      printf("%s\n", futhark_get_tuning_param_class(i));
      return;
    }
  }

  failure();
  printf("Unknown tuning parameter: %s\n", param);
}

void cmd_fields(struct server_state *s, const char *args[]) {
  const char *type = get_arg(args, 0);
  const struct type *t = get_type(s, type);
  const struct record *r = t->record;

  if (r == NULL) {
    failure();
    printf("Not a record type\n");
    return;
  }

  for (int i = 0; i < r->num_fields; i++) {
    const struct field f = r->fields[i];
    printf("%s %s\n", f.name, f.type->name);
  }
}

void cmd_project(struct server_state *s, const char *args[]) {
  const char *to_name = get_arg(args, 0);
  const char *from_name = get_arg(args, 1);
  const char *field_name = get_arg(args, 2);

  struct variable *from = get_variable(s, from_name);

  if (from == NULL) {
    failure();
    printf("Unknown variable: %s\n", from_name);
    return;
  }

  const struct type *from_type = from->value.type;
  const struct record *r = from_type->record;

  if (r == NULL) {
    failure();
    printf("Not a record type\n");
    return;
  }

  const struct field *field = NULL;
  for (int i = 0; i < r->num_fields; i++) {
    if (strcmp(r->fields[i].name, field_name) == 0) {
      field = &r->fields[i];
      break;
    }
  }

  if (field == NULL) {
    failure();
    printf("No such field\n");
  }

  struct variable *to = create_variable(s, to_name, field->type);

  if (to == NULL) {
    failure();
    printf("Variable already exists: %s\n", to_name);
    return;
  }

  field->project(s->ctx, value_ptr(&to->value), from->value.value.v_ptr);
}

void cmd_new(struct server_state *s, const char *args[]) {
  const char *to_name = get_arg(args, 0);
  const char *type_name = get_arg(args, 1);
  const struct type *type = get_type(s, type_name);
  struct variable *to = create_variable(s, to_name, type);

  if (to == NULL) {
    failure();
    printf("Variable already exists: %s\n", to_name);
    return;
  }

  const struct record* r = type->record;

  if (r == NULL) {
    failure();
    printf("Not a record type\n");
    return;
  }

  int num_args = 0;
  for (int i = 2; arg_exists(args, i); i++) {
    num_args++;
  }

  if (num_args != r->num_fields) {
    failure();
    printf("%d fields expected but %d values provided.\n", num_args, r->num_fields);
    return;
  }

  const void** value_ptrs = alloca(num_args * sizeof(void*));

  for (int i = 0; i < num_args; i++) {
    struct variable* v = get_variable(s, args[2+i]);

    if (v == NULL) {
      failure();
      printf("Unknown variable: %s\n", args[2+i]);
      return;
    }

    if (strcmp(v->value.type->name, r->fields[i].type->name) != 0) {
      failure();
      printf("Field %s mismatch: expected type %s, got %s\n",
             r->fields[i].name, r->fields[i].type->name, v->value.type->name);
      return;
    }

    value_ptrs[i] = value_ptr(&v->value);
  }

  r->new(s->ctx, value_ptr(&to->value), value_ptrs);
}

void cmd_entry_points(struct server_state *s, const char *args[]) {
  (void)args;
  for (int i = 0; s->prog.entry_points[i].name; i++) {
    puts(s->prog.entry_points[i].name);
  }
}

void cmd_types(struct server_state *s, const char *args[]) {
  (void)args;
  for (int i = 0; s->prog.types[i] != NULL; i++) {
    puts(s->prog.types[i]->name);
  }
}

char *next_word(char **line) {
  char *p = *line;

  while (isspace(*p)) {
    p++;
  }

  if (*p == 0) {
    return NULL;
  }

  if (*p == '"') {
    char *save = p+1;
    // Skip ahead till closing quote.
    p++;

    while (*p && *p != '"') {
      p++;
    }

    if (*p == '"') {
      *p = 0;
      *line = p+1;
      return save;
    } else {
      return NULL;
    }
  } else {
    char *save = p;
    // Skip ahead till next whitespace.

    while (*p && !isspace(*p)) {
      p++;
    }

    if (*p) {
      *p = 0;
      *line = p+1;
    } else {
      *line = p;
    }
    return save;
  }
}

void process_line(struct server_state *s, char *line) {
  int max_num_tokens = 1000;
  const char* tokens[max_num_tokens];
  int num_tokens = 0;

  while ((tokens[num_tokens] = next_word(&line)) != NULL) {
    num_tokens++;
    if (num_tokens == max_num_tokens) {
      futhark_panic(1, "Line too long.\n");
    }
  }

  const char *command = tokens[0];

  if (command == NULL) {
    failure();
    printf("Empty line\n");
  } else if (strcmp(command, "call") == 0) {
    cmd_call(s, tokens+1);
  } else if (strcmp(command, "restore") == 0) {
    cmd_restore(s, tokens+1);
  } else if (strcmp(command, "store") == 0) {
    cmd_store(s, tokens+1);
  } else if (strcmp(command, "free") == 0) {
    cmd_free(s, tokens+1);
  } else if (strcmp(command, "rename") == 0) {
    cmd_rename(s, tokens+1);
  } else if (strcmp(command, "inputs") == 0) {
    cmd_inputs(s, tokens+1);
  } else if (strcmp(command, "outputs") == 0) {
    cmd_outputs(s, tokens+1);
  } else if (strcmp(command, "clear") == 0) {
    cmd_clear(s, tokens+1);
  } else if (strcmp(command, "pause_profiling") == 0) {
    cmd_pause_profiling(s, tokens+1);
  } else if (strcmp(command, "unpause_profiling") == 0) {
    cmd_unpause_profiling(s, tokens+1);
  } else if (strcmp(command, "report") == 0) {
    cmd_report(s, tokens+1);
  } else if (strcmp(command, "set_tuning_param") == 0) {
    cmd_set_tuning_param(s, tokens+1);
  } else if (strcmp(command, "tuning_params") == 0) {
    cmd_tuning_params(s, tokens+1);
  } else if (strcmp(command, "tuning_param_class") == 0) {
    cmd_tuning_param_class(s, tokens+1);
  } else if (strcmp(command, "fields") == 0) {
    cmd_fields(s, tokens+1);
  } else if (strcmp(command, "new") == 0) {
    cmd_new(s, tokens+1);
  } else if (strcmp(command, "project") == 0) {
    cmd_project(s, tokens+1);
  } else if (strcmp(command, "entry_points") == 0) {
    cmd_entry_points(s, tokens+1);
  } else if (strcmp(command, "types") == 0) {
    cmd_types(s, tokens+1);
  } else {
    futhark_panic(1, "Unknown command: %s\n", command);
  }
}

void run_server(struct futhark_prog *prog,
                struct futhark_context_config *cfg,
                struct futhark_context *ctx) {
  char *line = NULL;
  size_t buflen = 0;
  ssize_t linelen;

  struct server_state s = {
    .cfg = cfg,
    .ctx = ctx,
    .variables_capacity = 100,
    .prog = *prog
  };

  s.variables = malloc(s.variables_capacity * sizeof(struct variable));

  for (int i = 0; i < s.variables_capacity; i++) {
    s.variables[i].name = NULL;
  }

  ok();
  while ((linelen = getline(&line, &buflen, stdin)) > 0) {
    process_line(&s, line);
    ok();
  }

  free(s.variables);
  free(line);
}

// The aux struct lets us write generic method implementations without
// code duplication.

typedef void* (*array_new_fn)(struct futhark_context *, const void*, const int64_t*);
typedef const int64_t* (*array_shape_fn)(struct futhark_context*, void*);
typedef int (*array_values_fn)(struct futhark_context*, void*, void*);
typedef int (*array_free_fn)(struct futhark_context*, void*);

struct array_aux {
  int rank;
  const struct primtype_info_t* info;
  const char *name;
  array_new_fn new;
  array_shape_fn shape;
  array_values_fn values;
  array_free_fn free;
};

int restore_array(const struct array_aux *aux, FILE *f,
                  struct futhark_context *ctx, void *p) {
  void *data = NULL;
  int64_t shape[aux->rank];
  if (read_array(f, aux->info, &data, shape, aux->rank) != 0) {
    return 1;
  }

  void *arr = aux->new(ctx, data, shape);
  if (arr == NULL) {
    return 1;
  }
  int err = futhark_context_sync(ctx);
  *(void**)p = arr;
  free(data);
  return err;
}

void store_array(const struct array_aux *aux, FILE *f,
                 struct futhark_context *ctx, void *p) {
  void *arr = *(void**)p;
  const int64_t *shape = aux->shape(ctx, arr);
  int64_t size = sizeof(aux->info->size);
  for (int i = 0; i < aux->rank; i++) {
    size *= shape[i];
  }
  int32_t *data = malloc(size);
  assert(aux->values(ctx, arr, data) == 0);
  assert(futhark_context_sync(ctx) == 0);
  assert(write_array(f, 1, aux->info, data, shape, aux->rank) == 0);
  free(data);
}

int free_array(const struct array_aux *aux,
               struct futhark_context *ctx, void *p) {
  void *arr = *(void**)p;
  return aux->free(ctx, arr);
}

typedef void* (*opaque_restore_fn)(struct futhark_context*, void*);
typedef int (*opaque_store_fn)(struct futhark_context*, const void*, void **, size_t *);
typedef int (*opaque_free_fn)(struct futhark_context*, void*);

struct opaque_aux {
  opaque_restore_fn restore;
  opaque_store_fn store;
  opaque_free_fn free;
};

int restore_opaque(const struct opaque_aux *aux, FILE *f,
                   struct futhark_context *ctx, void *p) {
  // We have a problem: we need to load data from 'f', since the
  // restore function takes a pointer, but we don't know how much we
  // need (and cannot possibly).  So we do something hacky: we read
  // *all* of the file, pass all of the data to the restore function
  // (which doesn't care if there's extra at the end), then we compute
  // how much space the the object actually takes in serialised form
  // and rewind the file to that position.  The only downside is more IO.
  size_t start = ftell(f);
  size_t size;
  char *bytes = fslurp_file(f, &size);
  void *obj = aux->restore(ctx, bytes);
  free(bytes);
  if (obj != NULL) {
    *(void**)p = obj;
    size_t obj_size;
    (void)aux->store(ctx, obj, NULL, &obj_size);
    fseek(f, start+obj_size, SEEK_SET);
    return 0;
  } else {
    fseek(f, start, SEEK_SET);
    return 1;
  }
}

void store_opaque(const struct opaque_aux *aux, FILE *f,
                  struct futhark_context *ctx, void *p) {
  void *obj = *(void**)p;
  size_t obj_size;
  void *data = NULL;
  (void)aux->store(ctx, obj, &data, &obj_size);
  assert(futhark_context_sync(ctx) == 0);
  fwrite(data, sizeof(char), obj_size, f);
  free(data);
}

int free_opaque(const struct opaque_aux *aux,
                struct futhark_context *ctx, void *p) {
  void *obj = *(void**)p;
  return aux->free(ctx, obj);
}

// End of server.h.

// Start of tuning.h.


int is_blank_line_or_comment(const char *s) {
  size_t i = strspn(s, " \t\n");
  return s[i] == '\0' || // Line is blank.
         strncmp(s + i, "--", 2) == 0; // Line is comment.
}

static char* load_tuning_file(const char *fname,
                              void *cfg,
                              int (*set_tuning_param)(void*, const char*, size_t)) {
  const int max_line_len = 1024;
  char* line = (char*) malloc(max_line_len);

  FILE *f = fopen(fname, "r");

  if (f == NULL) {
    snprintf(line, max_line_len, "Cannot open file: %s", strerror(errno));
    return line;
  }

  int lineno = 0;
  while (fgets(line, max_line_len, f) != NULL) {
    lineno++;
    if (is_blank_line_or_comment(line)) {
      continue;
    }
    char *eql = strstr(line, "=");
    if (eql) {
      *eql = 0;
      char *endptr;
      int value = strtol(eql+1, &endptr, 10);
      if (*endptr && *endptr != '\n') {
        snprintf(line, max_line_len, "Invalid line %d (must be of form 'name=int').",
                 lineno);
        return line;
      }
      if (set_tuning_param(cfg, line, (size_t)value) != 0) {
        char* err = (char*) malloc(max_line_len + 50);
        snprintf(err, max_line_len + 50, "Unknown name '%s' on line %d.", line, lineno);
        free(line);
        return err;
      }
    } else {
      snprintf(line, max_line_len, "Invalid line %d (must be of form 'name=int').",
               lineno);
      return line;
    }
  }

  free(line);

  return NULL;
}

// End of tuning.h.

const struct type type_ZMZNZMZNf64;
const struct type type_ZMZNf64;
void *futhark_new_f64_2d_wrap(struct futhark_context *ctx, const void *p, const int64_t *shape)
{
    return futhark_new_f64_2d(ctx, p, shape[0], shape[1]);
}
const struct array_aux type_ZMZNZMZNf64_aux = {.name ="[][]f64", .rank =2, .info =&f64_info, .new =(array_new_fn) futhark_new_f64_2d_wrap, .free =(array_free_fn) futhark_free_f64_2d, .shape =(array_shape_fn) futhark_shape_f64_2d, .values =(array_values_fn) futhark_values_f64_2d};
const struct type type_ZMZNZMZNf64 = {.name ="[][]f64", .restore =(restore_fn) restore_array, .store =(store_fn) store_array, .free =(free_fn) free_array, .aux =&type_ZMZNZMZNf64_aux};
void *futhark_new_f64_1d_wrap(struct futhark_context *ctx, const void *p, const int64_t *shape)
{
    return futhark_new_f64_1d(ctx, p, shape[0]);
}
const struct array_aux type_ZMZNf64_aux = {.name ="[]f64", .rank =1, .info =&f64_info, .new =(array_new_fn) futhark_new_f64_1d_wrap, .free =(array_free_fn) futhark_free_f64_1d, .shape =(array_shape_fn) futhark_shape_f64_1d, .values =(array_values_fn) futhark_values_f64_1d};
const struct type type_ZMZNf64 = {.name ="[]f64", .restore =(restore_fn) restore_array, .store =(store_fn) store_array, .free =(free_fn) free_array, .aux =&type_ZMZNf64_aux};
const struct type *test_acc_prob_out_types[] = {&type_ZMZNf64, NULL};
bool test_acc_prob_out_unique[] = {false};
const struct type *test_acc_prob_in_types[] = {&type_i64, &type_i64, &type_i64, NULL};
bool test_acc_prob_in_unique[] = {false, false, false};
const char *test_acc_prob_tuning_params[] = {NULL};
int call_test_acc_prob(struct futhark_context *ctx, void **outs, void **ins)
{
    struct futhark_f64_1d * *out0 = outs[0];
    int64_t in0 = *(int64_t *) ins[0];
    int64_t in1 = *(int64_t *) ins[1];
    int64_t in2 = *(int64_t *) ins[2];
    
    return futhark_entry_test_acc_prob(ctx, out0, in0, in1, in2);
}
const struct type *test_acc_prob_mat_out_types[] = {&type_ZMZNZMZNf64, NULL};
bool test_acc_prob_mat_out_unique[] = {false};
const struct type *test_acc_prob_mat_in_types[] = {&type_i64, &type_i64, &type_i64, NULL};
bool test_acc_prob_mat_in_unique[] = {false, false, false};
const char *test_acc_prob_mat_tuning_params[] = {NULL};
int call_test_acc_prob_mat(struct futhark_context *ctx, void **outs, void **ins)
{
    struct futhark_f64_2d * *out0 = outs[0];
    int64_t in0 = *(int64_t *) ins[0];
    int64_t in1 = *(int64_t *) ins[1];
    int64_t in2 = *(int64_t *) ins[2];
    
    return futhark_entry_test_acc_prob_mat(ctx, out0, in0, in1, in2);
}
const struct type *test_bellman_out_types[] = {&type_ZMZNf64, NULL};
bool test_bellman_out_unique[] = {false};
const struct type *test_bellman_in_types[] = {&type_i64, &type_ZMZNf64, &type_i64, NULL};
bool test_bellman_in_unique[] = {false, false, false};
const char *test_bellman_tuning_params[] = {NULL};
int call_test_bellman(struct futhark_context *ctx, void **outs, void **ins)
{
    struct futhark_f64_1d * *out0 = outs[0];
    int64_t in0 = *(int64_t *) ins[0];
    struct futhark_f64_1d * in1 = *(struct futhark_f64_1d * *) ins[1];
    int64_t in2 = *(int64_t *) ins[2];
    
    return futhark_entry_test_bellman(ctx, out0, in0, in1, in2);
}
const struct type *test_bellmanN_out_types[] = {&type_ZMZNf64, NULL};
bool test_bellmanN_out_unique[] = {false};
const struct type *test_bellmanN_in_types[] = {&type_i64, &type_ZMZNf64, &type_i64, &type_i64, NULL};
bool test_bellmanN_in_unique[] = {false, false, false, false};
const char *test_bellmanN_tuning_params[] = {NULL};
int call_test_bellmanN(struct futhark_context *ctx, void **outs, void **ins)
{
    struct futhark_f64_1d * *out0 = outs[0];
    int64_t in0 = *(int64_t *) ins[0];
    struct futhark_f64_1d * in1 = *(struct futhark_f64_1d * *) ins[1];
    int64_t in2 = *(int64_t *) ins[2];
    int64_t in3 = *(int64_t *) ins[3];
    
    return futhark_entry_test_bellmanN(ctx, out0, in0, in1, in2, in3);
}
const struct type *test_carprice_buy_out_types[] = {&type_ZMZNf64, NULL};
bool test_carprice_buy_out_unique[] = {false};
const struct type *test_carprice_buy_in_types[] = {&type_i64, &type_ZMZNf64, &type_i64, NULL};
bool test_carprice_buy_in_unique[] = {false, false, false};
const char *test_carprice_buy_tuning_params[] = {NULL};
int call_test_carprice_buy(struct futhark_context *ctx, void **outs, void **ins)
{
    struct futhark_f64_1d * *out0 = outs[0];
    int64_t in0 = *(int64_t *) ins[0];
    struct futhark_f64_1d * in1 = *(struct futhark_f64_1d * *) ins[1];
    int64_t in2 = *(int64_t *) ins[2];
    
    return futhark_entry_test_carprice_buy(ctx, out0, in0, in1, in2);
}
const struct type *test_carprice_sell_out_types[] = {&type_ZMZNf64, NULL};
bool test_carprice_sell_out_unique[] = {false};
const struct type *test_carprice_sell_in_types[] = {&type_i64, &type_ZMZNf64, &type_i64, NULL};
bool test_carprice_sell_in_unique[] = {false, false, false};
const char *test_carprice_sell_tuning_params[] = {NULL};
int call_test_carprice_sell(struct futhark_context *ctx, void **outs, void **ins)
{
    struct futhark_f64_1d * *out0 = outs[0];
    int64_t in0 = *(int64_t *) ins[0];
    struct futhark_f64_1d * in1 = *(struct futhark_f64_1d * *) ins[1];
    int64_t in2 = *(int64_t *) ins[2];
    
    return futhark_entry_test_carprice_sell(ctx, out0, in0, in1, in2);
}
const struct type *test_ev_scrap_out_types[] = {&type_ZMZNf64, NULL};
bool test_ev_scrap_out_unique[] = {false};
const struct type *test_ev_scrap_in_types[] = {&type_i64, &type_ZMZNf64, &type_i64, NULL};
bool test_ev_scrap_in_unique[] = {false, false, false};
const char *test_ev_scrap_tuning_params[] = {NULL};
int call_test_ev_scrap(struct futhark_context *ctx, void **outs, void **ins)
{
    struct futhark_f64_1d * *out0 = outs[0];
    int64_t in0 = *(int64_t *) ins[0];
    struct futhark_f64_1d * in1 = *(struct futhark_f64_1d * *) ins[1];
    int64_t in2 = *(int64_t *) ins[2];
    
    return futhark_entry_test_ev_scrap(ctx, out0, in0, in1, in2);
}
const struct type *test_notrade_out_types[] = {&type_ZMZNZMZNf64, NULL};
bool test_notrade_out_unique[] = {false};
const struct type *test_notrade_in_types[] = {&type_i64, &type_i64, &type_i64, NULL};
bool test_notrade_in_unique[] = {false, false, false};
const char *test_notrade_tuning_params[] = {NULL};
int call_test_notrade(struct futhark_context *ctx, void **outs, void **ins)
{
    struct futhark_f64_2d * *out0 = outs[0];
    int64_t in0 = *(int64_t *) ins[0];
    int64_t in1 = *(int64_t *) ins[1];
    int64_t in2 = *(int64_t *) ins[2];
    
    return futhark_entry_test_notrade(ctx, out0, in0, in1, in2);
}
const struct type *test_simple_prices_out_types[] = {&type_ZMZNZMZNf64, NULL};
bool test_simple_prices_out_unique[] = {false};
const struct type *test_simple_prices_in_types[] = {&type_i64, &type_ZMZNf64, &type_i64, NULL};
bool test_simple_prices_in_unique[] = {false, false, false};
const char *test_simple_prices_tuning_params[] = {NULL};
int call_test_simple_prices(struct futhark_context *ctx, void **outs, void **ins)
{
    struct futhark_f64_2d * *out0 = outs[0];
    int64_t in0 = *(int64_t *) ins[0];
    struct futhark_f64_1d * in1 = *(struct futhark_f64_1d * *) ins[1];
    int64_t in2 = *(int64_t *) ins[2];
    
    return futhark_entry_test_simple_prices(ctx, out0, in0, in1, in2);
}
const struct type *test_trade_out_types[] = {&type_ZMZNZMZNf64, NULL};
bool test_trade_out_unique[] = {false};
const struct type *test_trade_in_types[] = {&type_i64, &type_i64, &type_i64, NULL};
bool test_trade_in_unique[] = {false, false, false};
const char *test_trade_tuning_params[] = {NULL};
int call_test_trade(struct futhark_context *ctx, void **outs, void **ins)
{
    struct futhark_f64_2d * *out0 = outs[0];
    int64_t in0 = *(int64_t *) ins[0];
    int64_t in1 = *(int64_t *) ins[1];
    int64_t in2 = *(int64_t *) ins[2];
    
    return futhark_entry_test_trade(ctx, out0, in0, in1, in2);
}
const struct type *test_utility_out_types[] = {&type_ZMZNZMZNf64, NULL};
bool test_utility_out_unique[] = {false};
const struct type *test_utility_in_types[] = {&type_i64, &type_ZMZNf64, &type_i64, NULL};
bool test_utility_in_unique[] = {false, false, false};
const char *test_utility_tuning_params[] = {NULL};
int call_test_utility(struct futhark_context *ctx, void **outs, void **ins)
{
    struct futhark_f64_2d * *out0 = outs[0];
    int64_t in0 = *(int64_t *) ins[0];
    struct futhark_f64_1d * in1 = *(struct futhark_f64_1d * *) ins[1];
    int64_t in2 = *(int64_t *) ins[2];
    
    return futhark_entry_test_utility(ctx, out0, in0, in1, in2);
}
const struct type *test_utility_2_out_types[] = {&type_ZMZNZMZNf64, NULL};
bool test_utility_2_out_unique[] = {false};
const struct type *test_utility_2_in_types[] = {&type_i64, &type_ZMZNf64, &type_i64, &type_ZMZNZMZNf64, NULL};
bool test_utility_2_in_unique[] = {false, false, false, false};
const char *test_utility_2_tuning_params[] = {NULL};
int call_test_utility_2(struct futhark_context *ctx, void **outs, void **ins)
{
    struct futhark_f64_2d * *out0 = outs[0];
    int64_t in0 = *(int64_t *) ins[0];
    struct futhark_f64_1d * in1 = *(struct futhark_f64_1d * *) ins[1];
    int64_t in2 = *(int64_t *) ins[2];
    struct futhark_f64_2d * in3 = *(struct futhark_f64_2d * *) ins[3];
    
    return futhark_entry_test_utility_2(ctx, out0, in0, in1, in2, in3);
}
const struct type *types[] = {&type_i8, &type_i16, &type_i32, &type_i64, &type_u8, &type_u16, &type_u32, &type_u64, &type_f16, &type_f32, &type_f64, &type_bool, &type_ZMZNZMZNf64, &type_ZMZNf64, NULL};
struct entry_point entry_points[] = {{.name ="test_acc_prob", .f =call_test_acc_prob, .tuning_params =test_acc_prob_tuning_params, .in_types =test_acc_prob_in_types, .out_types =test_acc_prob_out_types, .in_unique =test_acc_prob_in_unique, .out_unique =test_acc_prob_out_unique}, {.name ="test_acc_prob_mat", .f =call_test_acc_prob_mat, .tuning_params =test_acc_prob_mat_tuning_params, .in_types =test_acc_prob_mat_in_types, .out_types =test_acc_prob_mat_out_types, .in_unique =test_acc_prob_mat_in_unique, .out_unique =test_acc_prob_mat_out_unique}, {.name ="test_bellman", .f =call_test_bellman, .tuning_params =test_bellman_tuning_params, .in_types =test_bellman_in_types, .out_types =test_bellman_out_types, .in_unique =test_bellman_in_unique, .out_unique =test_bellman_out_unique}, {.name ="test_bellmanN", .f =call_test_bellmanN, .tuning_params =test_bellmanN_tuning_params, .in_types =test_bellmanN_in_types, .out_types =test_bellmanN_out_types, .in_unique =test_bellmanN_in_unique, .out_unique =test_bellmanN_out_unique}, {.name ="test_carprice_buy", .f =call_test_carprice_buy, .tuning_params =test_carprice_buy_tuning_params, .in_types =test_carprice_buy_in_types, .out_types =test_carprice_buy_out_types, .in_unique =test_carprice_buy_in_unique, .out_unique =test_carprice_buy_out_unique}, {.name ="test_carprice_sell", .f =call_test_carprice_sell, .tuning_params =test_carprice_sell_tuning_params, .in_types =test_carprice_sell_in_types, .out_types =test_carprice_sell_out_types, .in_unique =test_carprice_sell_in_unique, .out_unique =test_carprice_sell_out_unique}, {.name ="test_ev_scrap", .f =call_test_ev_scrap, .tuning_params =test_ev_scrap_tuning_params, .in_types =test_ev_scrap_in_types, .out_types =test_ev_scrap_out_types, .in_unique =test_ev_scrap_in_unique, .out_unique =test_ev_scrap_out_unique}, {.name ="test_notrade", .f =call_test_notrade, .tuning_params =test_notrade_tuning_params, .in_types =test_notrade_in_types, .out_types =test_notrade_out_types, .in_unique =test_notrade_in_unique, .out_unique =test_notrade_out_unique}, {.name ="test_simple_prices", .f =call_test_simple_prices, .tuning_params =test_simple_prices_tuning_params, .in_types =test_simple_prices_in_types, .out_types =test_simple_prices_out_types, .in_unique =test_simple_prices_in_unique, .out_unique =test_simple_prices_out_unique}, {.name ="test_trade", .f =call_test_trade, .tuning_params =test_trade_tuning_params, .in_types =test_trade_in_types, .out_types =test_trade_out_types, .in_unique =test_trade_in_unique, .out_unique =test_trade_out_unique}, {.name ="test_utility", .f =call_test_utility, .tuning_params =test_utility_tuning_params, .in_types =test_utility_in_types, .out_types =test_utility_out_types, .in_unique =test_utility_in_unique, .out_unique =test_utility_out_unique}, {.name ="test_utility_2", .f =call_test_utility_2, .tuning_params =test_utility_2_tuning_params, .in_types =test_utility_2_in_types, .out_types =test_utility_2_out_types, .in_unique =test_utility_2_in_unique, .out_unique =test_utility_2_out_unique}, {.name =NULL}};
struct futhark_prog prog = {.types =types, .entry_points =entry_points};
int parse_options(struct futhark_context_config *cfg, int argc, char *const argv[])
{
    int ch;
    static struct option long_options[] = {{"debugging", no_argument, NULL, 1}, {"log", no_argument, NULL, 2}, {"profile", no_argument, NULL, 3}, {"help", no_argument, NULL, 4}, {"print-params", no_argument, NULL, 5}, {"param", required_argument, NULL, 6}, {"tuning", required_argument, NULL, 7}, {"cache-file", required_argument, NULL, 8}, {0, 0, 0, 0}};
    static char *option_descriptions = "  -D/--debugging     Perform possibly expensive internal correctness checks and verbose logging.\n  -L/--log           Print various low-overhead logging information while running.\n  -P/--profile       Enable the collection of profiling information.\n  -h/--help          Print help information and exit.\n  --print-params     Print all tuning parameters that can be set with --param or --tuning.\n  --param ASSIGNMENT Set a tuning parameter to the given value.\n  --tuning FILE      Read size=value assignments from the given file.\n  --cache-file FILE  Store program cache here.\n";
    
    while ((ch = getopt_long(argc, argv, ":DLPh", long_options, NULL)) != -1) {
        if (ch == 1 || ch == 'D')
            futhark_context_config_set_debugging(cfg, 1);
        if (ch == 2 || ch == 'L')
            futhark_context_config_set_logging(cfg, 1);
        if (ch == 3 || ch == 'P')
            futhark_context_config_set_profiling(cfg, 1);
        if (ch == 4 || ch == 'h') {
            printf("Usage: %s [OPTIONS]...\nOptions:\n\n%s\nFor more information, consult the Futhark User's Guide or the man pages.\n", fut_progname, option_descriptions);
            exit(0);
        }
        if (ch == 5) {
            int n = futhark_get_tuning_param_count();
            
            for (int i = 0; i < n; i++)
                printf("%s (%s)\n", futhark_get_tuning_param_name(i), futhark_get_tuning_param_class(i));
            exit(0);
        }
        if (ch == 6) {
            char *name = optarg;
            char *equals = strstr(optarg, "=");
            char *value_str = equals != NULL ? equals + 1 : optarg;
            int value = atoi(value_str);
            
            if (equals != NULL) {
                *equals = 0;
                if (futhark_context_config_set_tuning_param(cfg, name, value) != 0)
                    futhark_panic(1, "Unknown size: %s\n", name);
            } else
                futhark_panic(1, "Invalid argument for size option: %s\n", optarg);
        }
        if (ch == 7) {
            char *ret = load_tuning_file(optarg, cfg, (int (*)(void *, const char *, size_t)) futhark_context_config_set_tuning_param);
            
            if (ret != NULL)
                futhark_panic(1, "When loading tuning file '%s': %s\n", optarg, ret);
        }
        if (ch == 8)
            futhark_context_config_set_cache_file(cfg, optarg);
        if (ch == ':')
            futhark_panic(-1, "Missing argument for option %s\n", argv[optind - 1]);
        if (ch == '?') {
            fprintf(stderr, "Usage: %s [OPTIONS]...\nOptions:\n\n%s\n", fut_progname, "  -D/--debugging     Perform possibly expensive internal correctness checks and verbose logging.\n  -L/--log           Print various low-overhead logging information while running.\n  -P/--profile       Enable the collection of profiling information.\n  -h/--help          Print help information and exit.\n  --print-params     Print all tuning parameters that can be set with --param or --tuning.\n  --param ASSIGNMENT Set a tuning parameter to the given value.\n  --tuning FILE      Read size=value assignments from the given file.\n  --cache-file FILE  Store program cache here.\n");
            futhark_panic(1, "Unknown option: %s\n", argv[optind - 1]);
        }
    }
    return optind;
}
int main(int argc, char **argv)
{
    fut_progname = argv[0];
    
    struct futhark_context_config *cfg = futhark_context_config_new();
    
    assert(cfg != NULL);
    
    int parsed_options = parse_options(cfg, argc, argv);
    
    argc -= parsed_options;
    argv += parsed_options;
    if (argc != 0)
        futhark_panic(1, "Excess non-option: %s\n", argv[0]);
    
    struct futhark_context *ctx = futhark_context_new(cfg);
    
    assert(ctx != NULL);
    futhark_context_set_logging_file(ctx, stdout);
    
    char *error = futhark_context_get_error(ctx);
    
    if (error != NULL)
        futhark_panic(1, "Error during context initialisation:\n%s", error);
    if (entry_point != NULL)
        run_server(&prog, cfg, ctx);
    futhark_context_free(ctx);
    futhark_context_config_free(cfg);
}

#ifdef _MSC_VER
#define inline __inline
#endif
#include <string.h>
#include <string.h>
#include <errno.h>
#include <assert.h>
#include <ctype.h>



#define FUTHARK_F64_ENABLED

// Start of scalar.h.

// Implementation of the primitive scalar operations.  Very
// repetitive.  This code is inserted directly into both CUDA and
// OpenCL programs, as well as the CPU code, so it has some #ifdefs to
// work everywhere.  Some operations are defined as macros because
// this allows us to use them as constant expressions in things like
// array sizes and static initialisers.

// Some of the #ifdefs are because OpenCL uses type-generic functions
// for some operations (e.g. sqrt), while C and CUDA sensibly use
// distinct functions for different precisions (e.g. sqrtf() and
// sqrt()).  This is quite annoying.  Due to C's unfortunate casting
// rules, it is also really easy to accidentally implement
// floating-point functions in the wrong precision, so be careful.

// Double-precision definitions are only included if the preprocessor
// macro FUTHARK_F64_ENABLED is set.

#ifndef M_PI
#define M_PI 3.141592653589793
#endif

SCALAR_FUN_ATTR int32_t fptobits_f32_i32(float x);
SCALAR_FUN_ATTR float bitstofp_i32_f32(int32_t x);

SCALAR_FUN_ATTR uint8_t   add8(uint8_t x, uint8_t y)   { return x + y; }
SCALAR_FUN_ATTR uint16_t add16(uint16_t x, uint16_t y) { return x + y; }
SCALAR_FUN_ATTR uint32_t add32(uint32_t x, uint32_t y) { return x + y; }
SCALAR_FUN_ATTR uint64_t add64(uint64_t x, uint64_t y) { return x + y; }

SCALAR_FUN_ATTR uint8_t   sub8(uint8_t x, uint8_t y)   { return x - y; }
SCALAR_FUN_ATTR uint16_t sub16(uint16_t x, uint16_t y) { return x - y; }
SCALAR_FUN_ATTR uint32_t sub32(uint32_t x, uint32_t y) { return x - y; }
SCALAR_FUN_ATTR uint64_t sub64(uint64_t x, uint64_t y) { return x - y; }

SCALAR_FUN_ATTR uint8_t   mul8(uint8_t x, uint8_t y)   { return x * y; }
SCALAR_FUN_ATTR uint16_t mul16(uint16_t x, uint16_t y) { return x * y; }
SCALAR_FUN_ATTR uint32_t mul32(uint32_t x, uint32_t y) { return x * y; }
SCALAR_FUN_ATTR uint64_t mul64(uint64_t x, uint64_t y) { return x * y; }

#if defined(ISPC)

SCALAR_FUN_ATTR uint8_t udiv8(uint8_t x, uint8_t y) {
  // This strange pattern is used to prevent the ISPC compiler from
  // causing SIGFPEs and bogus results on divisions where inactive lanes
  // have 0-valued divisors. It ensures that any inactive lane instead
  // has a divisor of 1. https://github.com/ispc/ispc/issues/2292
  uint8_t ys = 1;
  foreach_active(i) { ys = y; }
  return x / ys;
}

SCALAR_FUN_ATTR uint16_t udiv16(uint16_t x, uint16_t y) {
  uint16_t ys = 1;
  foreach_active(i) { ys = y; }
  return x / ys;
}

SCALAR_FUN_ATTR uint32_t udiv32(uint32_t x, uint32_t y) {
  uint32_t ys = 1;
  foreach_active(i) { ys = y; }
  return x / ys;
}

SCALAR_FUN_ATTR uint64_t udiv64(uint64_t x, uint64_t y) {
  uint64_t ys = 1;
  foreach_active(i) { ys = y; }
  return x / ys;
}

SCALAR_FUN_ATTR uint8_t udiv_up8(uint8_t x, uint8_t y) {
  uint8_t ys = 1;
  foreach_active(i) { ys = y; }
  return (x + y - 1) / ys;
}

SCALAR_FUN_ATTR uint16_t udiv_up16(uint16_t x, uint16_t y) {
  uint16_t ys = 1;
  foreach_active(i) { ys = y; }
  return (x + y - 1) / ys;
}

SCALAR_FUN_ATTR uint32_t udiv_up32(uint32_t x, uint32_t y) {
  uint32_t ys = 1;
  foreach_active(i) { ys = y; }
  return (x + y - 1) / ys;
}

SCALAR_FUN_ATTR uint64_t udiv_up64(uint64_t x, uint64_t y) {
  uint64_t ys = 1;
  foreach_active(i) { ys = y; }
  return (x + y - 1) / ys;
}

SCALAR_FUN_ATTR uint8_t umod8(uint8_t x, uint8_t y) {
  uint8_t ys = 1;
  foreach_active(i) { ys = y; }
  return x % ys;
}

SCALAR_FUN_ATTR uint16_t umod16(uint16_t x, uint16_t y) {
  uint16_t ys = 1;
  foreach_active(i) { ys = y; }
  return x % ys;
}

SCALAR_FUN_ATTR uint32_t umod32(uint32_t x, uint32_t y) {
  uint32_t ys = 1;
  foreach_active(i) { ys = y; }
  return x % ys;
}

SCALAR_FUN_ATTR uint64_t umod64(uint64_t x, uint64_t y) {
  uint64_t ys = 1;
  foreach_active(i) { ys = y; }
  return x % ys;
}

SCALAR_FUN_ATTR uint8_t udiv_safe8(uint8_t x, uint8_t y) {
  uint8_t ys = 1;
  foreach_active(i) { ys = y; }
  return y == 0 ? 0 : x / ys;
}

SCALAR_FUN_ATTR uint16_t udiv_safe16(uint16_t x, uint16_t y) {
  uint16_t ys = 1;
  foreach_active(i) { ys = y; }
  return y == 0 ? 0 : x / ys;
}

SCALAR_FUN_ATTR uint32_t udiv_safe32(uint32_t x, uint32_t y) {
  uint32_t ys = 1;
  foreach_active(i) { ys = y; }
  return y == 0 ? 0 : x / ys;
}

SCALAR_FUN_ATTR uint64_t udiv_safe64(uint64_t x, uint64_t y) {
  uint64_t ys = 1;
  foreach_active(i) { ys = y; }
  return y == 0 ? 0 : x / ys;
}

SCALAR_FUN_ATTR uint8_t udiv_up_safe8(uint8_t x, uint8_t y) {
  uint8_t ys = 1;
  foreach_active(i) { ys = y; }
  return y == 0 ? 0 : (x + y - 1) / ys;
}

SCALAR_FUN_ATTR uint16_t udiv_up_safe16(uint16_t x, uint16_t y) {
  uint16_t ys = 1;
  foreach_active(i) { ys = y; }
  return y == 0 ? 0 : (x + y - 1) / ys;
}

SCALAR_FUN_ATTR uint32_t udiv_up_safe32(uint32_t x, uint32_t y) {
  uint32_t ys = 1;
  foreach_active(i) { ys = y; }
  return y == 0 ? 0 : (x + y - 1) / ys;
}

SCALAR_FUN_ATTR uint64_t udiv_up_safe64(uint64_t x, uint64_t y) {
  uint64_t ys = 1;
  foreach_active(i) { ys = y; }
  return y == 0 ? 0 : (x + y - 1) / ys;
}

SCALAR_FUN_ATTR uint8_t umod_safe8(uint8_t x, uint8_t y) {
  uint8_t ys = 1;
  foreach_active(i) { ys = y; }
  return y == 0 ? 0 : x % ys;
}

SCALAR_FUN_ATTR uint16_t umod_safe16(uint16_t x, uint16_t y) {
  uint16_t ys = 1;
  foreach_active(i) { ys = y; }
  return y == 0 ? 0 : x % ys;
}

SCALAR_FUN_ATTR uint32_t umod_safe32(uint32_t x, uint32_t y) {
  uint32_t ys = 1;
  foreach_active(i) { ys = y; }
  return y == 0 ? 0 : x % ys;
}

SCALAR_FUN_ATTR uint64_t umod_safe64(uint64_t x, uint64_t y) {
  uint64_t ys = 1;
  foreach_active(i) { ys = y; }
  return y == 0 ? 0 : x % ys;
}

SCALAR_FUN_ATTR int8_t sdiv8(int8_t x, int8_t y) {
  int8_t ys = 1;
  foreach_active(i) { ys = y; }
  int8_t q = x / ys;
  int8_t r = x % ys;
  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

SCALAR_FUN_ATTR int16_t sdiv16(int16_t x, int16_t y) {
  int16_t ys = 1;
  foreach_active(i) { ys = y; }
  int16_t q = x / ys;
  int16_t r = x % ys;
  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

SCALAR_FUN_ATTR int32_t sdiv32(int32_t x, int32_t y) {
  int32_t ys = 1;
  foreach_active(i) { ys = y; }
  int32_t q = x / ys;
  int32_t r = x % ys;
  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

SCALAR_FUN_ATTR int64_t sdiv64(int64_t x, int64_t y) {
  int64_t ys = 1;
  foreach_active(i) { ys = y; }
  int64_t q = x / ys;
  int64_t r = x % ys;
  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

SCALAR_FUN_ATTR int8_t sdiv_up8(int8_t x, int8_t y) { return sdiv8(x + y - 1, y); }
SCALAR_FUN_ATTR int16_t sdiv_up16(int16_t x, int16_t y) { return sdiv16(x + y - 1, y); }
SCALAR_FUN_ATTR int32_t sdiv_up32(int32_t x, int32_t y) { return sdiv32(x + y - 1, y); }
SCALAR_FUN_ATTR int64_t sdiv_up64(int64_t x, int64_t y) { return sdiv64(x + y - 1, y); }

SCALAR_FUN_ATTR int8_t smod8(int8_t x, int8_t y) {
  int8_t ys = 1;
  foreach_active(i) { ys = y; }
  int8_t r = x % ys;
  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

SCALAR_FUN_ATTR int16_t smod16(int16_t x, int16_t y) {
  int16_t ys = 1;
  foreach_active(i) { ys = y; }
  int16_t r = x % ys;
  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

SCALAR_FUN_ATTR int32_t smod32(int32_t x, int32_t y) {
  int32_t ys = 1;
  foreach_active(i) { ys = y; }
  int32_t r = x % ys;
  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

SCALAR_FUN_ATTR int64_t smod64(int64_t x, int64_t y) {
  int64_t ys = 1;
  foreach_active(i) { ys = y; }
  int64_t r = x % ys;
  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

SCALAR_FUN_ATTR int8_t   sdiv_safe8(int8_t x, int8_t y)   { return y == 0 ? 0 : sdiv8(x, y); }
SCALAR_FUN_ATTR int16_t sdiv_safe16(int16_t x, int16_t y) { return y == 0 ? 0 : sdiv16(x, y); }
SCALAR_FUN_ATTR int32_t sdiv_safe32(int32_t x, int32_t y) { return y == 0 ? 0 : sdiv32(x, y); }
SCALAR_FUN_ATTR int64_t sdiv_safe64(int64_t x, int64_t y) { return y == 0 ? 0 : sdiv64(x, y); }

SCALAR_FUN_ATTR int8_t sdiv_up_safe8(int8_t x, int8_t y)     { return sdiv_safe8(x + y - 1, y); }
SCALAR_FUN_ATTR int16_t sdiv_up_safe16(int16_t x, int16_t y) { return sdiv_safe16(x + y - 1, y); }
SCALAR_FUN_ATTR int32_t sdiv_up_safe32(int32_t x, int32_t y) { return sdiv_safe32(x + y - 1, y); }
SCALAR_FUN_ATTR int64_t sdiv_up_safe64(int64_t x, int64_t y) { return sdiv_safe64(x + y - 1, y); }

SCALAR_FUN_ATTR int8_t   smod_safe8(int8_t x, int8_t y)   { return y == 0 ? 0 : smod8(x, y); }
SCALAR_FUN_ATTR int16_t smod_safe16(int16_t x, int16_t y) { return y == 0 ? 0 : smod16(x, y); }
SCALAR_FUN_ATTR int32_t smod_safe32(int32_t x, int32_t y) { return y == 0 ? 0 : smod32(x, y); }
SCALAR_FUN_ATTR int64_t smod_safe64(int64_t x, int64_t y) { return y == 0 ? 0 : smod64(x, y); }

SCALAR_FUN_ATTR int8_t squot8(int8_t x, int8_t y) {
  int8_t ys = 1;
  foreach_active(i) { ys = y; }
  return x / ys;
}

SCALAR_FUN_ATTR int16_t squot16(int16_t x, int16_t y) {
  int16_t ys = 1;
  foreach_active(i) { ys = y; }
  return x / ys;
}

SCALAR_FUN_ATTR int32_t squot32(int32_t x, int32_t y) {
  int32_t ys = 1;
  foreach_active(i) { ys = y; }
  return x / ys;
}

SCALAR_FUN_ATTR int64_t squot64(int64_t x, int64_t y) {
  int64_t ys = 1;
  foreach_active(i) { ys = y; }
  return x / ys;
}

SCALAR_FUN_ATTR int8_t srem8(int8_t x, int8_t y) {
  int8_t ys = 1;
  foreach_active(i) { ys = y; }
  return x % ys;
}

SCALAR_FUN_ATTR int16_t srem16(int16_t x, int16_t y) {
  int16_t ys = 1;
  foreach_active(i) { ys = y; }
  return x % ys;
}

SCALAR_FUN_ATTR int32_t srem32(int32_t x, int32_t y) {
  int32_t ys = 1;
  foreach_active(i) { ys = y; }
  return x % ys;
}

SCALAR_FUN_ATTR int64_t srem64(int64_t x, int64_t y) {
  int8_t ys = 1;
  foreach_active(i) { ys = y; }
  return x % ys;
}

SCALAR_FUN_ATTR int8_t squot_safe8(int8_t x, int8_t y) {
  int8_t ys = 1;
  foreach_active(i) { ys = y; }
  return y == 0 ? 0 : x / ys;
}

SCALAR_FUN_ATTR int16_t squot_safe16(int16_t x, int16_t y) {
  int16_t ys = 1;
  foreach_active(i) { ys = y; }
  return y == 0 ? 0 : x / ys;
}

SCALAR_FUN_ATTR int32_t squot_safe32(int32_t x, int32_t y) {
  int32_t ys = 1;
  foreach_active(i) { ys = y; }
  return y == 0 ? 0 : x / ys;
}

SCALAR_FUN_ATTR int64_t squot_safe64(int64_t x, int64_t y) {
  int64_t ys = 1;
  foreach_active(i) { ys = y; }
  return y == 0 ? 0 : x / ys;
}

SCALAR_FUN_ATTR int8_t srem_safe8(int8_t x, int8_t y) {
  int8_t ys = 1;
  foreach_active(i) { ys = y; }
  return y == 0 ? 0 : x % ys;
}

SCALAR_FUN_ATTR int16_t srem_safe16(int16_t x, int16_t y) {
  int16_t ys = 1;
  foreach_active(i) { ys = y; }
  return y == 0 ? 0 : x % ys;
}

SCALAR_FUN_ATTR int32_t srem_safe32(int32_t x, int32_t y) {
  int32_t ys = 1;
  foreach_active(i) { ys = y; }
  return y == 0 ? 0 : x % ys;
}

SCALAR_FUN_ATTR int64_t srem_safe64(int64_t x, int64_t y) {
  int64_t ys = 1;
  foreach_active(i) { ys = y; }
  return y == 0 ? 0 : x % ys;
}

#else

SCALAR_FUN_ATTR uint8_t   udiv8(uint8_t x, uint8_t y)   { return x / y; }
SCALAR_FUN_ATTR uint16_t udiv16(uint16_t x, uint16_t y) { return x / y; }
SCALAR_FUN_ATTR uint32_t udiv32(uint32_t x, uint32_t y) { return x / y; }
SCALAR_FUN_ATTR uint64_t udiv64(uint64_t x, uint64_t y) { return x / y; }

SCALAR_FUN_ATTR uint8_t   udiv_up8(uint8_t x, uint8_t y)   { return (x + y - 1) / y; }
SCALAR_FUN_ATTR uint16_t udiv_up16(uint16_t x, uint16_t y) { return (x + y - 1) / y; }
SCALAR_FUN_ATTR uint32_t udiv_up32(uint32_t x, uint32_t y) { return (x + y - 1) / y; }
SCALAR_FUN_ATTR uint64_t udiv_up64(uint64_t x, uint64_t y) { return (x + y - 1) / y; }

SCALAR_FUN_ATTR uint8_t   umod8(uint8_t x, uint8_t y)   { return x % y; }
SCALAR_FUN_ATTR uint16_t umod16(uint16_t x, uint16_t y) { return x % y; }
SCALAR_FUN_ATTR uint32_t umod32(uint32_t x, uint32_t y) { return x % y; }
SCALAR_FUN_ATTR uint64_t umod64(uint64_t x, uint64_t y) { return x % y; }

SCALAR_FUN_ATTR uint8_t   udiv_safe8(uint8_t x, uint8_t y)   { return y == 0 ? 0 : x / y; }
SCALAR_FUN_ATTR uint16_t udiv_safe16(uint16_t x, uint16_t y) { return y == 0 ? 0 : x / y; }
SCALAR_FUN_ATTR uint32_t udiv_safe32(uint32_t x, uint32_t y) { return y == 0 ? 0 : x / y; }
SCALAR_FUN_ATTR uint64_t udiv_safe64(uint64_t x, uint64_t y) { return y == 0 ? 0 : x / y; }

SCALAR_FUN_ATTR uint8_t   udiv_up_safe8(uint8_t x, uint8_t y)   { return y == 0 ? 0 : (x + y - 1) / y; }
SCALAR_FUN_ATTR uint16_t udiv_up_safe16(uint16_t x, uint16_t y) { return y == 0 ? 0 : (x + y - 1) / y; }
SCALAR_FUN_ATTR uint32_t udiv_up_safe32(uint32_t x, uint32_t y) { return y == 0 ? 0 : (x + y - 1) / y; }
SCALAR_FUN_ATTR uint64_t udiv_up_safe64(uint64_t x, uint64_t y) { return y == 0 ? 0 : (x + y - 1) / y; }

SCALAR_FUN_ATTR uint8_t   umod_safe8(uint8_t x, uint8_t y)   { return y == 0 ? 0 : x % y; }
SCALAR_FUN_ATTR uint16_t umod_safe16(uint16_t x, uint16_t y) { return y == 0 ? 0 : x % y; }
SCALAR_FUN_ATTR uint32_t umod_safe32(uint32_t x, uint32_t y) { return y == 0 ? 0 : x % y; }
SCALAR_FUN_ATTR uint64_t umod_safe64(uint64_t x, uint64_t y) { return y == 0 ? 0 : x % y; }

SCALAR_FUN_ATTR int8_t sdiv8(int8_t x, int8_t y) {
  int8_t q = x / y;
  int8_t r = x % y;
  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

SCALAR_FUN_ATTR int16_t sdiv16(int16_t x, int16_t y) {
  int16_t q = x / y;
  int16_t r = x % y;
  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

SCALAR_FUN_ATTR int32_t sdiv32(int32_t x, int32_t y) {
  int32_t q = x / y;
  int32_t r = x % y;
  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

SCALAR_FUN_ATTR int64_t sdiv64(int64_t x, int64_t y) {
  int64_t q = x / y;
  int64_t r = x % y;
  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

SCALAR_FUN_ATTR int8_t   sdiv_up8(int8_t x, int8_t y)   { return sdiv8(x + y - 1, y); }
SCALAR_FUN_ATTR int16_t sdiv_up16(int16_t x, int16_t y) { return sdiv16(x + y - 1, y); }
SCALAR_FUN_ATTR int32_t sdiv_up32(int32_t x, int32_t y) { return sdiv32(x + y - 1, y); }
SCALAR_FUN_ATTR int64_t sdiv_up64(int64_t x, int64_t y) { return sdiv64(x + y - 1, y); }

SCALAR_FUN_ATTR int8_t smod8(int8_t x, int8_t y) {
  int8_t r = x % y;
  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

SCALAR_FUN_ATTR int16_t smod16(int16_t x, int16_t y) {
  int16_t r = x % y;
  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

SCALAR_FUN_ATTR int32_t smod32(int32_t x, int32_t y) {
  int32_t r = x % y;
  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

SCALAR_FUN_ATTR int64_t smod64(int64_t x, int64_t y) {
  int64_t r = x % y;
  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

SCALAR_FUN_ATTR int8_t   sdiv_safe8(int8_t x, int8_t y)   { return y == 0 ? 0 : sdiv8(x, y); }
SCALAR_FUN_ATTR int16_t sdiv_safe16(int16_t x, int16_t y) { return y == 0 ? 0 : sdiv16(x, y); }
SCALAR_FUN_ATTR int32_t sdiv_safe32(int32_t x, int32_t y) { return y == 0 ? 0 : sdiv32(x, y); }
SCALAR_FUN_ATTR int64_t sdiv_safe64(int64_t x, int64_t y) { return y == 0 ? 0 : sdiv64(x, y); }

SCALAR_FUN_ATTR int8_t   sdiv_up_safe8(int8_t x, int8_t y)   { return sdiv_safe8(x + y - 1, y);}
SCALAR_FUN_ATTR int16_t sdiv_up_safe16(int16_t x, int16_t y) { return sdiv_safe16(x + y - 1, y); }
SCALAR_FUN_ATTR int32_t sdiv_up_safe32(int32_t x, int32_t y) { return sdiv_safe32(x + y - 1, y); }
SCALAR_FUN_ATTR int64_t sdiv_up_safe64(int64_t x, int64_t y) { return sdiv_safe64(x + y - 1, y); }

SCALAR_FUN_ATTR int8_t   smod_safe8(int8_t x, int8_t y)   { return y == 0 ? 0 : smod8(x, y); }
SCALAR_FUN_ATTR int16_t smod_safe16(int16_t x, int16_t y) { return y == 0 ? 0 : smod16(x, y); }
SCALAR_FUN_ATTR int32_t smod_safe32(int32_t x, int32_t y) { return y == 0 ? 0 : smod32(x, y); }
SCALAR_FUN_ATTR int64_t smod_safe64(int64_t x, int64_t y) { return y == 0 ? 0 : smod64(x, y); }

SCALAR_FUN_ATTR int8_t   squot8(int8_t x, int8_t y)   { return x / y; }
SCALAR_FUN_ATTR int16_t squot16(int16_t x, int16_t y) { return x / y; }
SCALAR_FUN_ATTR int32_t squot32(int32_t x, int32_t y) { return x / y; }
SCALAR_FUN_ATTR int64_t squot64(int64_t x, int64_t y) { return x / y; }

SCALAR_FUN_ATTR int8_t   srem8(int8_t x, int8_t y)   { return x % y; }
SCALAR_FUN_ATTR int16_t srem16(int16_t x, int16_t y) { return x % y; }
SCALAR_FUN_ATTR int32_t srem32(int32_t x, int32_t y) { return x % y; }
SCALAR_FUN_ATTR int64_t srem64(int64_t x, int64_t y) { return x % y; }

SCALAR_FUN_ATTR int8_t   squot_safe8(int8_t x, int8_t y)   { return y == 0 ? 0 : x / y; }
SCALAR_FUN_ATTR int16_t squot_safe16(int16_t x, int16_t y) { return y == 0 ? 0 : x / y; }
SCALAR_FUN_ATTR int32_t squot_safe32(int32_t x, int32_t y) { return y == 0 ? 0 : x / y; }
SCALAR_FUN_ATTR int64_t squot_safe64(int64_t x, int64_t y) { return y == 0 ? 0 : x / y; }

SCALAR_FUN_ATTR int8_t   srem_safe8(int8_t x, int8_t y)   { return y == 0 ? 0 : x % y; }
SCALAR_FUN_ATTR int16_t srem_safe16(int16_t x, int16_t y) { return y == 0 ? 0 : x % y; }
SCALAR_FUN_ATTR int32_t srem_safe32(int32_t x, int32_t y) { return y == 0 ? 0 : x % y; }
SCALAR_FUN_ATTR int64_t srem_safe64(int64_t x, int64_t y) { return y == 0 ? 0 : x % y; }

#endif

SCALAR_FUN_ATTR int8_t   smin8(int8_t x, int8_t y)   { return x < y ? x : y; }
SCALAR_FUN_ATTR int16_t smin16(int16_t x, int16_t y) { return x < y ? x : y; }
SCALAR_FUN_ATTR int32_t smin32(int32_t x, int32_t y) { return x < y ? x : y; }
SCALAR_FUN_ATTR int64_t smin64(int64_t x, int64_t y) { return x < y ? x : y; }

SCALAR_FUN_ATTR uint8_t   umin8(uint8_t x, uint8_t y)   { return x < y ? x : y; }
SCALAR_FUN_ATTR uint16_t umin16(uint16_t x, uint16_t y) { return x < y ? x : y; }
SCALAR_FUN_ATTR uint32_t umin32(uint32_t x, uint32_t y) { return x < y ? x : y; }
SCALAR_FUN_ATTR uint64_t umin64(uint64_t x, uint64_t y) { return x < y ? x : y; }

SCALAR_FUN_ATTR int8_t  smax8(int8_t x, int8_t y)    { return x < y ? y : x; }
SCALAR_FUN_ATTR int16_t smax16(int16_t x, int16_t y) { return x < y ? y : x; }
SCALAR_FUN_ATTR int32_t smax32(int32_t x, int32_t y) { return x < y ? y : x; }
SCALAR_FUN_ATTR int64_t smax64(int64_t x, int64_t y) { return x < y ? y : x; }

SCALAR_FUN_ATTR uint8_t   umax8(uint8_t x, uint8_t y)   { return x < y ? y : x; }
SCALAR_FUN_ATTR uint16_t umax16(uint16_t x, uint16_t y) { return x < y ? y : x; }
SCALAR_FUN_ATTR uint32_t umax32(uint32_t x, uint32_t y) { return x < y ? y : x; }
SCALAR_FUN_ATTR uint64_t umax64(uint64_t x, uint64_t y) { return x < y ? y : x; }

SCALAR_FUN_ATTR uint8_t   shl8(uint8_t x, uint8_t y)   { return (uint8_t)(x << y); }
SCALAR_FUN_ATTR uint16_t shl16(uint16_t x, uint16_t y) { return (uint16_t)(x << y); }
SCALAR_FUN_ATTR uint32_t shl32(uint32_t x, uint32_t y) { return x << y; }
SCALAR_FUN_ATTR uint64_t shl64(uint64_t x, uint64_t y) { return x << y; }

SCALAR_FUN_ATTR uint8_t   lshr8(uint8_t x, uint8_t y)   { return x >> y; }
SCALAR_FUN_ATTR uint16_t lshr16(uint16_t x, uint16_t y) { return x >> y; }
SCALAR_FUN_ATTR uint32_t lshr32(uint32_t x, uint32_t y) { return x >> y; }
SCALAR_FUN_ATTR uint64_t lshr64(uint64_t x, uint64_t y) { return x >> y; }

SCALAR_FUN_ATTR int8_t   ashr8(int8_t x, int8_t y)   { return x >> y; }
SCALAR_FUN_ATTR int16_t ashr16(int16_t x, int16_t y) { return x >> y; }
SCALAR_FUN_ATTR int32_t ashr32(int32_t x, int32_t y) { return x >> y; }
SCALAR_FUN_ATTR int64_t ashr64(int64_t x, int64_t y) { return x >> y; }

SCALAR_FUN_ATTR uint8_t   and8(uint8_t x, uint8_t y)   { return x & y; }
SCALAR_FUN_ATTR uint16_t and16(uint16_t x, uint16_t y) { return x & y; }
SCALAR_FUN_ATTR uint32_t and32(uint32_t x, uint32_t y) { return x & y; }
SCALAR_FUN_ATTR uint64_t and64(uint64_t x, uint64_t y) { return x & y; }

SCALAR_FUN_ATTR uint8_t    or8(uint8_t x, uint8_t y)  { return x | y; }
SCALAR_FUN_ATTR uint16_t or16(uint16_t x, uint16_t y) { return x | y; }
SCALAR_FUN_ATTR uint32_t or32(uint32_t x, uint32_t y) { return x | y; }
SCALAR_FUN_ATTR uint64_t or64(uint64_t x, uint64_t y) { return x | y; }

SCALAR_FUN_ATTR uint8_t   xor8(uint8_t x, uint8_t y)   { return x ^ y; }
SCALAR_FUN_ATTR uint16_t xor16(uint16_t x, uint16_t y) { return x ^ y; }
SCALAR_FUN_ATTR uint32_t xor32(uint32_t x, uint32_t y) { return x ^ y; }
SCALAR_FUN_ATTR uint64_t xor64(uint64_t x, uint64_t y) { return x ^ y; }

SCALAR_FUN_ATTR bool ult8(uint8_t x, uint8_t y)    { return x < y; }
SCALAR_FUN_ATTR bool ult16(uint16_t x, uint16_t y) { return x < y; }
SCALAR_FUN_ATTR bool ult32(uint32_t x, uint32_t y) { return x < y; }
SCALAR_FUN_ATTR bool ult64(uint64_t x, uint64_t y) { return x < y; }

SCALAR_FUN_ATTR bool ule8(uint8_t x, uint8_t y)    { return x <= y; }
SCALAR_FUN_ATTR bool ule16(uint16_t x, uint16_t y) { return x <= y; }
SCALAR_FUN_ATTR bool ule32(uint32_t x, uint32_t y) { return x <= y; }
SCALAR_FUN_ATTR bool ule64(uint64_t x, uint64_t y) { return x <= y; }

SCALAR_FUN_ATTR bool  slt8(int8_t x, int8_t y)   { return x < y; }
SCALAR_FUN_ATTR bool slt16(int16_t x, int16_t y) { return x < y; }
SCALAR_FUN_ATTR bool slt32(int32_t x, int32_t y) { return x < y; }
SCALAR_FUN_ATTR bool slt64(int64_t x, int64_t y) { return x < y; }

SCALAR_FUN_ATTR bool  sle8(int8_t x, int8_t y)   { return x <= y; }
SCALAR_FUN_ATTR bool sle16(int16_t x, int16_t y) { return x <= y; }
SCALAR_FUN_ATTR bool sle32(int32_t x, int32_t y) { return x <= y; }
SCALAR_FUN_ATTR bool sle64(int64_t x, int64_t y) { return x <= y; }

SCALAR_FUN_ATTR uint8_t pow8(uint8_t x, uint8_t y) {
  uint8_t res = 1, rem = y;
  while (rem != 0) {
    if (rem & 1)
      res *= x;
    rem >>= 1;
    x *= x;
  }
  return res;
}

SCALAR_FUN_ATTR uint16_t pow16(uint16_t x, uint16_t y) {
  uint16_t res = 1, rem = y;
  while (rem != 0) {
    if (rem & 1)
      res *= x;
    rem >>= 1;
    x *= x;
  }
  return res;
}

SCALAR_FUN_ATTR uint32_t pow32(uint32_t x, uint32_t y) {
  uint32_t res = 1, rem = y;
  while (rem != 0) {
    if (rem & 1)
      res *= x;
    rem >>= 1;
    x *= x;
  }
  return res;
}

SCALAR_FUN_ATTR uint64_t pow64(uint64_t x, uint64_t y) {
  uint64_t res = 1, rem = y;
  while (rem != 0) {
    if (rem & 1)
      res *= x;
    rem >>= 1;
    x *= x;
  }
  return res;
}

SCALAR_FUN_ATTR bool  itob_i8_bool(int8_t x)  { return x != 0; }
SCALAR_FUN_ATTR bool itob_i16_bool(int16_t x) { return x != 0; }
SCALAR_FUN_ATTR bool itob_i32_bool(int32_t x) { return x != 0; }
SCALAR_FUN_ATTR bool itob_i64_bool(int64_t x) { return x != 0; }

SCALAR_FUN_ATTR int8_t btoi_bool_i8(bool x)   { return x; }
SCALAR_FUN_ATTR int16_t btoi_bool_i16(bool x) { return x; }
SCALAR_FUN_ATTR int32_t btoi_bool_i32(bool x) { return x; }
SCALAR_FUN_ATTR int64_t btoi_bool_i64(bool x) { return x; }

#define sext_i8_i8(x) ((int8_t) (int8_t) (x))
#define sext_i8_i16(x) ((int16_t) (int8_t) (x))
#define sext_i8_i32(x) ((int32_t) (int8_t) (x))
#define sext_i8_i64(x) ((int64_t) (int8_t) (x))
#define sext_i16_i8(x) ((int8_t) (int16_t) (x))
#define sext_i16_i16(x) ((int16_t) (int16_t) (x))
#define sext_i16_i32(x) ((int32_t) (int16_t) (x))
#define sext_i16_i64(x) ((int64_t) (int16_t) (x))
#define sext_i32_i8(x) ((int8_t) (int32_t) (x))
#define sext_i32_i16(x) ((int16_t) (int32_t) (x))
#define sext_i32_i32(x) ((int32_t) (int32_t) (x))
#define sext_i32_i64(x) ((int64_t) (int32_t) (x))
#define sext_i64_i8(x) ((int8_t) (int64_t) (x))
#define sext_i64_i16(x) ((int16_t) (int64_t) (x))
#define sext_i64_i32(x) ((int32_t) (int64_t) (x))
#define sext_i64_i64(x) ((int64_t) (int64_t) (x))
#define zext_i8_i8(x) ((int8_t) (uint8_t) (x))
#define zext_i8_i16(x) ((int16_t) (uint8_t) (x))
#define zext_i8_i32(x) ((int32_t) (uint8_t) (x))
#define zext_i8_i64(x) ((int64_t) (uint8_t) (x))
#define zext_i16_i8(x) ((int8_t) (uint16_t) (x))
#define zext_i16_i16(x) ((int16_t) (uint16_t) (x))
#define zext_i16_i32(x) ((int32_t) (uint16_t) (x))
#define zext_i16_i64(x) ((int64_t) (uint16_t) (x))
#define zext_i32_i8(x) ((int8_t) (uint32_t) (x))
#define zext_i32_i16(x) ((int16_t) (uint32_t) (x))
#define zext_i32_i32(x) ((int32_t) (uint32_t) (x))
#define zext_i32_i64(x) ((int64_t) (uint32_t) (x))
#define zext_i64_i8(x) ((int8_t) (uint64_t) (x))
#define zext_i64_i16(x) ((int16_t) (uint64_t) (x))
#define zext_i64_i32(x) ((int32_t) (uint64_t) (x))
#define zext_i64_i64(x) ((int64_t) (uint64_t) (x))

SCALAR_FUN_ATTR int8_t   abs8(int8_t x)  { return (int8_t)abs(x); }
SCALAR_FUN_ATTR int16_t abs16(int16_t x) { return (int16_t)abs(x); }
SCALAR_FUN_ATTR int32_t abs32(int32_t x) { return abs(x); }
SCALAR_FUN_ATTR int64_t abs64(int64_t x) {
#if defined(__OPENCL_VERSION__) || defined(ISPC)
  return abs(x);
#else
  return llabs(x);
#endif
}

#if defined(__OPENCL_VERSION__)

SCALAR_FUN_ATTR int32_t  futrts_popc8(int8_t x)  { return popcount(x); }
SCALAR_FUN_ATTR int32_t futrts_popc16(int16_t x) { return popcount(x); }
SCALAR_FUN_ATTR int32_t futrts_popc32(int32_t x) { return popcount(x); }
SCALAR_FUN_ATTR int32_t futrts_popc64(int64_t x) { return popcount(x); }

#elif defined(__CUDA_ARCH__)

SCALAR_FUN_ATTR int32_t  futrts_popc8(int8_t x)  { return __popc(zext_i8_i32(x)); }
SCALAR_FUN_ATTR int32_t futrts_popc16(int16_t x) { return __popc(zext_i16_i32(x)); }
SCALAR_FUN_ATTR int32_t futrts_popc32(int32_t x) { return __popc(x); }
SCALAR_FUN_ATTR int32_t futrts_popc64(int64_t x) { return __popcll(x); }

#else // Not OpenCL or CUDA, but plain C.

SCALAR_FUN_ATTR int32_t futrts_popc8(uint8_t x) {
  int c = 0;
  for (; x; ++c) { x &= x - 1; }
  return c;
}

SCALAR_FUN_ATTR int32_t futrts_popc16(uint16_t x) {
  int c = 0;
  for (; x; ++c) { x &= x - 1; }
  return c;
}

SCALAR_FUN_ATTR int32_t futrts_popc32(uint32_t x) {
  int c = 0;
  for (; x; ++c) { x &= x - 1; }
  return c;
}

SCALAR_FUN_ATTR int32_t futrts_popc64(uint64_t x) {
  int c = 0;
  for (; x; ++c) { x &= x - 1; }
  return c;
}
#endif

#if defined(__OPENCL_VERSION__)
SCALAR_FUN_ATTR uint8_t  futrts_umul_hi8 ( uint8_t a,  uint8_t b) { return mul_hi(a, b); }
SCALAR_FUN_ATTR uint16_t futrts_umul_hi16(uint16_t a, uint16_t b) { return mul_hi(a, b); }
SCALAR_FUN_ATTR uint32_t futrts_umul_hi32(uint32_t a, uint32_t b) { return mul_hi(a, b); }
SCALAR_FUN_ATTR uint64_t futrts_umul_hi64(uint64_t a, uint64_t b) { return mul_hi(a, b); }
SCALAR_FUN_ATTR uint8_t  futrts_smul_hi8 ( int8_t a,  int8_t b) { return mul_hi(a, b); }
SCALAR_FUN_ATTR uint16_t futrts_smul_hi16(int16_t a, int16_t b) { return mul_hi(a, b); }
SCALAR_FUN_ATTR uint32_t futrts_smul_hi32(int32_t a, int32_t b) { return mul_hi(a, b); }
SCALAR_FUN_ATTR uint64_t futrts_smul_hi64(int64_t a, int64_t b) { return mul_hi(a, b); }
#elif defined(__CUDA_ARCH__)
SCALAR_FUN_ATTR  uint8_t futrts_umul_hi8(uint8_t a, uint8_t b) { return ((uint16_t)a) * ((uint16_t)b) >> 8; }
SCALAR_FUN_ATTR uint16_t futrts_umul_hi16(uint16_t a, uint16_t b) { return ((uint32_t)a) * ((uint32_t)b) >> 16; }
SCALAR_FUN_ATTR uint32_t futrts_umul_hi32(uint32_t a, uint32_t b) { return __umulhi(a, b); }
SCALAR_FUN_ATTR uint64_t futrts_umul_hi64(uint64_t a, uint64_t b) { return __umul64hi(a, b); }
SCALAR_FUN_ATTR  uint8_t futrts_smul_hi8 ( int8_t a, int8_t b) { return ((int16_t)a) * ((int16_t)b) >> 8; }
SCALAR_FUN_ATTR uint16_t futrts_smul_hi16(int16_t a, int16_t b) { return ((int32_t)a) * ((int32_t)b) >> 16; }
SCALAR_FUN_ATTR uint32_t futrts_smul_hi32(int32_t a, int32_t b) { return __mulhi(a, b); }
SCALAR_FUN_ATTR uint64_t futrts_smul_hi64(int64_t a, int64_t b) { return __mul64hi(a, b); }
#elif defined(ISPC)
SCALAR_FUN_ATTR uint8_t futrts_umul_hi8(uint8_t a, uint8_t b) { return ((uint16_t)a) * ((uint16_t)b) >> 8; }
SCALAR_FUN_ATTR uint16_t futrts_umul_hi16(uint16_t a, uint16_t b) { return ((uint32_t)a) * ((uint32_t)b) >> 16; }
SCALAR_FUN_ATTR uint32_t futrts_umul_hi32(uint32_t a, uint32_t b) { return ((uint64_t)a) * ((uint64_t)b) >> 32; }
SCALAR_FUN_ATTR uint64_t futrts_umul_hi64(uint64_t a, uint64_t b) {
  uint64_t ah = a >> 32;
  uint64_t al = a & 0xffffffff;
  uint64_t bh = b >> 32;
  uint64_t bl = b & 0xffffffff;

  uint64_t p1 = al * bl;
  uint64_t p2 = al * bh;
  uint64_t p3 = ah * bl;
  uint64_t p4 = ah * bh;

  uint64_t p1h = p1 >> 32;
  uint64_t p2h = p2 >> 32;
  uint64_t p3h = p3 >> 32;
  uint64_t p2l = p2 & 0xffffffff;
  uint64_t p3l = p3 & 0xffffffff;

  uint64_t l = p1h + p2l + p3l;
  uint64_t m = (p2 >> 32) + (p3 >> 32);
  uint64_t h = (l >> 32) + m + p4;

  return h;
}
SCALAR_FUN_ATTR  int8_t futrts_smul_hi8 ( int8_t a,  int8_t b) { return ((uint16_t)a) * ((uint16_t)b) >> 8; }
SCALAR_FUN_ATTR int16_t futrts_smul_hi16(int16_t a, int16_t b) { return ((uint32_t)a) * ((uint32_t)b) >> 16; }
SCALAR_FUN_ATTR int32_t futrts_smul_hi32(int32_t a, int32_t b) { return ((uint64_t)a) * ((uint64_t)b) >> 32; }
SCALAR_FUN_ATTR int64_t futrts_smul_hi64(int64_t a, int64_t b) {
  uint64_t ah = a >> 32;
  uint64_t al = a & 0xffffffff;
  uint64_t bh = b >> 32;
  uint64_t bl = b & 0xffffffff;

  uint64_t p1 =  al * bl;
  int64_t  p2 = al * bh;
  int64_t  p3 = ah * bl;
  uint64_t p4 =  ah * bh;

  uint64_t p1h = p1 >> 32;
  uint64_t p2h = p2 >> 32;
  uint64_t p3h = p3 >> 32;
  uint64_t p2l = p2 & 0xffffffff;
  uint64_t p3l = p3 & 0xffffffff;

  uint64_t l = p1h + p2l + p3l;
  uint64_t m = (p2 >> 32) + (p3 >> 32);
  uint64_t h = (l >> 32) + m + p4;

  return h;
}

#else // Not OpenCL, ISPC, or CUDA, but plain C.
SCALAR_FUN_ATTR uint8_t futrts_umul_hi8(uint8_t a, uint8_t b) { return ((uint16_t)a) * ((uint16_t)b) >> 8; }
SCALAR_FUN_ATTR uint16_t futrts_umul_hi16(uint16_t a, uint16_t b) { return ((uint32_t)a) * ((uint32_t)b) >> 16; }
SCALAR_FUN_ATTR uint32_t futrts_umul_hi32(uint32_t a, uint32_t b) { return ((uint64_t)a) * ((uint64_t)b) >> 32; }
SCALAR_FUN_ATTR uint64_t futrts_umul_hi64(uint64_t a, uint64_t b) { return ((__uint128_t)a) * ((__uint128_t)b) >> 64; }
SCALAR_FUN_ATTR int8_t futrts_smul_hi8(int8_t a, int8_t b) { return ((int16_t)a) * ((int16_t)b) >> 8; }
SCALAR_FUN_ATTR int16_t futrts_smul_hi16(int16_t a, int16_t b) { return ((int32_t)a) * ((int32_t)b) >> 16; }
SCALAR_FUN_ATTR int32_t futrts_smul_hi32(int32_t a, int32_t b) { return ((int64_t)a) * ((int64_t)b) >> 32; }
SCALAR_FUN_ATTR int64_t futrts_smul_hi64(int64_t a, int64_t b) { return ((__int128_t)a) * ((__int128_t)b) >> 64; }
#endif

#if defined(__OPENCL_VERSION__)
SCALAR_FUN_ATTR  uint8_t futrts_umad_hi8 ( uint8_t a,  uint8_t b,  uint8_t c) { return mad_hi(a, b, c); }
SCALAR_FUN_ATTR uint16_t futrts_umad_hi16(uint16_t a, uint16_t b, uint16_t c) { return mad_hi(a, b, c); }
SCALAR_FUN_ATTR uint32_t futrts_umad_hi32(uint32_t a, uint32_t b, uint32_t c) { return mad_hi(a, b, c); }
SCALAR_FUN_ATTR uint64_t futrts_umad_hi64(uint64_t a, uint64_t b, uint64_t c) { return mad_hi(a, b, c); }
SCALAR_FUN_ATTR  uint8_t futrts_smad_hi8( int8_t a,  int8_t b,   int8_t c) { return mad_hi(a, b, c); }
SCALAR_FUN_ATTR uint16_t futrts_smad_hi16(int16_t a, int16_t b, int16_t c) { return mad_hi(a, b, c); }
SCALAR_FUN_ATTR uint32_t futrts_smad_hi32(int32_t a, int32_t b, int32_t c) { return mad_hi(a, b, c); }
SCALAR_FUN_ATTR uint64_t futrts_smad_hi64(int64_t a, int64_t b, int64_t c) { return mad_hi(a, b, c); }
#else // Not OpenCL

SCALAR_FUN_ATTR  uint8_t futrts_umad_hi8( uint8_t a,  uint8_t b,  uint8_t c) { return futrts_umul_hi8(a, b) + c; }
SCALAR_FUN_ATTR uint16_t futrts_umad_hi16(uint16_t a, uint16_t b, uint16_t c) { return futrts_umul_hi16(a, b) + c; }
SCALAR_FUN_ATTR uint32_t futrts_umad_hi32(uint32_t a, uint32_t b, uint32_t c) { return futrts_umul_hi32(a, b) + c; }
SCALAR_FUN_ATTR uint64_t futrts_umad_hi64(uint64_t a, uint64_t b, uint64_t c) { return futrts_umul_hi64(a, b) + c; }
SCALAR_FUN_ATTR  uint8_t futrts_smad_hi8 ( int8_t a,  int8_t b,  int8_t c) { return futrts_smul_hi8(a, b) + c; }
SCALAR_FUN_ATTR uint16_t futrts_smad_hi16(int16_t a, int16_t b, int16_t c) { return futrts_smul_hi16(a, b) + c; }
SCALAR_FUN_ATTR uint32_t futrts_smad_hi32(int32_t a, int32_t b, int32_t c) { return futrts_smul_hi32(a, b) + c; }
SCALAR_FUN_ATTR uint64_t futrts_smad_hi64(int64_t a, int64_t b, int64_t c) { return futrts_smul_hi64(a, b) + c; }
#endif

#if defined(__OPENCL_VERSION__)
SCALAR_FUN_ATTR int32_t  futrts_clzz8(int8_t x)  { return clz(x); }
SCALAR_FUN_ATTR int32_t futrts_clzz16(int16_t x) { return clz(x); }
SCALAR_FUN_ATTR int32_t futrts_clzz32(int32_t x) { return clz(x); }
SCALAR_FUN_ATTR int32_t futrts_clzz64(int64_t x) { return clz(x); }

#elif defined(__CUDA_ARCH__)

SCALAR_FUN_ATTR int32_t  futrts_clzz8(int8_t x)  { return __clz(zext_i8_i32(x)) - 24; }
SCALAR_FUN_ATTR int32_t futrts_clzz16(int16_t x) { return __clz(zext_i16_i32(x)) - 16; }
SCALAR_FUN_ATTR int32_t futrts_clzz32(int32_t x) { return __clz(x); }
SCALAR_FUN_ATTR int32_t futrts_clzz64(int64_t x) { return __clzll(x); }

#elif defined(ISPC)

SCALAR_FUN_ATTR int32_t  futrts_clzz8(int8_t x)  { return count_leading_zeros((int32_t)(uint8_t)x)-24; }
SCALAR_FUN_ATTR int32_t futrts_clzz16(int16_t x) { return count_leading_zeros((int32_t)(uint16_t)x)-16; }
SCALAR_FUN_ATTR int32_t futrts_clzz32(int32_t x) { return count_leading_zeros(x); }
SCALAR_FUN_ATTR int32_t futrts_clzz64(int64_t x) { return count_leading_zeros(x); }

#else // Not OpenCL, ISPC or CUDA, but plain C.

SCALAR_FUN_ATTR int32_t futrts_clzz8(int8_t x)
{ return x == 0 ? 8 : __builtin_clz((uint32_t)zext_i8_i32(x)) - 24; }
SCALAR_FUN_ATTR int32_t futrts_clzz16(int16_t x)
{ return x == 0 ? 16 : __builtin_clz((uint32_t)zext_i16_i32(x)) - 16; }
SCALAR_FUN_ATTR int32_t futrts_clzz32(int32_t x)
{ return x == 0 ? 32 : __builtin_clz((uint32_t)x); }
SCALAR_FUN_ATTR int32_t futrts_clzz64(int64_t x)
{ return x == 0 ? 64 : __builtin_clzll((uint64_t)x); }
#endif

#if defined(__OPENCL_VERSION__)
SCALAR_FUN_ATTR int32_t futrts_ctzz8(int8_t x) {
  int i = 0;
  for (; i < 8 && (x & 1) == 0; i++, x >>= 1) ;
  return i;
}

SCALAR_FUN_ATTR int32_t futrts_ctzz16(int16_t x) {
  int i = 0;
  for (; i < 16 && (x & 1) == 0; i++, x >>= 1) ;
  return i;
}

SCALAR_FUN_ATTR int32_t futrts_ctzz32(int32_t x) {
  int i = 0;
  for (; i < 32 && (x & 1) == 0; i++, x >>= 1) ;
  return i;
}

SCALAR_FUN_ATTR int32_t futrts_ctzz64(int64_t x) {
  int i = 0;
  for (; i < 64 && (x & 1) == 0; i++, x >>= 1) ;
  return i;
}

#elif defined(__CUDA_ARCH__)

SCALAR_FUN_ATTR int32_t futrts_ctzz8(int8_t x) {
  int y = __ffs(x);
  return y == 0 ? 8 : y - 1;
}

SCALAR_FUN_ATTR int32_t futrts_ctzz16(int16_t x) {
  int y = __ffs(x);
  return y == 0 ? 16 : y - 1;
}

SCALAR_FUN_ATTR int32_t futrts_ctzz32(int32_t x) {
  int y = __ffs(x);
  return y == 0 ? 32 : y - 1;
}

SCALAR_FUN_ATTR int32_t futrts_ctzz64(int64_t x) {
  int y = __ffsll(x);
  return y == 0 ? 64 : y - 1;
}

#elif defined(ISPC)

SCALAR_FUN_ATTR int32_t futrts_ctzz8(int8_t x) { return x == 0 ? 8 : count_trailing_zeros((int32_t)x); }
SCALAR_FUN_ATTR int32_t futrts_ctzz16(int16_t x) { return x == 0 ? 16 : count_trailing_zeros((int32_t)x); }
SCALAR_FUN_ATTR int32_t futrts_ctzz32(int32_t x) { return count_trailing_zeros(x); }
SCALAR_FUN_ATTR int32_t futrts_ctzz64(int64_t x) { return count_trailing_zeros(x); }

#else // Not OpenCL or CUDA, but plain C.

SCALAR_FUN_ATTR int32_t  futrts_ctzz8(int8_t x)  { return x == 0 ? 8 : __builtin_ctz((uint32_t)x); }
SCALAR_FUN_ATTR int32_t futrts_ctzz16(int16_t x) { return x == 0 ? 16 : __builtin_ctz((uint32_t)x); }
SCALAR_FUN_ATTR int32_t futrts_ctzz32(int32_t x) { return x == 0 ? 32 : __builtin_ctz((uint32_t)x); }
SCALAR_FUN_ATTR int32_t futrts_ctzz64(int64_t x) { return x == 0 ? 64 : __builtin_ctzll((uint64_t)x); }
#endif

SCALAR_FUN_ATTR float fdiv32(float x, float y) { return x / y; }
SCALAR_FUN_ATTR float fadd32(float x, float y) { return x + y; }
SCALAR_FUN_ATTR float fsub32(float x, float y) { return x - y; }
SCALAR_FUN_ATTR float fmul32(float x, float y) { return x * y; }
SCALAR_FUN_ATTR bool cmplt32(float x, float y) { return x < y; }
SCALAR_FUN_ATTR bool cmple32(float x, float y) { return x <= y; }
SCALAR_FUN_ATTR float sitofp_i8_f32(int8_t x)  { return (float) x; }

SCALAR_FUN_ATTR float sitofp_i16_f32(int16_t x) { return (float) x; }
SCALAR_FUN_ATTR float sitofp_i32_f32(int32_t x) { return (float) x; }
SCALAR_FUN_ATTR float sitofp_i64_f32(int64_t x) { return (float) x; }
SCALAR_FUN_ATTR float  uitofp_i8_f32(uint8_t x)  { return (float) x; }
SCALAR_FUN_ATTR float uitofp_i16_f32(uint16_t x) { return (float) x; }
SCALAR_FUN_ATTR float uitofp_i32_f32(uint32_t x) { return (float) x; }
SCALAR_FUN_ATTR float uitofp_i64_f32(uint64_t x) { return (float) x; }

#ifdef __OPENCL_VERSION__
SCALAR_FUN_ATTR float fabs32(float x)          { return fabs(x); }
SCALAR_FUN_ATTR float fmax32(float x, float y) { return fmax(x, y); }
SCALAR_FUN_ATTR float fmin32(float x, float y) { return fmin(x, y); }
SCALAR_FUN_ATTR float fpow32(float x, float y) { return pow(x, y); }

#elif defined(ISPC)

SCALAR_FUN_ATTR float fabs32(float x) { return abs(x); }
SCALAR_FUN_ATTR float fmax32(float x, float y) { return isnan(x) ? y : isnan(y) ? x : max(x, y); }
SCALAR_FUN_ATTR float fmin32(float x, float y) { return isnan(x) ? y : isnan(y) ? x : min(x, y); }
SCALAR_FUN_ATTR float fpow32(float a, float b) {
  float ret;
  foreach_active (i) {
      uniform float r = pow(extract(a, i), extract(b, i));
      ret = insert(ret, i, r);
  }
  return ret;
}

#else // Not OpenCL, but CUDA or plain C.

SCALAR_FUN_ATTR float fabs32(float x)          { return fabsf(x); }
SCALAR_FUN_ATTR float fmax32(float x, float y) { return fmaxf(x, y); }
SCALAR_FUN_ATTR float fmin32(float x, float y) { return fminf(x, y); }
SCALAR_FUN_ATTR float fpow32(float x, float y) { return powf(x, y); }
#endif

SCALAR_FUN_ATTR bool futrts_isnan32(float x) { return isnan(x); }

#if defined(ISPC)

SCALAR_FUN_ATTR bool futrts_isinf32(float x) { return !isnan(x) && isnan(x - x); }

SCALAR_FUN_ATTR bool futrts_isfinite32(float x) { return !isnan(x) && !futrts_isinf32(x); }

#else

SCALAR_FUN_ATTR bool futrts_isinf32(float x) { return isinf(x); }

#endif

SCALAR_FUN_ATTR int8_t fptosi_f32_i8(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (int8_t) x;
  }
}

SCALAR_FUN_ATTR int16_t fptosi_f32_i16(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (int16_t) x;
  }
}

SCALAR_FUN_ATTR int32_t fptosi_f32_i32(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (int32_t) x;
  }
}

SCALAR_FUN_ATTR int64_t fptosi_f32_i64(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (int64_t) x;
  };
}

SCALAR_FUN_ATTR uint8_t fptoui_f32_i8(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (uint8_t) (int8_t) x;
  }
}

SCALAR_FUN_ATTR uint16_t fptoui_f32_i16(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (uint16_t) (int16_t) x;
  }
}

SCALAR_FUN_ATTR uint32_t fptoui_f32_i32(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (uint32_t) (int32_t) x;
  }
}

SCALAR_FUN_ATTR uint64_t fptoui_f32_i64(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (uint64_t) (int64_t) x;
  }
}

SCALAR_FUN_ATTR bool ftob_f32_bool(float x) { return x != 0; }
SCALAR_FUN_ATTR float btof_bool_f32(bool x) { return x ? 1 : 0; }

#ifdef __OPENCL_VERSION__
SCALAR_FUN_ATTR float futrts_log32(float x) { return log(x); }
SCALAR_FUN_ATTR float futrts_log2_32(float x) { return log2(x); }
SCALAR_FUN_ATTR float futrts_log10_32(float x) { return log10(x); }
SCALAR_FUN_ATTR float futrts_log1p_32(float x) { return log1p(x); }
SCALAR_FUN_ATTR float futrts_sqrt32(float x) { return sqrt(x); }
SCALAR_FUN_ATTR float futrts_rsqrt32(float x) { return rsqrt(x); }
SCALAR_FUN_ATTR float futrts_cbrt32(float x) { return cbrt(x); }
SCALAR_FUN_ATTR float futrts_exp32(float x) { return exp(x); }
SCALAR_FUN_ATTR float futrts_cos32(float x) { return cos(x); }
SCALAR_FUN_ATTR float futrts_cospi32(float x) { return cospi(x); }
SCALAR_FUN_ATTR float futrts_sin32(float x) { return sin(x); }
SCALAR_FUN_ATTR float futrts_sinpi32(float x) { return sinpi(x); }
SCALAR_FUN_ATTR float futrts_tan32(float x) { return tan(x); }
SCALAR_FUN_ATTR float futrts_tanpi32(float x) { return tanpi(x); }
SCALAR_FUN_ATTR float futrts_acos32(float x) { return acos(x); }
SCALAR_FUN_ATTR float futrts_acospi32(float x) { return acospi(x); }
SCALAR_FUN_ATTR float futrts_asin32(float x) { return asin(x); }
SCALAR_FUN_ATTR float futrts_asinpi32(float x) { return asinpi(x); }
SCALAR_FUN_ATTR float futrts_atan32(float x) { return atan(x); }
SCALAR_FUN_ATTR float futrts_atanpi32(float x) { return atanpi(x); }
SCALAR_FUN_ATTR float futrts_cosh32(float x) { return cosh(x); }
SCALAR_FUN_ATTR float futrts_sinh32(float x) { return sinh(x); }
SCALAR_FUN_ATTR float futrts_tanh32(float x) { return tanh(x); }
SCALAR_FUN_ATTR float futrts_acosh32(float x) { return acosh(x); }
SCALAR_FUN_ATTR float futrts_asinh32(float x) { return asinh(x); }
SCALAR_FUN_ATTR float futrts_atanh32(float x) { return atanh(x); }
SCALAR_FUN_ATTR float futrts_atan2_32(float x, float y) { return atan2(x, y); }
SCALAR_FUN_ATTR float futrts_atan2pi_32(float x, float y) { return atan2pi(x, y); }
SCALAR_FUN_ATTR float futrts_hypot32(float x, float y) { return hypot(x, y); }
SCALAR_FUN_ATTR float futrts_gamma32(float x) { return tgamma(x); }
SCALAR_FUN_ATTR float futrts_lgamma32(float x) { return lgamma(x); }
SCALAR_FUN_ATTR float futrts_erf32(float x) { return erf(x); }
SCALAR_FUN_ATTR float futrts_erfc32(float x) { return erfc(x); }
SCALAR_FUN_ATTR float fmod32(float x, float y) { return fmod(x, y); }
SCALAR_FUN_ATTR float futrts_round32(float x) { return rint(x); }
SCALAR_FUN_ATTR float futrts_floor32(float x) { return floor(x); }
SCALAR_FUN_ATTR float futrts_ceil32(float x) { return ceil(x); }
SCALAR_FUN_ATTR float futrts_nextafter32(float x, float y) { return nextafter(x, y); }
SCALAR_FUN_ATTR float futrts_lerp32(float v0, float v1, float t) { return mix(v0, v1, t); }
SCALAR_FUN_ATTR float futrts_ldexp32(float x, int32_t y) { return ldexp(x, y); }
SCALAR_FUN_ATTR float futrts_copysign32(float x, float y) { return copysign(x, y); }
SCALAR_FUN_ATTR float futrts_mad32(float a, float b, float c) { return mad(a, b, c); }
SCALAR_FUN_ATTR float futrts_fma32(float a, float b, float c) { return fma(a, b, c); }

#elif defined(ISPC)

SCALAR_FUN_ATTR float futrts_log32(float x) { return futrts_isfinite32(x) || (futrts_isinf32(x) && x < 0)? log(x) : x; }
SCALAR_FUN_ATTR float futrts_log2_32(float x) { return futrts_log32(x) / log(2.0f); }
SCALAR_FUN_ATTR float futrts_log10_32(float x) { return futrts_log32(x) / log(10.0f); }

SCALAR_FUN_ATTR float futrts_log1p_32(float x) {
  if(x == -1.0f || (futrts_isinf32(x) && x > 0.0f)) return x / 0.0f;
  float y = 1.0f + x;
  float z = y - 1.0f;
  return log(y) - (z-x)/y;
}

SCALAR_FUN_ATTR float futrts_sqrt32(float x) { return sqrt(x); }
SCALAR_FUN_ATTR float futrts_rsqrt32(float x) { return 1/sqrt(x); }

extern "C" unmasked uniform float cbrtf(uniform float);
SCALAR_FUN_ATTR float futrts_cbrt32(float x) {
  float res;
  foreach_active (i) {
    uniform float r = cbrtf(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

SCALAR_FUN_ATTR float futrts_exp32(float x) { return exp(x); }
SCALAR_FUN_ATTR float futrts_cos32(float x) { return cos(x); }
SCALAR_FUN_ATTR float futrts_cospi32(float x) { return cos((float)M_PI*x); }
SCALAR_FUN_ATTR float futrts_sin32(float x) { return sin(x); }
SCALAR_FUN_ATTR float futrts_sinpi32(float x) { return sin(M_PI*x); }
SCALAR_FUN_ATTR float futrts_tan32(float x) { return tan(x); }
SCALAR_FUN_ATTR float futrts_tanpi32(float x) { return tan((float)M_PI*x); }
SCALAR_FUN_ATTR float futrts_acos32(float x) { return acos(x); }
SCALAR_FUN_ATTR float futrts_acospi32(float x) { return acos(x)/(float)M_PI; }
SCALAR_FUN_ATTR float futrts_asin32(float x) { return asin(x); }
SCALAR_FUN_ATTR float futrts_asinpi32(float x) { return asin(x)/(float)M_PI; }
SCALAR_FUN_ATTR float futrts_atan32(float x) { return atan(x); }
SCALAR_FUN_ATTR float futrts_atanpi32(float x) { return atan(x)/(float)M_PI; }
SCALAR_FUN_ATTR float futrts_cosh32(float x) { return (exp(x)+exp(-x)) / 2.0f; }
SCALAR_FUN_ATTR float futrts_sinh32(float x) { return (exp(x)-exp(-x)) / 2.0f; }
SCALAR_FUN_ATTR float futrts_tanh32(float x) { return futrts_sinh32(x)/futrts_cosh32(x); }

SCALAR_FUN_ATTR float futrts_acosh32(float x) {
  float f = x+sqrt(x*x-1);
  if (futrts_isfinite32(f)) return log(f);
  return f;
}

SCALAR_FUN_ATTR float futrts_asinh32(float x) {
  float f = x+sqrt(x*x+1);
  if (futrts_isfinite32(f)) return log(f);
  return f;
}

SCALAR_FUN_ATTR float futrts_atanh32(float x) {
  float f = (1+x)/(1-x);
  if (futrts_isfinite32(f)) return log(f)/2.0f;
  return f;
}

SCALAR_FUN_ATTR float futrts_atan2_32(float x, float y)
{ return (x == 0.0f && y == 0.0f) ? 0.0f : atan2(x, y); }
SCALAR_FUN_ATTR float futrts_atan2pi_32(float x, float y)
{ return (x == 0.0f && y == 0.0f) ? 0.0f : atan2(x, y) / (float)M_PI; }

SCALAR_FUN_ATTR float futrts_hypot32(float x, float y) {
  if (futrts_isfinite32(x) && futrts_isfinite32(y)) {
    x = abs(x);
    y = abs(y);
    float a;
    float b;
    if (x >= y){
        a = x;
        b = y;
    } else {
        a = y;
        b = x;
    }
    if(b == 0){
      return a;
    }

    int e;
    float an;
    float bn;
    an = frexp (a, &e);
    bn = ldexp (b, - e);
    float cn;
    cn = sqrt (an * an + bn * bn);
    return ldexp (cn, e);
  } else {
    if (futrts_isinf32(x) || futrts_isinf32(y)) return INFINITY;
    else return x + y;
  }

}

extern "C" unmasked uniform float tgammaf(uniform float x);
SCALAR_FUN_ATTR float futrts_gamma32(float x) {
  float res;
  foreach_active (i) {
    uniform float r = tgammaf(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

extern "C" unmasked uniform float lgammaf(uniform float x);
SCALAR_FUN_ATTR float futrts_lgamma32(float x) {
  float res;
  foreach_active (i) {
    uniform float r = lgammaf(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

extern "C" unmasked uniform float erff(uniform float x);
SCALAR_FUN_ATTR float futrts_erf32(float x) {
  float res;
  foreach_active (i) {
    uniform float r = erff(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

extern "C" unmasked uniform float erfcf(uniform float x);
SCALAR_FUN_ATTR float futrts_erfc32(float x) {
  float res;
  foreach_active (i) {
    uniform float r = erfcf(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

SCALAR_FUN_ATTR float fmod32(float x, float y) { return x - y * trunc(x/y); }
SCALAR_FUN_ATTR float futrts_round32(float x) { return round(x); }
SCALAR_FUN_ATTR float futrts_floor32(float x) { return floor(x); }
SCALAR_FUN_ATTR float futrts_ceil32(float x) { return ceil(x); }

extern "C" unmasked uniform float nextafterf(uniform float x, uniform float y);
SCALAR_FUN_ATTR float futrts_nextafter32(float x, float y) {
  float res;
  foreach_active (i) {
    uniform float r = nextafterf(extract(x, i), extract(y, i));
    res = insert(res, i, r);
  }
  return res;
}

SCALAR_FUN_ATTR float futrts_lerp32(float v0, float v1, float t) {
  return v0 + (v1 - v0) * t;
}

SCALAR_FUN_ATTR float futrts_ldexp32(float x, int32_t y) {
  return x * pow((uniform float)2.0, (float)y);
}

SCALAR_FUN_ATTR float futrts_copysign32(float x, float y) {
  int32_t xb = fptobits_f32_i32(x);
  int32_t yb = fptobits_f32_i32(y);
  return bitstofp_i32_f32((xb & ~(1<<31)) | (yb & (1<<31)));
}

SCALAR_FUN_ATTR float futrts_mad32(float a, float b, float c) {
  return a * b + c;
}

SCALAR_FUN_ATTR float futrts_fma32(float a, float b, float c) {
  return a * b + c;
}

#else // Not OpenCL or ISPC, but CUDA or plain C.

SCALAR_FUN_ATTR float futrts_log32(float x) { return logf(x); }
SCALAR_FUN_ATTR float futrts_log2_32(float x) { return log2f(x); }
SCALAR_FUN_ATTR float futrts_log10_32(float x) { return log10f(x); }
SCALAR_FUN_ATTR float futrts_log1p_32(float x) { return log1pf(x); }
SCALAR_FUN_ATTR float futrts_sqrt32(float x) { return sqrtf(x); }
SCALAR_FUN_ATTR float futrts_rsqrt32(float x) { return 1/sqrtf(x); }
SCALAR_FUN_ATTR float futrts_cbrt32(float x) { return cbrtf(x); }
SCALAR_FUN_ATTR float futrts_exp32(float x) { return expf(x); }
SCALAR_FUN_ATTR float futrts_cos32(float x) { return cosf(x); }

SCALAR_FUN_ATTR float futrts_cospi32(float x) {
#if defined(__CUDA_ARCH__)
  return cospif(x);
#else
  return cosf(((float)M_PI)*x);
#endif
}
SCALAR_FUN_ATTR float futrts_sin32(float x) { return sinf(x); }

SCALAR_FUN_ATTR float futrts_sinpi32(float x) {
#if defined(__CUDA_ARCH__)
  return sinpif(x);
#else
  return sinf((float)M_PI*x);
#endif
}

SCALAR_FUN_ATTR float futrts_tan32(float x) { return tanf(x); }
SCALAR_FUN_ATTR float futrts_tanpi32(float x) { return tanf((float)M_PI*x); }
SCALAR_FUN_ATTR float futrts_acos32(float x) { return acosf(x); }
SCALAR_FUN_ATTR float futrts_acospi32(float x) { return acosf(x)/(float)M_PI; }
SCALAR_FUN_ATTR float futrts_asin32(float x) { return asinf(x); }
SCALAR_FUN_ATTR float futrts_asinpi32(float x) { return asinf(x)/(float)M_PI; }
SCALAR_FUN_ATTR float futrts_atan32(float x) { return atanf(x); }
SCALAR_FUN_ATTR float futrts_atanpi32(float x) { return atanf(x)/(float)M_PI; }
SCALAR_FUN_ATTR float futrts_cosh32(float x) { return coshf(x); }
SCALAR_FUN_ATTR float futrts_sinh32(float x) { return sinhf(x); }
SCALAR_FUN_ATTR float futrts_tanh32(float x) { return tanhf(x); }
SCALAR_FUN_ATTR float futrts_acosh32(float x) { return acoshf(x); }
SCALAR_FUN_ATTR float futrts_asinh32(float x) { return asinhf(x); }
SCALAR_FUN_ATTR float futrts_atanh32(float x) { return atanhf(x); }
SCALAR_FUN_ATTR float futrts_atan2_32(float x, float y) { return atan2f(x, y); }
SCALAR_FUN_ATTR float futrts_atan2pi_32(float x, float y) { return atan2f(x, y) / (float)M_PI; }
SCALAR_FUN_ATTR float futrts_hypot32(float x, float y) { return hypotf(x, y); }
SCALAR_FUN_ATTR float futrts_gamma32(float x) { return tgammaf(x); }
SCALAR_FUN_ATTR float futrts_lgamma32(float x) { return lgammaf(x); }
SCALAR_FUN_ATTR float futrts_erf32(float x) { return erff(x); }
SCALAR_FUN_ATTR float futrts_erfc32(float x) { return erfcf(x); }
SCALAR_FUN_ATTR float fmod32(float x, float y) { return fmodf(x, y); }
SCALAR_FUN_ATTR float futrts_round32(float x) { return rintf(x); }
SCALAR_FUN_ATTR float futrts_floor32(float x) { return floorf(x); }
SCALAR_FUN_ATTR float futrts_ceil32(float x) { return ceilf(x); }
SCALAR_FUN_ATTR float futrts_nextafter32(float x, float y) { return nextafterf(x, y); }
SCALAR_FUN_ATTR float futrts_lerp32(float v0, float v1, float t) { return v0 + (v1 - v0) * t; }
SCALAR_FUN_ATTR float futrts_ldexp32(float x, int32_t y) { return ldexpf(x, y); }
SCALAR_FUN_ATTR float futrts_copysign32(float x, float y) { return copysignf(x, y); }
SCALAR_FUN_ATTR float futrts_mad32(float a, float b, float c) { return a * b + c; }
SCALAR_FUN_ATTR float futrts_fma32(float a, float b, float c) { return fmaf(a, b, c); }

#endif

#if defined(ISPC)

SCALAR_FUN_ATTR int32_t fptobits_f32_i32(float x) { return intbits(x); }
SCALAR_FUN_ATTR float bitstofp_i32_f32(int32_t x) { return floatbits(x); }
SCALAR_FUN_ATTR uniform int32_t fptobits_f32_i32(uniform float x) { return intbits(x); }
SCALAR_FUN_ATTR uniform float bitstofp_i32_f32(uniform int32_t x) { return floatbits(x); }

#else

SCALAR_FUN_ATTR int32_t fptobits_f32_i32(float x) {
  union {
    float f;
    int32_t t;
  } p;

  p.f = x;
  return p.t;
}

SCALAR_FUN_ATTR float bitstofp_i32_f32(int32_t x) {
  union {
    int32_t f;
    float t;
  } p;

  p.f = x;
  return p.t;
}
#endif

SCALAR_FUN_ATTR float fsignum32(float x) {
  return futrts_isnan32(x) ? x : (x > 0 ? 1 : 0) - (x < 0 ? 1 : 0);
}

#ifdef FUTHARK_F64_ENABLED

SCALAR_FUN_ATTR double bitstofp_i64_f64(int64_t x);
SCALAR_FUN_ATTR int64_t fptobits_f64_i64(double x);

#if defined(ISPC)

SCALAR_FUN_ATTR bool futrts_isinf64(float x) { return !isnan(x) && isnan(x - x); }
SCALAR_FUN_ATTR bool futrts_isfinite64(float x) { return !isnan(x) && !futrts_isinf64(x); }
SCALAR_FUN_ATTR double fdiv64(double x, double y) { return x / y; }
SCALAR_FUN_ATTR double fadd64(double x, double y) { return x + y; }
SCALAR_FUN_ATTR double fsub64(double x, double y) { return x - y; }
SCALAR_FUN_ATTR double fmul64(double x, double y) { return x * y; }
SCALAR_FUN_ATTR bool cmplt64(double x, double y) { return x < y; }
SCALAR_FUN_ATTR bool cmple64(double x, double y) { return x <= y; }
SCALAR_FUN_ATTR double sitofp_i8_f64(int8_t x) { return (double) x; }
SCALAR_FUN_ATTR double sitofp_i16_f64(int16_t x) { return (double) x; }
SCALAR_FUN_ATTR double sitofp_i32_f64(int32_t x) { return (double) x; }
SCALAR_FUN_ATTR double sitofp_i64_f64(int64_t x) { return (double) x; }
SCALAR_FUN_ATTR double uitofp_i8_f64(uint8_t x) { return (double) x; }
SCALAR_FUN_ATTR double uitofp_i16_f64(uint16_t x) { return (double) x; }
SCALAR_FUN_ATTR double uitofp_i32_f64(uint32_t x) { return (double) x; }
SCALAR_FUN_ATTR double uitofp_i64_f64(uint64_t x) { return (double) x; }
SCALAR_FUN_ATTR double fabs64(double x) { return abs(x); }
SCALAR_FUN_ATTR double fmax64(double x, double y) { return isnan(x) ? y : isnan(y) ? x : max(x, y); }
SCALAR_FUN_ATTR double fmin64(double x, double y) { return isnan(x) ? y : isnan(y) ? x : min(x, y); }

SCALAR_FUN_ATTR double fpow64(double a, double b) {
  float ret;
  foreach_active (i) {
      uniform float r = pow(extract(a, i), extract(b, i));
      ret = insert(ret, i, r);
  }
  return ret;
}
SCALAR_FUN_ATTR double futrts_log64(double x) { return futrts_isfinite64(x) || (futrts_isinf64(x) && x < 0)? log(x) : x; }
SCALAR_FUN_ATTR double futrts_log2_64(double x) { return futrts_log64(x)/log(2.0d); }
SCALAR_FUN_ATTR double futrts_log10_64(double x) { return futrts_log64(x)/log(10.0d); }

SCALAR_FUN_ATTR double futrts_log1p_64(double x) {
  if(x == -1.0d || (futrts_isinf64(x) && x > 0.0d)) return x / 0.0d;
  double y = 1.0d + x;
  double z = y - 1.0d;
  return log(y) - (z-x)/y;
}

SCALAR_FUN_ATTR double futrts_sqrt64(double x) { return sqrt(x); }
SCALAR_FUN_ATTR double futrts_rsqrt64(double x) { return 1/sqrt(x); }

SCALAR_FUN_ATTR double futrts_cbrt64(double x) {
  double res;
  foreach_active (i) {
    uniform double r = cbrtf(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}
SCALAR_FUN_ATTR double futrts_exp64(double x) { return exp(x); }
SCALAR_FUN_ATTR double futrts_cos64(double x) { return cos(x); }
SCALAR_FUN_ATTR double futrts_cospi64(double x) { return cos(M_PI*x); }
SCALAR_FUN_ATTR double futrts_sin64(double x) { return sin(x); }
SCALAR_FUN_ATTR double futrts_sinpi64(double x) { return sin(M_PI*x); }
SCALAR_FUN_ATTR double futrts_tan64(double x) { return tan(x); }
SCALAR_FUN_ATTR double futrts_tanpi64(double x) { return tan(M_PI*x); }
SCALAR_FUN_ATTR double futrts_acos64(double x) { return acos(x); }
SCALAR_FUN_ATTR double futrts_acospi64(double x) { return acos(x)/M_PI; }
SCALAR_FUN_ATTR double futrts_asin64(double x) { return asin(x); }
SCALAR_FUN_ATTR double futrts_asinpi64(double x) { return asin(x)/M_PI; }
SCALAR_FUN_ATTR double futrts_atan64(double x) { return atan(x); }
SCALAR_FUN_ATTR double futrts_atanpi64(double x) { return atan(x)/M_PI; }
SCALAR_FUN_ATTR double futrts_cosh64(double x) { return (exp(x)+exp(-x)) / 2.0d; }
SCALAR_FUN_ATTR double futrts_sinh64(double x) { return (exp(x)-exp(-x)) / 2.0d; }
SCALAR_FUN_ATTR double futrts_tanh64(double x) { return futrts_sinh64(x)/futrts_cosh64(x); }

SCALAR_FUN_ATTR double futrts_acosh64(double x) {
  double f = x+sqrt(x*x-1.0d);
  if(futrts_isfinite64(f)) return log(f);
  return f;
}

SCALAR_FUN_ATTR double futrts_asinh64(double x) {
  double f = x+sqrt(x*x+1.0d);
  if(futrts_isfinite64(f)) return log(f);
  return f;
}

SCALAR_FUN_ATTR double futrts_atanh64(double x) {
  double f = (1.0d+x)/(1.0d-x);
  if(futrts_isfinite64(f)) return log(f)/2.0d;
  return f;
}
SCALAR_FUN_ATTR double futrts_atan2_64(double x, double y) { return atan2(x, y); }

SCALAR_FUN_ATTR double futrts_atan2pi_64(double x, double y) { return atan2(x, y) / M_PI; }

extern "C" unmasked uniform double hypot(uniform double x, uniform double y);
SCALAR_FUN_ATTR double futrts_hypot64(double x, double y) {
  double res;
  foreach_active (i) {
    uniform double r = hypot(extract(x, i), extract(y, i));
    res = insert(res, i, r);
  }
  return res;
}

extern "C" unmasked uniform double tgamma(uniform double x);
SCALAR_FUN_ATTR double futrts_gamma64(double x) {
  double res;
  foreach_active (i) {
    uniform double r = tgamma(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

extern "C" unmasked uniform double lgamma(uniform double x);
SCALAR_FUN_ATTR double futrts_lgamma64(double x) {
  double res;
  foreach_active (i) {
    uniform double r = lgamma(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

extern "C" unmasked uniform double erf(uniform double x);
SCALAR_FUN_ATTR double futrts_erf64(double x) {
  double res;
  foreach_active (i) {
    uniform double r = erf(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

extern "C" unmasked uniform double erfc(uniform double x);
SCALAR_FUN_ATTR double futrts_erfc64(double x) {
  double res;
  foreach_active (i) {
    uniform double r = erfc(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

SCALAR_FUN_ATTR double futrts_fma64(double a, double b, double c) { return a * b + c; }
SCALAR_FUN_ATTR double futrts_round64(double x) { return round(x); }
SCALAR_FUN_ATTR double futrts_ceil64(double x) { return ceil(x); }

extern "C" unmasked uniform double nextafter(uniform float x, uniform double y);
SCALAR_FUN_ATTR float futrts_nextafter64(double x, double y) {
  double res;
  foreach_active (i) {
    uniform double r = nextafter(extract(x, i), extract(y, i));
    res = insert(res, i, r);
  }
  return res;
}

SCALAR_FUN_ATTR double futrts_floor64(double x) { return floor(x); }
SCALAR_FUN_ATTR bool futrts_isnan64(double x) { return isnan(x); }

SCALAR_FUN_ATTR int8_t fptosi_f64_i8(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int8_t) x;
  }
}

SCALAR_FUN_ATTR int16_t fptosi_f64_i16(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int16_t) x;
  }
}

SCALAR_FUN_ATTR int32_t fptosi_f64_i32(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int32_t) x;
  }
}

SCALAR_FUN_ATTR int64_t fptosi_f64_i64(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int64_t) x;
  }
}

SCALAR_FUN_ATTR uint8_t fptoui_f64_i8(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint8_t) (int8_t) x;
  }
}

SCALAR_FUN_ATTR uint16_t fptoui_f64_i16(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint16_t) (int16_t) x;
  }
}

SCALAR_FUN_ATTR uint32_t fptoui_f64_i32(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint32_t) (int32_t) x;
  }
}

SCALAR_FUN_ATTR uint64_t fptoui_f64_i64(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint64_t) (int64_t) x;
  }
}

SCALAR_FUN_ATTR bool ftob_f64_bool(double x) { return x != 0.0; }
SCALAR_FUN_ATTR double btof_bool_f64(bool x) { return x ? 1.0 : 0.0; }

SCALAR_FUN_ATTR int64_t fptobits_f64_i64(double x) {
  int64_t res;
  foreach_active (i) {
    uniform double tmp = extract(x, i);
    uniform int64_t r = *((uniform int64_t* uniform)&tmp);
    res = insert(res, i, r);
  }
  return res;
}

SCALAR_FUN_ATTR double bitstofp_i64_f64(int64_t x) {
  double res;
  foreach_active (i) {
    uniform int64_t tmp = extract(x, i);
    uniform double r = *((uniform double* uniform)&tmp);
    res = insert(res, i, r);
  }
  return res;
}

SCALAR_FUN_ATTR uniform int64_t fptobits_f64_i64(uniform double x) {
  return intbits(x);
}

SCALAR_FUN_ATTR uniform double bitstofp_i64_f64(uniform int64_t x) {
  return doublebits(x);
}

SCALAR_FUN_ATTR double fmod64(double x, double y) {
  return x - y * trunc(x/y);
}

SCALAR_FUN_ATTR double fsignum64(double x) {
  return futrts_isnan64(x) ? x : (x > 0 ? 1.0d : 0.0d) - (x < 0 ? 1.0d : 0.0d);
}

SCALAR_FUN_ATTR double futrts_lerp64(double v0, double v1, double t) {
  return v0 + (v1 - v0) * t;
}

SCALAR_FUN_ATTR double futrts_ldexp64(double x, int32_t y) {
  return x * pow((uniform double)2.0, (double)y);
}

SCALAR_FUN_ATTR double futrts_copysign64(double x, double y) {
  int64_t xb = fptobits_f64_i64(x);
  int64_t yb = fptobits_f64_i64(y);
  return bitstofp_i64_f64((xb & ~(((int64_t)1)<<63)) | (yb & (((int64_t)1)<<63)));
}

SCALAR_FUN_ATTR double futrts_mad64(double a, double b, double c) { return a * b + c; }
SCALAR_FUN_ATTR float fpconv_f32_f32(float x) { return (float) x; }
SCALAR_FUN_ATTR double fpconv_f32_f64(float x) { return (double) x; }
SCALAR_FUN_ATTR float fpconv_f64_f32(double x) { return (float) x; }
SCALAR_FUN_ATTR double fpconv_f64_f64(double x) { return (double) x; }

#else

SCALAR_FUN_ATTR double fdiv64(double x, double y) { return x / y; }
SCALAR_FUN_ATTR double fadd64(double x, double y) { return x + y; }
SCALAR_FUN_ATTR double fsub64(double x, double y) { return x - y; }
SCALAR_FUN_ATTR double fmul64(double x, double y) { return x * y; }
SCALAR_FUN_ATTR bool cmplt64(double x, double y) { return x < y; }
SCALAR_FUN_ATTR bool cmple64(double x, double y) { return x <= y; }
SCALAR_FUN_ATTR double sitofp_i8_f64(int8_t x) { return (double) x; }
SCALAR_FUN_ATTR double sitofp_i16_f64(int16_t x) { return (double) x; }
SCALAR_FUN_ATTR double sitofp_i32_f64(int32_t x) { return (double) x; }
SCALAR_FUN_ATTR double sitofp_i64_f64(int64_t x) { return (double) x; }
SCALAR_FUN_ATTR double uitofp_i8_f64(uint8_t x) { return (double) x; }
SCALAR_FUN_ATTR double uitofp_i16_f64(uint16_t x) { return (double) x; }
SCALAR_FUN_ATTR double uitofp_i32_f64(uint32_t x) { return (double) x; }
SCALAR_FUN_ATTR double uitofp_i64_f64(uint64_t x) { return (double) x; }
SCALAR_FUN_ATTR double fabs64(double x) { return fabs(x); }
SCALAR_FUN_ATTR double fmax64(double x, double y) { return fmax(x, y); }
SCALAR_FUN_ATTR double fmin64(double x, double y) { return fmin(x, y); }
SCALAR_FUN_ATTR double fpow64(double x, double y) { return pow(x, y); }
SCALAR_FUN_ATTR double futrts_log64(double x) { return log(x); }
SCALAR_FUN_ATTR double futrts_log2_64(double x) { return log2(x); }
SCALAR_FUN_ATTR double futrts_log10_64(double x) { return log10(x); }
SCALAR_FUN_ATTR double futrts_log1p_64(double x) { return log1p(x); }
SCALAR_FUN_ATTR double futrts_sqrt64(double x) { return sqrt(x); }
SCALAR_FUN_ATTR double futrts_rsqrt64(double x) { return 1/sqrt(x); }
SCALAR_FUN_ATTR double futrts_cbrt64(double x) { return cbrt(x); }
SCALAR_FUN_ATTR double futrts_exp64(double x) { return exp(x); }
SCALAR_FUN_ATTR double futrts_cos64(double x) { return cos(x); }

SCALAR_FUN_ATTR double futrts_cospi64(double x) {
#ifdef __OPENCL_VERSION__
  return cospi(x);
#elif defined(__CUDA_ARCH__)
  return cospi(x);
#else
  return cos(M_PI*x);
#endif
}

SCALAR_FUN_ATTR double futrts_sin64(double x) {
  return sin(x);
}

SCALAR_FUN_ATTR double futrts_sinpi64(double x) {
#ifdef __OPENCL_VERSION__
  return sinpi(x);
#elif defined(__CUDA_ARCH__)
  return sinpi(x);
#else
  return sin(M_PI*x);
#endif
}

SCALAR_FUN_ATTR double futrts_tan64(double x) {
  return tan(x);
}

SCALAR_FUN_ATTR double futrts_tanpi64(double x) {
#ifdef __OPENCL_VERSION__
  return tanpi(x);
#else
  return tan(M_PI*x);
#endif
}

SCALAR_FUN_ATTR double futrts_acos64(double x) {
  return acos(x);
}

SCALAR_FUN_ATTR double futrts_acospi64(double x) {
#ifdef __OPENCL_VERSION__
  return acospi(x);
#else
  return acos(x) / M_PI;
#endif
}

SCALAR_FUN_ATTR double futrts_asin64(double x) {
  return asin(x);
}

SCALAR_FUN_ATTR double futrts_asinpi64(double x) {
#ifdef __OPENCL_VERSION__
  return asinpi(x);
#else
  return asin(x) / M_PI;
#endif
}

SCALAR_FUN_ATTR double futrts_atan64(double x) {
  return atan(x);
}

SCALAR_FUN_ATTR double futrts_atanpi64(double x) {
#ifdef __OPENCL_VERSION__
  return atanpi(x);
#else
  return atan(x) / M_PI;
#endif
}

SCALAR_FUN_ATTR double futrts_cosh64(double x) { return cosh(x); }
SCALAR_FUN_ATTR double futrts_sinh64(double x) { return sinh(x); }
SCALAR_FUN_ATTR double futrts_tanh64(double x) { return tanh(x); }
SCALAR_FUN_ATTR double futrts_acosh64(double x) { return acosh(x); }
SCALAR_FUN_ATTR double futrts_asinh64(double x) { return asinh(x); }
SCALAR_FUN_ATTR double futrts_atanh64(double x) { return atanh(x); }
SCALAR_FUN_ATTR double futrts_atan2_64(double x, double y) { return atan2(x, y); }

SCALAR_FUN_ATTR double futrts_atan2pi_64(double x, double y) {
#ifdef __OPENCL_VERSION__
  return atan2pi(x, y);
#else
  return atan2(x, y) / M_PI;
#endif
}

SCALAR_FUN_ATTR double futrts_hypot64(double x, double y) { return hypot(x, y); }
SCALAR_FUN_ATTR double futrts_gamma64(double x) { return tgamma(x); }
SCALAR_FUN_ATTR double futrts_lgamma64(double x) { return lgamma(x); }
SCALAR_FUN_ATTR double futrts_erf64(double x) { return erf(x); }
SCALAR_FUN_ATTR double futrts_erfc64(double x) { return erfc(x); }
SCALAR_FUN_ATTR double futrts_fma64(double a, double b, double c) { return fma(a, b, c); }
SCALAR_FUN_ATTR double futrts_round64(double x) { return rint(x); }
SCALAR_FUN_ATTR double futrts_ceil64(double x) { return ceil(x); }
SCALAR_FUN_ATTR float futrts_nextafter64(float x, float y) { return nextafter(x, y); }
SCALAR_FUN_ATTR double futrts_floor64(double x) { return floor(x); }
SCALAR_FUN_ATTR bool futrts_isnan64(double x) { return isnan(x); }
SCALAR_FUN_ATTR bool futrts_isinf64(double x) { return isinf(x); }

SCALAR_FUN_ATTR int8_t fptosi_f64_i8(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int8_t) x;
  }
}

SCALAR_FUN_ATTR int16_t fptosi_f64_i16(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int16_t) x;
  }
}

SCALAR_FUN_ATTR int32_t fptosi_f64_i32(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int32_t) x;
  }
}

SCALAR_FUN_ATTR int64_t fptosi_f64_i64(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int64_t) x;
  }
}

SCALAR_FUN_ATTR uint8_t fptoui_f64_i8(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint8_t) (int8_t) x;
  }
}

SCALAR_FUN_ATTR uint16_t fptoui_f64_i16(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint16_t) (int16_t) x;
  }
}

SCALAR_FUN_ATTR uint32_t fptoui_f64_i32(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint32_t) (int32_t) x;
  }
}

SCALAR_FUN_ATTR uint64_t fptoui_f64_i64(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint64_t) (int64_t) x;
  }
}

SCALAR_FUN_ATTR bool ftob_f64_bool(double x) { return x != 0; }
SCALAR_FUN_ATTR double btof_bool_f64(bool x) { return x ? 1 : 0; }

SCALAR_FUN_ATTR int64_t fptobits_f64_i64(double x) {
  union {
    double f;
    int64_t t;
  } p;

  p.f = x;
  return p.t;
}

SCALAR_FUN_ATTR double bitstofp_i64_f64(int64_t x) {
  union {
    int64_t f;
    double t;
  } p;

  p.f = x;
  return p.t;
}

SCALAR_FUN_ATTR double fmod64(double x, double y) {
  return fmod(x, y);
}

SCALAR_FUN_ATTR double fsignum64(double x) {
  return futrts_isnan64(x) ? x : (x > 0) - (x < 0);
}

SCALAR_FUN_ATTR double futrts_lerp64(double v0, double v1, double t) {
#ifdef __OPENCL_VERSION__
  return mix(v0, v1, t);
#else
  return v0 + (v1 - v0) * t;
#endif
}

SCALAR_FUN_ATTR double futrts_ldexp64(double x, int32_t y) {
  return ldexp(x, y);
}

SCALAR_FUN_ATTR float futrts_copysign64(double x, double y) {
  return copysign(x, y);
}

SCALAR_FUN_ATTR double futrts_mad64(double a, double b, double c) {
#ifdef __OPENCL_VERSION__
  return mad(a, b, c);
#else
  return a * b + c;
#endif
}

SCALAR_FUN_ATTR float fpconv_f32_f32(float x) { return (float) x; }
SCALAR_FUN_ATTR double fpconv_f32_f64(float x) { return (double) x; }
SCALAR_FUN_ATTR float fpconv_f64_f32(double x) { return (float) x; }
SCALAR_FUN_ATTR double fpconv_f64_f64(double x) { return (double) x; }

#endif

#endif

#define futrts_cond_f16(x,y,z) ((x) ? (y) : (z))
#define futrts_cond_f32(x,y,z) ((x) ? (y) : (z))
#define futrts_cond_f64(x,y,z) ((x) ? (y) : (z))

#define futrts_cond_i8(x,y,z) ((x) ? (y) : (z))
#define futrts_cond_i16(x,y,z) ((x) ? (y) : (z))
#define futrts_cond_i32(x,y,z) ((x) ? (y) : (z))
#define futrts_cond_i64(x,y,z) ((x) ? (y) : (z))

#define futrts_cond_bool(x,y,z) ((x) ? (y) : (z))
#define futrts_cond_unit(x,y,z) ((x) ? (y) : (z))

// End of scalar.h.
// Start of scalar_f16.h.

// Half-precision is emulated if needed (e.g. in straight C) with the
// native type used if possible.  The emulation works by typedef'ing
// 'float' to 'f16', and then implementing all operations on single
// precision.  To cut down on duplication, we use the same code for
// those Futhark functions that require just operators or casts.  The
// in-memory representation for arrays will still be 16 bits even
// under emulation, so the compiler will have to be careful when
// generating reads or writes.

#if !defined(cl_khr_fp16) && !(defined(__CUDA_ARCH__) && __CUDA_ARCH__ >= 600) && !(defined(ISPC))
#define EMULATE_F16
#endif

#if !defined(EMULATE_F16) && defined(__OPENCL_VERSION__)
#pragma OPENCL EXTENSION cl_khr_fp16 : enable
#endif

#ifdef EMULATE_F16

// Note that the half-precision storage format is still 16 bits - the
// compiler will have to be real careful!
typedef float f16;

#elif defined(ISPC)
typedef float16 f16;

#else

#ifdef __CUDA_ARCH__
#include <cuda_fp16.h>
#endif

typedef half f16;

#endif

// Some of these functions convert to single precision because half
// precision versions are not available.
SCALAR_FUN_ATTR f16 fadd16(f16 x, f16 y) { return x + y; }
SCALAR_FUN_ATTR f16 fsub16(f16 x, f16 y) { return x - y; }
SCALAR_FUN_ATTR f16 fmul16(f16 x, f16 y) { return x * y; }
SCALAR_FUN_ATTR bool cmplt16(f16 x, f16 y) { return x < y; }
SCALAR_FUN_ATTR bool cmple16(f16 x, f16 y) { return x <= y; }
SCALAR_FUN_ATTR f16 sitofp_i8_f16(int8_t x) { return (f16) x; }
SCALAR_FUN_ATTR f16 sitofp_i16_f16(int16_t x) { return (f16) x; }
SCALAR_FUN_ATTR f16 sitofp_i32_f16(int32_t x) { return (f16) x; }
SCALAR_FUN_ATTR f16 sitofp_i64_f16(int64_t x) { return (f16) x; }
SCALAR_FUN_ATTR f16 uitofp_i8_f16(uint8_t x) { return (f16) x; }
SCALAR_FUN_ATTR f16 uitofp_i16_f16(uint16_t x) { return (f16) x; }
SCALAR_FUN_ATTR f16 uitofp_i32_f16(uint32_t x) { return (f16) x; }
SCALAR_FUN_ATTR f16 uitofp_i64_f16(uint64_t x) { return (f16) x; }
SCALAR_FUN_ATTR int8_t fptosi_f16_i8(f16 x) { return (int8_t) (float) x; }
SCALAR_FUN_ATTR int16_t fptosi_f16_i16(f16 x) { return (int16_t) x; }
SCALAR_FUN_ATTR int32_t fptosi_f16_i32(f16 x) { return (int32_t) x; }
SCALAR_FUN_ATTR int64_t fptosi_f16_i64(f16 x) { return (int64_t) x; }
SCALAR_FUN_ATTR uint8_t fptoui_f16_i8(f16 x) { return (uint8_t) (float) x; }
SCALAR_FUN_ATTR uint16_t fptoui_f16_i16(f16 x) { return (uint16_t) x; }
SCALAR_FUN_ATTR uint32_t fptoui_f16_i32(f16 x) { return (uint32_t) x; }
SCALAR_FUN_ATTR uint64_t fptoui_f16_i64(f16 x) { return (uint64_t) x; }
SCALAR_FUN_ATTR bool ftob_f16_bool(f16 x) { return x != (f16)0; }
SCALAR_FUN_ATTR f16 btof_bool_f16(bool x) { return x ? 1 : 0; }

#ifndef EMULATE_F16

SCALAR_FUN_ATTR bool futrts_isnan16(f16 x) { return isnan((float)x); }

#ifdef __OPENCL_VERSION__

SCALAR_FUN_ATTR f16 fabs16(f16 x) { return fabs(x); }
SCALAR_FUN_ATTR f16 fmax16(f16 x, f16 y) { return fmax(x, y); }
SCALAR_FUN_ATTR f16 fmin16(f16 x, f16 y) { return fmin(x, y); }
SCALAR_FUN_ATTR f16 fpow16(f16 x, f16 y) { return pow(x, y); }

#elif defined(ISPC)

SCALAR_FUN_ATTR f16 fabs16(f16 x) { return abs(x); }
SCALAR_FUN_ATTR f16 fmax16(f16 x, f16 y) { return futrts_isnan16(x) ? y : futrts_isnan16(y) ? x : max(x, y); }
SCALAR_FUN_ATTR f16 fmin16(f16 x, f16 y) { return futrts_isnan16(x) ? y : futrts_isnan16(y) ? x : min(x, y); }
SCALAR_FUN_ATTR f16 fpow16(f16 x, f16 y) { return pow(x, y); }

#else // Assuming CUDA.

SCALAR_FUN_ATTR f16 fabs16(f16 x) { return fabsf(x); }
SCALAR_FUN_ATTR f16 fmax16(f16 x, f16 y) { return fmaxf(x, y); }
SCALAR_FUN_ATTR f16 fmin16(f16 x, f16 y) { return fminf(x, y); }
SCALAR_FUN_ATTR f16 fpow16(f16 x, f16 y) { return powf(x, y); }

#endif

#if defined(ISPC)
SCALAR_FUN_ATTR bool futrts_isinf16(float x) { return !futrts_isnan16(x) && futrts_isnan16(x - x); }
SCALAR_FUN_ATTR bool futrts_isfinite16(float x) { return !futrts_isnan16(x) && !futrts_isinf16(x); }
#else
SCALAR_FUN_ATTR bool futrts_isinf16(f16 x) { return isinf((float)x); }
#endif

#ifdef __OPENCL_VERSION__
SCALAR_FUN_ATTR f16 futrts_log16(f16 x) { return log(x); }
SCALAR_FUN_ATTR f16 futrts_log2_16(f16 x) { return log2(x); }
SCALAR_FUN_ATTR f16 futrts_log10_16(f16 x) { return log10(x); }
SCALAR_FUN_ATTR f16 futrts_log1p_16(f16 x) { return log1p(x); }
SCALAR_FUN_ATTR f16 futrts_sqrt16(f16 x) { return sqrt(x); }
SCALAR_FUN_ATTR f16 futrts_rsqrt16(f16 x) { return rsqrt(x); }
SCALAR_FUN_ATTR f16 futrts_cbrt16(f16 x) { return cbrt(x); }
SCALAR_FUN_ATTR f16 futrts_exp16(f16 x) { return exp(x); }
SCALAR_FUN_ATTR f16 futrts_cos16(f16 x) { return cos(x); }
SCALAR_FUN_ATTR f16 futrts_cospi16(f16 x) { return cospi(x); }
SCALAR_FUN_ATTR f16 futrts_sin16(f16 x) { return sin(x); }
SCALAR_FUN_ATTR f16 futrts_sinpi16(f16 x) { return sinpi(x); }
SCALAR_FUN_ATTR f16 futrts_tan16(f16 x) { return tan(x); }
SCALAR_FUN_ATTR f16 futrts_tanpi16(f16 x) { return tanpi(x); }
SCALAR_FUN_ATTR f16 futrts_acos16(f16 x) { return acos(x); }
SCALAR_FUN_ATTR f16 futrts_acospi16(f16 x) { return acospi(x); }
SCALAR_FUN_ATTR f16 futrts_asin16(f16 x) { return asin(x); }
SCALAR_FUN_ATTR f16 futrts_asinpi16(f16 x) { return asinpi(x); }
SCALAR_FUN_ATTR f16 futrts_atan16(f16 x) { return atan(x); }
SCALAR_FUN_ATTR f16 futrts_atanpi16(f16 x) { return atanpi(x); }
SCALAR_FUN_ATTR f16 futrts_cosh16(f16 x) { return cosh(x); }
SCALAR_FUN_ATTR f16 futrts_sinh16(f16 x) { return sinh(x); }
SCALAR_FUN_ATTR f16 futrts_tanh16(f16 x) { return tanh(x); }
SCALAR_FUN_ATTR f16 futrts_acosh16(f16 x) { return acosh(x); }
SCALAR_FUN_ATTR f16 futrts_asinh16(f16 x) { return asinh(x); }
SCALAR_FUN_ATTR f16 futrts_atanh16(f16 x) { return atanh(x); }
SCALAR_FUN_ATTR f16 futrts_atan2_16(f16 x, f16 y) { return atan2(x, y); }
SCALAR_FUN_ATTR f16 futrts_atan2pi_16(f16 x, f16 y) { return atan2pi(x, y); }
SCALAR_FUN_ATTR f16 futrts_hypot16(f16 x, f16 y) { return hypot(x, y); }
SCALAR_FUN_ATTR f16 futrts_gamma16(f16 x) { return tgamma(x); }
SCALAR_FUN_ATTR f16 futrts_lgamma16(f16 x) { return lgamma(x); }
SCALAR_FUN_ATTR f16 futrts_erf16(f16 x) { return erf(x); }
SCALAR_FUN_ATTR f16 futrts_erfc16(f16 x) { return erfc(x); }
SCALAR_FUN_ATTR f16 fmod16(f16 x, f16 y) { return fmod(x, y); }
SCALAR_FUN_ATTR f16 futrts_round16(f16 x) { return rint(x); }
SCALAR_FUN_ATTR f16 futrts_floor16(f16 x) { return floor(x); }
SCALAR_FUN_ATTR f16 futrts_ceil16(f16 x) { return ceil(x); }
SCALAR_FUN_ATTR f16 futrts_nextafter16(f16 x, f16 y) { return nextafter(x, y); }
SCALAR_FUN_ATTR f16 futrts_lerp16(f16 v0, f16 v1, f16 t) { return mix(v0, v1, t); }
SCALAR_FUN_ATTR f16 futrts_ldexp16(f16 x, int32_t y) { return ldexp(x, y); }
SCALAR_FUN_ATTR f16 futrts_copysign16(f16 x, f16 y) { return copysign(x, y); }
SCALAR_FUN_ATTR f16 futrts_mad16(f16 a, f16 b, f16 c) { return mad(a, b, c); }
SCALAR_FUN_ATTR f16 futrts_fma16(f16 a, f16 b, f16 c) { return fma(a, b, c); }

#elif defined(ISPC)

SCALAR_FUN_ATTR f16 futrts_log16(f16 x) { return futrts_isfinite16(x) || (futrts_isinf16(x) && x < 0) ? log(x) : x; }
SCALAR_FUN_ATTR f16 futrts_log2_16(f16 x) { return futrts_log16(x) / log(2.0f16); }
SCALAR_FUN_ATTR f16 futrts_log10_16(f16 x) { return futrts_log16(x) / log(10.0f16); }
SCALAR_FUN_ATTR f16 futrts_log1p_16(f16 x) {
  if(x == -1.0f16 || (futrts_isinf16(x) && x > 0.0f16)) return x / 0.0f16;
  f16 y = 1.0f16 + x;
  f16 z = y - 1.0f16;
  return log(y) - (z-x)/y;
}
SCALAR_FUN_ATTR f16 futrts_sqrt16(f16 x) { return (float16)sqrt((float)x); }
SCALAR_FUN_ATTR f16 futrts_rsqrt16(f16 x) { return (float16)1/sqrt((float)x); }
SCALAR_FUN_ATTR f16 futrts_exp16(f16 x) { return exp(x); }
SCALAR_FUN_ATTR f16 futrts_cos16(f16 x) { return (float16)cos((float)x); }
SCALAR_FUN_ATTR f16 futrts_cospi16(f16 x) { return (float16)cos((float)M_PI*(float)x); }
SCALAR_FUN_ATTR f16 futrts_sin16(f16 x) { return (float16)sin((float)x); }
SCALAR_FUN_ATTR f16 futrts_sinpi16(f16 x) { return (float16)sin((float)M_PI*(float)x); }
SCALAR_FUN_ATTR f16 futrts_tan16(f16 x) { return (float16)tan((float)x); }
SCALAR_FUN_ATTR f16 futrts_tanpi16(f16 x) { return (float16)(tan((float)M_PI*(float)x)); }
SCALAR_FUN_ATTR f16 futrts_acos16(f16 x) { return (float16)acos((float)x); }
SCALAR_FUN_ATTR f16 futrts_acospi16(f16 x) { return (float16)(acos((float)x)/(float)M_PI); }
SCALAR_FUN_ATTR f16 futrts_asin16(f16 x) { return (float16)asin((float)x); }
SCALAR_FUN_ATTR f16 futrts_asinpi16(f16 x) { return (float16)(asin((float)x)/(float)M_PI); }
SCALAR_FUN_ATTR f16 futrts_atan16(f16 x) { return (float16)atan((float)x); }
SCALAR_FUN_ATTR f16 futrts_atanpi16(f16 x) { return (float16)(atan((float)x)/(float)M_PI); }
SCALAR_FUN_ATTR f16 futrts_cosh16(f16 x) { return (exp(x)+exp(-x)) / 2.0f16; }
SCALAR_FUN_ATTR f16 futrts_sinh16(f16 x) { return (exp(x)-exp(-x)) / 2.0f16; }
SCALAR_FUN_ATTR f16 futrts_tanh16(f16 x) { return futrts_sinh16(x)/futrts_cosh16(x); }
SCALAR_FUN_ATTR f16 futrts_acosh16(f16 x) {
  float16 f = x+(float16)sqrt((float)(x*x-1));
  if(futrts_isfinite16(f)) return log(f);
  return f;
}
SCALAR_FUN_ATTR f16 futrts_asinh16(f16 x) {
  float16 f = x+(float16)sqrt((float)(x*x+1));
  if(futrts_isfinite16(f)) return log(f);
  return f;
}
SCALAR_FUN_ATTR f16 futrts_atanh16(f16 x) {
  float16 f = (1+x)/(1-x);
  if(futrts_isfinite16(f)) return log(f)/2.0f16;
  return f;
}
SCALAR_FUN_ATTR f16 futrts_atan2_16(f16 x, f16 y) { return (float16)atan2((float)x, (float)y); }
SCALAR_FUN_ATTR f16 futrts_atan2pi_16(f16 x, f16 y) { return (float16)(atan2((float)x, (float)y)/(float)M_PI); }
SCALAR_FUN_ATTR f16 futrts_hypot16(f16 x, f16 y) { return (float16)futrts_hypot32((float)x, (float)y); }

extern "C" unmasked uniform float tgammaf(uniform float x);
SCALAR_FUN_ATTR f16 futrts_gamma16(f16 x) {
  f16 res;
  foreach_active (i) {
    uniform f16 r = (f16)tgammaf(extract((float)x, i));
    res = insert(res, i, r);
  }
  return res;
}

extern "C" unmasked uniform float lgammaf(uniform float x);
SCALAR_FUN_ATTR f16 futrts_lgamma16(f16 x) {
  f16 res;
  foreach_active (i) {
    uniform f16 r = (f16)lgammaf(extract((float)x, i));
    res = insert(res, i, r);
  }
  return res;
}
SCALAR_FUN_ATTR f16 futrts_cbrt16(f16 x) { return (f16)futrts_cbrt32((float)x); }
SCALAR_FUN_ATTR f16 futrts_erf16(f16 x) { return (f16)futrts_erf32((float)x); }
SCALAR_FUN_ATTR f16 futrts_erfc16(f16 x) { return (f16)futrts_erfc32((float)x); }
SCALAR_FUN_ATTR f16 fmod16(f16 x, f16 y) { return x - y * (float16)trunc((float) (x/y)); }
SCALAR_FUN_ATTR f16 futrts_round16(f16 x) { return (float16)round((float)x); }
SCALAR_FUN_ATTR f16 futrts_floor16(f16 x) { return (float16)floor((float)x); }
SCALAR_FUN_ATTR f16 futrts_ceil16(f16 x) { return (float16)ceil((float)x); }
SCALAR_FUN_ATTR f16 futrts_nextafter16(f16 x, f16 y) { return (float16)futrts_nextafter32((float)x, (float) y); }
SCALAR_FUN_ATTR f16 futrts_lerp16(f16 v0, f16 v1, f16 t) { return v0 + (v1 - v0) * t; }
SCALAR_FUN_ATTR f16 futrts_ldexp16(f16 x, int32_t y) { return futrts_ldexp32((float)x, y); }
SCALAR_FUN_ATTR f16 futrts_copysign16(f16 x, f16 y) { return futrts_copysign32((float)x, y); }
SCALAR_FUN_ATTR f16 futrts_mad16(f16 a, f16 b, f16 c) { return a * b + c; }
SCALAR_FUN_ATTR f16 futrts_fma16(f16 a, f16 b, f16 c) { return a * b + c; }

#else // Assume CUDA.

SCALAR_FUN_ATTR f16 futrts_log16(f16 x) { return hlog(x); }
SCALAR_FUN_ATTR f16 futrts_log2_16(f16 x) { return hlog2(x); }
SCALAR_FUN_ATTR f16 futrts_log10_16(f16 x) { return hlog10(x); }
SCALAR_FUN_ATTR f16 futrts_log1p_16(f16 x) { return (f16)log1pf((float)x); }
SCALAR_FUN_ATTR f16 futrts_sqrt16(f16 x) { return hsqrt(x); }
SCALAR_FUN_ATTR f16 futrts_rsqrt16(f16 x) { return hrsqrt(x); }
SCALAR_FUN_ATTR f16 futrts_cbrt16(f16 x) { return cbrtf(x); }
SCALAR_FUN_ATTR f16 futrts_exp16(f16 x) { return hexp(x); }
SCALAR_FUN_ATTR f16 futrts_cos16(f16 x) { return hcos(x); }
SCALAR_FUN_ATTR f16 futrts_cospi16(f16 x) { return hcos((f16)M_PI*x); }
SCALAR_FUN_ATTR f16 futrts_sin16(f16 x) { return hsin(x); }
SCALAR_FUN_ATTR f16 futrts_sinpi16(f16 x) { return hsin((f16)M_PI*x); }
SCALAR_FUN_ATTR f16 futrts_tan16(f16 x) { return tanf(x); }
SCALAR_FUN_ATTR f16 futrts_tanpi16(f16 x) { return tanf((f16)M_PI*x); }
SCALAR_FUN_ATTR f16 futrts_acos16(f16 x) { return acosf(x); }
SCALAR_FUN_ATTR f16 futrts_acospi16(f16 x) { return (f16)acosf(x)/(f16)M_PI; }
SCALAR_FUN_ATTR f16 futrts_asin16(f16 x) { return asinf(x); }
SCALAR_FUN_ATTR f16 futrts_asinpi16(f16 x) { return (f16)asinf(x)/(f16)M_PI; }
SCALAR_FUN_ATTR f16 futrts_atan16(f16 x) { return (f16)atanf(x); }
SCALAR_FUN_ATTR f16 futrts_atanpi16(f16 x) { return (f16)atanf(x)/(f16)M_PI; }
SCALAR_FUN_ATTR f16 futrts_cosh16(f16 x) { return coshf(x); }
SCALAR_FUN_ATTR f16 futrts_sinh16(f16 x) { return sinhf(x); }
SCALAR_FUN_ATTR f16 futrts_tanh16(f16 x) { return tanhf(x); }
SCALAR_FUN_ATTR f16 futrts_acosh16(f16 x) { return acoshf(x); }
SCALAR_FUN_ATTR f16 futrts_asinh16(f16 x) { return asinhf(x); }
SCALAR_FUN_ATTR f16 futrts_atanh16(f16 x) { return atanhf(x); }
SCALAR_FUN_ATTR f16 futrts_atan2_16(f16 x, f16 y) { return (f16)atan2f(x, y); }
SCALAR_FUN_ATTR f16 futrts_atan2pi_16(f16 x, f16 y) { return (f16)atan2f(x, y)/(f16)M_PI; }
SCALAR_FUN_ATTR f16 futrts_hypot16(f16 x, f16 y) { return hypotf(x, y); }
SCALAR_FUN_ATTR f16 futrts_gamma16(f16 x) { return tgammaf(x); }
SCALAR_FUN_ATTR f16 futrts_lgamma16(f16 x) { return lgammaf(x); }
SCALAR_FUN_ATTR f16 futrts_erf16(f16 x) { return erff(x); }
SCALAR_FUN_ATTR f16 futrts_erfc16(f16 x) { return erfcf(x); }
SCALAR_FUN_ATTR f16 fmod16(f16 x, f16 y) { return fmodf(x, y); }
SCALAR_FUN_ATTR f16 futrts_round16(f16 x) { return rintf(x); }
SCALAR_FUN_ATTR f16 futrts_floor16(f16 x) { return hfloor(x); }
SCALAR_FUN_ATTR f16 futrts_ceil16(f16 x) { return hceil(x); }
SCALAR_FUN_ATTR f16 futrts_nextafter16(f16 x, f16 y) { return __ushort_as_half(halfbitsnextafter(__half_as_ushort(x), __half_as_ushort(y))); }
SCALAR_FUN_ATTR f16 futrts_lerp16(f16 v0, f16 v1, f16 t) { return v0 + (v1 - v0) * t; }
SCALAR_FUN_ATTR f16 futrts_ldexp16(f16 x, int32_t y) { return futrts_ldexp32((float)x, y); }
SCALAR_FUN_ATTR f16 futrts_copysign16(f16 x, f16 y) { return futrts_copysign32((float)x, y); }
SCALAR_FUN_ATTR f16 futrts_mad16(f16 a, f16 b, f16 c) { return a * b + c; }
SCALAR_FUN_ATTR f16 futrts_fma16(f16 a, f16 b, f16 c) { return fmaf(a, b, c); }

#endif

// The CUDA __half type cannot be put in unions for some reason, so we
// use bespoke conversion functions instead.
#ifdef __CUDA_ARCH__
SCALAR_FUN_ATTR int16_t fptobits_f16_i16(f16 x) { return __half_as_ushort(x); }
SCALAR_FUN_ATTR f16 bitstofp_i16_f16(int16_t x) { return __ushort_as_half(x); }
#elif defined(ISPC)
SCALAR_FUN_ATTR int16_t fptobits_f16_i16(f16 x) { varying int16_t y = *((varying int16_t * uniform)&x); return y;
}
SCALAR_FUN_ATTR f16 bitstofp_i16_f16(int16_t x) { varying f16 y = *((varying f16 * uniform)&x); return y; }
#else
SCALAR_FUN_ATTR int16_t fptobits_f16_i16(f16 x) {
  union {
    f16 f;
    int16_t t;
  } p;

  p.f = x;
  return p.t;
}

SCALAR_FUN_ATTR f16 bitstofp_i16_f16(int16_t x) {
  union {
    int16_t f;
    f16 t;
  } p;

  p.f = x;
  return p.t;
}
#endif

#else // No native f16 - emulate.

SCALAR_FUN_ATTR f16 fabs16(f16 x) { return fabs32(x); }
SCALAR_FUN_ATTR f16 fmax16(f16 x, f16 y) { return fmax32(x, y); }
SCALAR_FUN_ATTR f16 fmin16(f16 x, f16 y) { return fmin32(x, y); }
SCALAR_FUN_ATTR f16 fpow16(f16 x, f16 y) { return fpow32(x, y); }
SCALAR_FUN_ATTR bool futrts_isnan16(f16 x) { return futrts_isnan32(x); }
SCALAR_FUN_ATTR bool futrts_isinf16(f16 x) { return futrts_isinf32(x); }
SCALAR_FUN_ATTR f16 futrts_log16(f16 x) { return futrts_log32(x); }
SCALAR_FUN_ATTR f16 futrts_log2_16(f16 x) { return futrts_log2_32(x); }
SCALAR_FUN_ATTR f16 futrts_log10_16(f16 x) { return futrts_log10_32(x); }
SCALAR_FUN_ATTR f16 futrts_log1p_16(f16 x) { return futrts_log1p_32(x); }
SCALAR_FUN_ATTR f16 futrts_sqrt16(f16 x) { return futrts_sqrt32(x); }
SCALAR_FUN_ATTR f16 futrts_rsqrt16(f16 x) { return futrts_rsqrt32(x); }
SCALAR_FUN_ATTR f16 futrts_cbrt16(f16 x) { return futrts_cbrt32(x); }
SCALAR_FUN_ATTR f16 futrts_exp16(f16 x) { return futrts_exp32(x); }
SCALAR_FUN_ATTR f16 futrts_cos16(f16 x) { return futrts_cos32(x); }
SCALAR_FUN_ATTR f16 futrts_cospi16(f16 x) { return futrts_cospi32(x); }
SCALAR_FUN_ATTR f16 futrts_sin16(f16 x) { return futrts_sin32(x); }
SCALAR_FUN_ATTR f16 futrts_sinpi16(f16 x) { return futrts_sinpi32(x); }
SCALAR_FUN_ATTR f16 futrts_tan16(f16 x) { return futrts_tan32(x); }
SCALAR_FUN_ATTR f16 futrts_tanpi16(f16 x) { return futrts_tanpi32(x); }
SCALAR_FUN_ATTR f16 futrts_acos16(f16 x) { return futrts_acos32(x); }
SCALAR_FUN_ATTR f16 futrts_acospi16(f16 x) { return futrts_acospi32(x); }
SCALAR_FUN_ATTR f16 futrts_asin16(f16 x) { return futrts_asin32(x); }
SCALAR_FUN_ATTR f16 futrts_asinpi16(f16 x) { return futrts_asinpi32(x); }
SCALAR_FUN_ATTR f16 futrts_atan16(f16 x) { return futrts_atan32(x); }
SCALAR_FUN_ATTR f16 futrts_atanpi16(f16 x) { return futrts_atanpi32(x); }
SCALAR_FUN_ATTR f16 futrts_cosh16(f16 x) { return futrts_cosh32(x); }
SCALAR_FUN_ATTR f16 futrts_sinh16(f16 x) { return futrts_sinh32(x); }
SCALAR_FUN_ATTR f16 futrts_tanh16(f16 x) { return futrts_tanh32(x); }
SCALAR_FUN_ATTR f16 futrts_acosh16(f16 x) { return futrts_acosh32(x); }
SCALAR_FUN_ATTR f16 futrts_asinh16(f16 x) { return futrts_asinh32(x); }
SCALAR_FUN_ATTR f16 futrts_atanh16(f16 x) { return futrts_atanh32(x); }
SCALAR_FUN_ATTR f16 futrts_atan2_16(f16 x, f16 y) { return futrts_atan2_32(x, y); }
SCALAR_FUN_ATTR f16 futrts_atan2pi_16(f16 x, f16 y) { return futrts_atan2pi_32(x, y); }
SCALAR_FUN_ATTR f16 futrts_hypot16(f16 x, f16 y) { return futrts_hypot32(x, y); }
SCALAR_FUN_ATTR f16 futrts_gamma16(f16 x) { return futrts_gamma32(x); }
SCALAR_FUN_ATTR f16 futrts_lgamma16(f16 x) { return futrts_lgamma32(x); }
SCALAR_FUN_ATTR f16 futrts_erf16(f16 x) { return futrts_erf32(x); }
SCALAR_FUN_ATTR f16 futrts_erfc16(f16 x) { return futrts_erfc32(x); }
SCALAR_FUN_ATTR f16 fmod16(f16 x, f16 y) { return fmod32(x, y); }
SCALAR_FUN_ATTR f16 futrts_round16(f16 x) { return futrts_round32(x); }
SCALAR_FUN_ATTR f16 futrts_floor16(f16 x) { return futrts_floor32(x); }
SCALAR_FUN_ATTR f16 futrts_ceil16(f16 x) { return futrts_ceil32(x); }
SCALAR_FUN_ATTR f16 futrts_nextafter16(f16 x, f16 y) { return halfbits2float(halfbitsnextafter(float2halfbits(x), float2halfbits(y))); }
SCALAR_FUN_ATTR f16 futrts_lerp16(f16 v0, f16 v1, f16 t) { return futrts_lerp32(v0, v1, t); }
SCALAR_FUN_ATTR f16 futrts_ldexp16(f16 x, int32_t y) { return futrts_ldexp32(x, y); }
SCALAR_FUN_ATTR f16 futrts_copysign16(f16 x, f16 y) { return futrts_copysign32((float)x, y); }
SCALAR_FUN_ATTR f16 futrts_mad16(f16 a, f16 b, f16 c) { return futrts_mad32(a, b, c); }
SCALAR_FUN_ATTR f16 futrts_fma16(f16 a, f16 b, f16 c) { return futrts_fma32(a, b, c); }

// Even when we are using an OpenCL that does not support cl_khr_fp16,
// it must still support vload_half for actually creating a
// half-precision number, which can then be efficiently converted to a
// float.  Similarly for vstore_half.
#ifdef __OPENCL_VERSION__

SCALAR_FUN_ATTR int16_t fptobits_f16_i16(f16 x) {
  int16_t y;
  // Violating strict aliasing here.
  vstore_half((float)x, 0, (half*)&y);
  return y;
}

SCALAR_FUN_ATTR f16 bitstofp_i16_f16(int16_t x) {
  return (f16)vload_half(0, (half*)&x);
}

#else
SCALAR_FUN_ATTR int16_t fptobits_f16_i16(f16 x) { return (int16_t)float2halfbits(x); }
SCALAR_FUN_ATTR f16 bitstofp_i16_f16(int16_t x) { return halfbits2float((uint16_t)x); }
SCALAR_FUN_ATTR f16 fsignum16(f16 x) { return futrts_isnan16(x) ? x : (x > 0 ? 1 : 0) - (x < 0 ? 1 : 0); }

#endif

#endif

SCALAR_FUN_ATTR float fpconv_f16_f16(f16 x) { return x; }
SCALAR_FUN_ATTR float fpconv_f16_f32(f16 x) { return x; }
SCALAR_FUN_ATTR f16 fpconv_f32_f16(float x) { return (f16) x; }

#ifdef FUTHARK_F64_ENABLED
SCALAR_FUN_ATTR double fpconv_f16_f64(f16 x) { return (double) x; }
#if defined(ISPC)
SCALAR_FUN_ATTR f16 fpconv_f64_f16(double x) { return (f16) ((float)x); }
#else
SCALAR_FUN_ATTR f16 fpconv_f64_f16(double x) { return (f16) x; }
#endif
#endif

// End of scalar_f16.h.

// Start of context_prototypes.h
//
// Prototypes for the functions in context.h, or that will be called
// from those functions, that need to be available very early.

struct futhark_context_config;
struct futhark_context;

static void set_error(struct futhark_context* ctx, char *error);

// These are called in context/config new/free functions and contain
// shared setup.  They are generated by the compiler itself.
static int init_constants(struct futhark_context*);
static int free_constants(struct futhark_context*);
static void setup_program(struct futhark_context* ctx);
static void teardown_program(struct futhark_context *ctx);

// Allocate host memory.  Must be freed with host_free().
static void host_alloc(struct futhark_context* ctx, size_t size, const char* tag, size_t* size_out, void** mem_out);
// Allocate memory allocated with host_alloc().
static void host_free(struct futhark_context* ctx, size_t size, const char* tag, void* mem);

// Log that a copy has occurred. The provenance may be NULL, if we do not know
// where this came from.
static void log_copy(struct futhark_context* ctx,
                     const char *kind, const char *provenance,
                     int r,
                     int64_t dst_offset, int64_t dst_strides[r],
                     int64_t src_offset, int64_t src_strides[r],
                     int64_t shape[r]);

static void log_transpose(struct futhark_context* ctx,
                          int64_t k, int64_t m, int64_t n);

static bool lmad_map_tr(int64_t *num_arrays_out, int64_t *n_out, int64_t *m_out,
                        int r,
                        const int64_t dst_strides[r],
                        const int64_t src_strides[r],
                        const int64_t shape[r]);

static bool lmad_contiguous(int r, int64_t strides[r], int64_t shape[r]);

static bool lmad_memcpyable(int r,
                            int64_t dst_strides[r], int64_t src_strides[r], int64_t shape[r]);

static void add_event(struct futhark_context* ctx,
                      const char* name,
                      const char* provenance,
                      struct kvs *kvs,
                      void* data,
                      event_report_fn f);

// Functions that must be defined by the backend.
static void backend_context_config_setup(struct futhark_context_config* cfg);
static void backend_context_config_teardown(struct futhark_context_config* cfg);
static int backend_context_setup(struct futhark_context *ctx);
static void backend_context_teardown(struct futhark_context *ctx);

// End of of context_prototypes.h

struct memblock {
    int *references;
    unsigned char *mem;
    int64_t size;
    const char *desc;
};
struct constants {
    int dummy;
};
struct tuning_params {
    int dummy;
};
static const int num_tuning_params = 0;
static const char *tuning_param_names[] = {NULL};
static const char *tuning_param_vars[] = {NULL};
static const char *tuning_param_classes[] = {NULL};
static int64_t tuning_param_defaults[] = {0};
// Start of backends/c.h

struct futhark_context_config {
  int in_use;
  int debugging;
  int profiling;
  int logging;
  char *cache_fname;
  int num_tuning_params;
  int64_t *tuning_params;
  const char** tuning_param_names;
  const char** tuning_param_vars;
  const char** tuning_param_classes;
};

static void backend_context_config_setup(struct futhark_context_config* cfg) {
  (void)cfg;
}

static void backend_context_config_teardown(struct futhark_context_config* cfg) {
  (void)cfg;
}

int futhark_context_config_set_tuning_param(struct futhark_context_config* cfg, const char *param_name, size_t param_value) {
  (void)cfg; (void)param_name; (void)param_value;
  return 1;
}

struct futhark_context {
  struct futhark_context_config* cfg;
  int detail_memory;
  int debugging;
  int profiling;
  int profiling_paused;
  int logging;
  lock_t lock;
  char *error;
  lock_t error_lock;
  FILE *log;
  struct constants *constants;
  struct free_list free_list;
  struct event_list event_list;
  int64_t peak_mem_usage_default;
  int64_t cur_mem_usage_default;
  struct program* program;
  bool program_initialised;
};

int backend_context_setup(struct futhark_context* ctx) {
  (void)ctx;
  return 0;
}

void backend_context_teardown(struct futhark_context* ctx) {
  (void)ctx;
}

int futhark_context_sync(struct futhark_context* ctx) {
  (void)ctx;
  return 0;
}

// End of backends/c.h

struct program {
    int dummy;
};
static void setup_program(struct futhark_context *ctx)
{
    (void) ctx;
    
    int error = 0;
    
    (void) error;
    ctx->program = malloc(sizeof(struct program));
}
static void teardown_program(struct futhark_context *ctx)
{
    (void) ctx;
    
    int error = 0;
    
    (void) error;
    free(ctx->program);
}
static void set_tuning_params(struct futhark_context *ctx)
{
    (void) ctx;
}
int memblock_unref(struct futhark_context *ctx, struct memblock *block, const char *desc)
{
    if (block->references != NULL) {
        *block->references -= 1;
        if (ctx->detail_memory)
            fprintf(ctx->log, "Unreferencing block %s (allocated as %s) in %s: %d references remaining.\n", desc, block->desc, "default space", *block->references);
        if (*block->references == 0) {
            ctx->cur_mem_usage_default -= block->size;
            host_free(ctx, (size_t) block->size, desc, (void *) block->mem);
            free(block->references);
            if (ctx->detail_memory)
                fprintf(ctx->log, "%lld bytes freed (now allocated: %lld bytes)\n", (long long) block->size, (long long) ctx->cur_mem_usage_default);
        }
        block->references = NULL;
    }
    return 0;
}
int memblock_alloc(struct futhark_context *ctx, struct memblock *block, int64_t size, const char *desc)
{
    if (size < 0)
        futhark_panic(1, "Negative allocation of %lld bytes attempted for %s in %s.\n", (long long) size, desc, "default space", ctx->cur_mem_usage_default);
    
    int ret = memblock_unref(ctx, block, desc);
    
    if (ret != FUTHARK_SUCCESS)
        return ret;
    if (ctx->detail_memory)
        fprintf(ctx->log, "Allocating %lld bytes for %s in %s (currently allocated: %lld bytes).\n", (long long) size, desc, "default space", (long long) ctx->cur_mem_usage_default);
    host_alloc(ctx, (size_t) size, desc, (size_t *) &size, (void *) &block->mem);
    if (ctx->error == NULL) {
        block->references = (int *) malloc(sizeof(int));
        *block->references = 1;
        block->size = size;
        block->desc = desc;
        
        long long new_usage = ctx->cur_mem_usage_default + size;
        
        if (ctx->detail_memory)
            fprintf(ctx->log, "Received block of %lld bytes; now allocated: %lld bytes", (long long) block->size, new_usage);
        ctx->cur_mem_usage_default = new_usage;
        if (new_usage > ctx->peak_mem_usage_default) {
            ctx->peak_mem_usage_default = new_usage;
            if (ctx->detail_memory)
                fprintf(ctx->log, " (new peak).\n");
        } else if (ctx->detail_memory)
            fprintf(ctx->log, ".\n");
        return FUTHARK_SUCCESS;
    } else {
        // We are naively assuming that any memory allocation error is due to OOM.
        lock_lock(&ctx->error_lock);
        
        char *old_error = ctx->error;
        
        ctx->error = msgprintf("Failed to allocate memory in %s.\nAttempted allocation: %12lld bytes\nCurrently allocated:  %12lld bytes\n%s", "default space", (long long) size, (long long) ctx->cur_mem_usage_default, old_error);
        free(old_error);
        lock_unlock(&ctx->error_lock);
        return FUTHARK_OUT_OF_MEMORY;
    }
}
int memblock_set(struct futhark_context *ctx, struct memblock *lhs, struct memblock *rhs, const char *lhs_desc)
{
    int ret = memblock_unref(ctx, lhs, lhs_desc);
    
    if (rhs->references != NULL)
        (*rhs->references)++;
    *lhs = *rhs;
    return ret;
}
char *futhark_context_report(struct futhark_context *ctx)
{
    if (futhark_context_sync(ctx) != 0)
        return NULL;
    
    struct str_builder builder;
    
    str_builder_init(&builder);
    str_builder_char(&builder, '{');
    str_builder_str(&builder, "\"memory\":{");
    str_builder(&builder, "\"default space\": %lld", (long long) ctx->peak_mem_usage_default);
    str_builder_str(&builder, "},\"events\":[");
    if (report_events_in_list(&ctx->event_list, &builder) != 0) {
        free(builder.str);
        return NULL;
    } else {
        str_builder_str(&builder, "]}");
        return builder.str;
    }
}
int futhark_context_clear_caches(struct futhark_context *ctx)
{
    lock_lock(&ctx->lock);
    ctx->peak_mem_usage_default = 0;
    lock_unlock(&ctx->lock);
    return ctx->error != NULL;
}

// Start of context.h

// Internal functions.

static void set_error(struct futhark_context* ctx, char *error) {
  lock_lock(&ctx->error_lock);
  if (ctx->error == NULL) {
    ctx->error = error;
  } else {
    free(error);
  }
  lock_unlock(&ctx->error_lock);
}

// XXX: should be static, but used in ispc_util.h
void lexical_realloc_error(struct futhark_context* ctx, size_t new_size) {
  set_error(ctx,
            msgprintf("Failed to allocate memory.\nAttempted allocation: %12lld bytes\n",
                      (long long) new_size));
}

static int lexical_realloc(struct futhark_context *ctx,
                           unsigned char **ptr,
                           int64_t *old_size,
                           int64_t new_size) {
  unsigned char *new = realloc(*ptr, (size_t)new_size);
  if (new == NULL) {
    lexical_realloc_error(ctx, new_size);
    return FUTHARK_OUT_OF_MEMORY;
  } else {
    *ptr = new;
    *old_size = new_size;
    return FUTHARK_SUCCESS;
  }
}

static void free_all_in_free_list(struct futhark_context* ctx) {
  fl_mem mem;
  free_list_pack(&ctx->free_list);
  while (free_list_first(&ctx->free_list, (fl_mem*)&mem) == 0) {
    free((void*)mem);
  }
}

static int is_small_alloc(size_t size) {
  return size < 1024*1024;
}

static void host_alloc(struct futhark_context* ctx,
                       size_t size, const char* tag, size_t* size_out, void** mem_out) {
  if (is_small_alloc(size) || free_list_find(&ctx->free_list, size, tag, size_out, (fl_mem*)mem_out) != 0) {
    *size_out = size;
    *mem_out = malloc(size);
  }
}

static void host_free(struct futhark_context* ctx,
                      size_t size, const char* tag, void* mem) {
  // Small allocations are handled by malloc()s own free list.  The
  // threshold here is kind of arbitrary, but seems to work OK.
  // Larger allocations are mmap()ed/munmapped() every time, which is
  // very slow, and Futhark programs tend to use a few very large
  // allocations.
  if (is_small_alloc(size)) {
    free(mem);
  } else {
    free_list_insert(&ctx->free_list, size, (fl_mem)mem, tag);
  }
}

static void add_event(struct futhark_context* ctx,
                      const char* name,
                      const char* provenance,
                      struct kvs *kvs,
                      void* data,
                      event_report_fn f) {
  if (provenance == NULL) {
    provenance = "unknown";
  }
  if (ctx->logging) {
    fprintf(ctx->log, "Event: %s\n  at: %s\n", name, provenance);
    if (kvs) {
      kvs_log(kvs, "  ", ctx->log);
    }
  }
  add_event_to_list(&ctx->event_list, name, provenance, kvs, data, f);
}

char *futhark_context_get_error(struct futhark_context *ctx) {
  char *error = ctx->error;
  ctx->error = NULL;
  return error;
}

void futhark_context_config_set_debugging(struct futhark_context_config *cfg, int flag) {
    cfg->profiling = cfg->logging = cfg->debugging = flag;
}

void futhark_context_config_set_profiling(struct futhark_context_config *cfg, int flag) {
    cfg->profiling = flag;
}

void futhark_context_config_set_logging(struct futhark_context_config *cfg, int flag) {
    cfg->logging = flag;
}

void futhark_context_config_set_cache_file(struct futhark_context_config *cfg, const char *f) {
  cfg->cache_fname = strdup(f);
}

int futhark_get_tuning_param_count(void) {
  return num_tuning_params;
}

const char *futhark_get_tuning_param_name(int i) {
  return tuning_param_names[i];
}

const char *futhark_get_tuning_param_class(int i) {
    return tuning_param_classes[i];
}

void futhark_context_set_logging_file(struct futhark_context *ctx, FILE *f){
  ctx->log = f;
}

void futhark_context_pause_profiling(struct futhark_context *ctx) {
  ctx->profiling_paused = 1;
}

void futhark_context_unpause_profiling(struct futhark_context *ctx) {
  ctx->profiling_paused = 0;
}

struct futhark_context_config* futhark_context_config_new(void) {
  struct futhark_context_config* cfg = malloc(sizeof(struct futhark_context_config));
  if (cfg == NULL) {
    return NULL;
  }
  cfg->in_use = 0;
  cfg->debugging = 0;
  cfg->profiling = 0;
  cfg->logging = 0;
  cfg->cache_fname = NULL;
  cfg->num_tuning_params = num_tuning_params;
  cfg->tuning_params = malloc(cfg->num_tuning_params * sizeof(int64_t));
  memcpy(cfg->tuning_params, tuning_param_defaults,
         cfg->num_tuning_params * sizeof(int64_t));
  cfg->tuning_param_names = tuning_param_names;
  cfg->tuning_param_vars = tuning_param_vars;
  cfg->tuning_param_classes = tuning_param_classes;
  backend_context_config_setup(cfg);
  return cfg;
}

void futhark_context_config_free(struct futhark_context_config* cfg) {
  assert(!cfg->in_use);
  backend_context_config_teardown(cfg);
  free(cfg->cache_fname);
  free(cfg->tuning_params);
  free(cfg);
}

struct futhark_context* futhark_context_new(struct futhark_context_config* cfg) {
  struct futhark_context* ctx = malloc(sizeof(struct futhark_context));
  if (ctx == NULL) {
    return NULL;
  }
  assert(!cfg->in_use);
  ctx->cfg = cfg;
  ctx->cfg->in_use = 1;
  ctx->program_initialised = false;
  create_lock(&ctx->error_lock);
  create_lock(&ctx->lock);
  free_list_init(&ctx->free_list);
  event_list_init(&ctx->event_list);
  ctx->peak_mem_usage_default = 0;
  ctx->cur_mem_usage_default = 0;
  ctx->constants = malloc(sizeof(struct constants));
  ctx->debugging = cfg->debugging;
  ctx->logging = cfg->logging;
  ctx->detail_memory = cfg->logging;
  ctx->profiling = cfg->profiling;
  ctx->profiling_paused = 0;
  ctx->error = NULL;
  ctx->log = stderr;
  set_tuning_params(ctx);
  if (backend_context_setup(ctx) == 0) {
    setup_program(ctx);
    init_constants(ctx);
    ctx->program_initialised = true;
    (void)futhark_context_clear_caches(ctx);
    (void)futhark_context_sync(ctx);
  }
  return ctx;
}

void futhark_context_free(struct futhark_context* ctx) {
  if (ctx->program_initialised) {
    free_constants(ctx);
    teardown_program(ctx);
  }
  backend_context_teardown(ctx);
  free_all_in_free_list(ctx);
  free_list_destroy(&ctx->free_list);
  event_list_free(&ctx->event_list);
  free(ctx->constants);
  free(ctx->error);
  free_lock(&ctx->lock);
  free_lock(&ctx->error_lock);
  ctx->cfg->in_use = 0;
  free(ctx);
}

// End of context.h

// Start of copy.h

// Cache-oblivious map-transpose function.
#define GEN_MAP_TRANSPOSE(NAME, ELEM_TYPE)                              \
  static void map_transpose_##NAME                                      \
  (ELEM_TYPE* dst, ELEM_TYPE* src,                                      \
   int64_t k, int64_t m, int64_t n,                                     \
   int64_t cb, int64_t ce, int64_t rb, int64_t re)                      \
  {                                                                     \
  int32_t r = re - rb;                                                  \
  int32_t c = ce - cb;                                                  \
  if (k == 1) {                                                         \
    if (r <= 64 && c <= 64) {                                           \
      for (int64_t j = 0; j < c; j++) {                                 \
        for (int64_t i = 0; i < r; i++) {                               \
          dst[(j + cb) * n + (i + rb)] = src[(i + rb) * m + (j + cb)];  \
        }                                                               \
      }                                                                 \
    } else if (c <= r) {                                                \
      map_transpose_##NAME(dst, src, k, m, n, cb, ce, rb, rb + r/2);    \
      map_transpose_##NAME(dst, src, k, m, n, cb, ce, rb + r/2, re);    \
    } else {                                                            \
      map_transpose_##NAME(dst, src, k, m, n, cb, cb + c/2, rb, re);    \
      map_transpose_##NAME(dst, src, k, m, n, cb + c/2, ce, rb, re);    \
    }                                                                   \
  } else {                                                              \
  for (int64_t i = 0; i < k; i++) {                                     \
    map_transpose_##NAME(dst + i * m * n, src + i * m * n, 1, m, n, cb, ce, rb, re); \
  }\
} \
}

// Straightforward LMAD copy function.
#define GEN_LMAD_COPY_ELEMENTS(NAME, ELEM_TYPE)                         \
  static void lmad_copy_elements_##NAME(int r,                          \
                                        ELEM_TYPE* dst, int64_t dst_strides[r], \
                                        ELEM_TYPE *src, int64_t src_strides[r], \
                                        int64_t shape[r]) {             \
    if (r == 1) {                                                       \
      for (int i = 0; i < shape[0]; i++) {                              \
        dst[i*dst_strides[0]] = src[i*src_strides[0]];                  \
      }                                                                 \
    } else if (r > 1) {                                                 \
      for (int i = 0; i < shape[0]; i++) {                              \
        lmad_copy_elements_##NAME(r-1,                                  \
                                  dst+i*dst_strides[0], dst_strides+1,  \
                                  src+i*src_strides[0], src_strides+1,  \
                                  shape+1);                             \
      }                                                                 \
    }                                                                   \
  }                                                                     \

// Check whether this LMAD can be seen as a transposed 2D array.  This
// is done by checking every possible splitting point.
static bool lmad_is_tr(int64_t *n_out, int64_t *m_out,
                       int r,
                       const int64_t strides[r],
                       const int64_t shape[r]) {
  for (int i = 1; i < r; i++) {
    int n = 1, m = 1;
    bool ok = true;
    int64_t expected = 1;
    // Check strides before 'i'.
    for (int j = i-1; j >= 0; j--) {
      ok = ok && strides[j] == expected;
      expected *= shape[j];
      n *= shape[j];
    }
    // Check strides after 'i'.
    for (int j = r-1; j >= i; j--) {
      ok = ok && strides[j] == expected;
      expected *= shape[j];
      m *= shape[j];
    }
    if (ok) {
      *n_out = n;
      *m_out = m;
      return true;
    }
  }
  return false;
}

// This function determines whether the a 'dst' LMAD is row-major and
// 'src' LMAD is column-major.  Both LMADs are for arrays of the same
// shape.  Both LMADs are allowed to have additional dimensions "on
// top".  Essentially, this function determines whether a copy from
// 'src' to 'dst' is a "map(transpose)" that we know how to implement
// efficiently.  The LMADs can have arbitrary rank, and the main
// challenge here is checking whether the src LMAD actually
// corresponds to a 2D column-major layout by morally collapsing
// dimensions.  There is a lot of looping here, but the actual trip
// count is going to be very low in practice.
//
// Returns true if this is indeed a map(transpose), and writes the
// number of arrays, and moral array size to appropriate output
// parameters.
static bool lmad_map_tr(int64_t *num_arrays_out, int64_t *n_out, int64_t *m_out,
                        int r,
                        const int64_t dst_strides[r],
                        const int64_t src_strides[r],
                        const int64_t shape[r]) {
  int64_t rowmajor_strides[r];
  rowmajor_strides[r-1] = 1;

  for (int i = r-2; i >= 0; i--) {
    rowmajor_strides[i] = rowmajor_strides[i+1] * shape[i+1];
  }

  // map_r will be the number of mapped dimensions on top.
  int map_r = 0;
  int64_t num_arrays = 1;
  for (int i = 0; i < r; i++) {
    if (dst_strides[i] != rowmajor_strides[i] ||
        src_strides[i] != rowmajor_strides[i]) {
      break;
    } else {
      num_arrays *= shape[i];
      map_r++;
    }
  }

  *num_arrays_out = num_arrays;

  if (r==map_r) {
    return false;
  }

  if (memcmp(&rowmajor_strides[map_r],
             &dst_strides[map_r],
             sizeof(int64_t)*(r-map_r)) == 0) {
    return lmad_is_tr(n_out, m_out, r-map_r, src_strides+map_r, shape+map_r);
  } else if (memcmp(&rowmajor_strides[map_r],
                    &src_strides[map_r],
                    sizeof(int64_t)*(r-map_r)) == 0) {
    return lmad_is_tr(m_out, n_out, r-map_r, dst_strides+map_r, shape+map_r);
  }
  return false;
}

// Check if the strides correspond to row-major strides of *any*
// permutation of the shape.  This is done by recursive search with
// backtracking.  This is worst-case exponential, but hopefully the
// arrays we encounter do not have that many dimensions.
static bool lmad_contiguous_search(int checked, int64_t expected,
                                   int r,
                                   int64_t strides[r], int64_t shape[r], bool used[r]) {
  for (int i = 0; i < r; i++) {
    for (int j = 0; j < r; j++) {
      if (!used[j] && strides[j] == expected && strides[j] >= 0) {
        used[j] = true;
        if (checked+1 == r ||
            lmad_contiguous_search(checked+1, expected * shape[j], r, strides, shape, used)) {
          return true;
        }
        used[j] = false;
      }
    }
  }
  return false;
}

// Does this LMAD correspond to an array with positive strides and no
// holes?
static bool lmad_contiguous(int r, int64_t strides[r], int64_t shape[r]) {
  bool used[r];
  for (int i = 0; i < r; i++) {
    used[i] = false;
  }
  return lmad_contiguous_search(0, 1, r, strides, shape, used);
}

// Does this copy correspond to something that could be done with a
// memcpy()-like operation?  I.e. do the LMADs actually represent the
// same in-memory layout and are they contiguous?
static bool lmad_memcpyable(int r,
                            int64_t dst_strides[r], int64_t src_strides[r], int64_t shape[r]) {
  if (!lmad_contiguous(r, dst_strides, shape)) {
    return false;
  }
  for (int i = 0; i < r; i++) {
    if (dst_strides[i] != src_strides[i] && shape[i] != 1) {
      return false;
    }
  }
  return true;
}


static void log_copy(struct futhark_context* ctx,
                     const char *kind, const char *provenance,
                     int r,
                     int64_t dst_offset, int64_t dst_strides[r],
                     int64_t src_offset, int64_t src_strides[r],
                     int64_t shape[r]) {
  if (ctx->logging) {
    fprintf(ctx->log, "\n# Copy %s\n", kind);
    if (provenance) { fprintf(ctx->log, "At: %s\n", provenance); }
    fprintf(ctx->log, "Shape: ");
    for (int i = 0; i < r; i++) { fprintf(ctx->log, "[%ld]", (long int)shape[i]); }
    fprintf(ctx->log, "\n");
    fprintf(ctx->log, "Dst offset: %ld\n", (long int)dst_offset);
    fprintf(ctx->log, "Dst strides:");
    for (int i = 0; i < r; i++) { fprintf(ctx->log, " %ld", (long int)dst_strides[i]); }
    fprintf(ctx->log, "\n");
    fprintf(ctx->log, "Src offset: %ld\n", (long int)src_offset);
    fprintf(ctx->log, "Src strides:");
    for (int i = 0; i < r; i++) { fprintf(ctx->log, " %ld", (long int)src_strides[i]); }
    fprintf(ctx->log, "\n");
  }
}

static void log_transpose(struct futhark_context* ctx,
                          int64_t k, int64_t n, int64_t m) {
  if (ctx->logging) {
    fprintf(ctx->log, "## Transpose\n");
    fprintf(ctx->log, "Arrays     : %ld\n", (long int)k);
    fprintf(ctx->log, "X elements : %ld\n", (long int)m);
    fprintf(ctx->log, "Y elements : %ld\n", (long int)n);
    fprintf(ctx->log, "\n");
  }
}

#define GEN_LMAD_COPY(NAME, ELEM_TYPE)                                  \
  static void lmad_copy_##NAME                                          \
  (struct futhark_context *ctx, int r,                                  \
   ELEM_TYPE* dst, int64_t dst_offset, int64_t dst_strides[r],          \
   ELEM_TYPE *src, int64_t src_offset, int64_t src_strides[r],          \
   int64_t shape[r]) {                                                  \
    log_copy(ctx, "CPU to CPU", NULL, r, dst_offset, dst_strides,       \
             src_offset, src_strides, shape);                           \
    int64_t size = 1;                                                   \
    for (int i = 0; i < r; i++) { size *= shape[i]; }                   \
    if (size == 0) { return; }                                          \
    int64_t k, n, m;                                                    \
    if (lmad_map_tr(&k, &n, &m,                                         \
                    r, dst_strides, src_strides, shape)) {              \
      log_transpose(ctx, k, n, m);                                      \
      map_transpose_##NAME                                              \
        (dst+dst_offset, src+src_offset, k, n, m, 0, n, 0, m);          \
    } else if (lmad_memcpyable(r, dst_strides, src_strides, shape)) {   \
      if (ctx->logging) {fprintf(ctx->log, "## Flat copy\n\n");}          \
      memcpy(dst+dst_offset, src+src_offset, size*sizeof(*dst));        \
    } else {                                                            \
      if (ctx->logging) {fprintf(ctx->log, "## General copy\n\n");}       \
      lmad_copy_elements_##NAME                                         \
        (r,                                                             \
         dst+dst_offset, dst_strides,                                   \
         src+src_offset, src_strides, shape);                           \
    }                                                                   \
  }

GEN_MAP_TRANSPOSE(1b, uint8_t)
GEN_MAP_TRANSPOSE(2b, uint16_t)
GEN_MAP_TRANSPOSE(4b, uint32_t)
GEN_MAP_TRANSPOSE(8b, uint64_t)

GEN_LMAD_COPY_ELEMENTS(1b, uint8_t)
GEN_LMAD_COPY_ELEMENTS(2b, uint16_t)
GEN_LMAD_COPY_ELEMENTS(4b, uint32_t)
GEN_LMAD_COPY_ELEMENTS(8b, uint64_t)

GEN_LMAD_COPY(1b, uint8_t)
GEN_LMAD_COPY(2b, uint16_t)
GEN_LMAD_COPY(4b, uint32_t)
GEN_LMAD_COPY(8b, uint64_t)

// End of copy.h

#define FUTHARK_FUN_ATTR static

FUTHARK_FUN_ATTR int futrts_entry_test_acc_prob(struct futhark_context *ctx, struct memblock *mem_out_p_50953, int64_t *out_prim_out_50954, int64_t n_29367, int64_t c_29368, int64_t Ax_29369);
FUTHARK_FUN_ATTR int futrts_entry_test_acc_prob_mat(struct futhark_context *ctx, struct memblock *mem_out_p_50957, int64_t *out_prim_out_50958, int64_t n_29623, int64_t c_29624, int64_t Ax_29625);
FUTHARK_FUN_ATTR int futrts_entry_test_bellman(struct futhark_context *ctx, struct memblock *mem_out_p_50987, int64_t *out_prim_out_50988, struct memblock newprices_mem_50257, int64_t c_36762, int64_t n_36763, int64_t Ax_36765);
FUTHARK_FUN_ATTR int futrts_entry_test_bellmanN(struct futhark_context *ctx, struct memblock *mem_out_p_51018, int64_t *out_prim_out_51019, struct memblock newprices_mem_50257, int64_t c_36886, int64_t n_36887, int64_t Ax_36889, int64_t N_36890);
FUTHARK_FUN_ATTR int futrts_entry_test_carprice_buy(struct futhark_context *ctx, struct memblock *mem_out_p_51052, int64_t *out_prim_out_51053, struct memblock newprices_mem_50257, int64_t c_29010, int64_t n_29011, int64_t Ax_29013);
FUTHARK_FUN_ATTR int futrts_entry_test_carprice_sell(struct futhark_context *ctx, struct memblock *mem_out_p_51057, int64_t *out_prim_out_51058, struct memblock newprices_mem_50257, int64_t c_27423, int64_t n_27424, int64_t Ax_27426);
FUTHARK_FUN_ATTR int futrts_entry_test_ev_scrap(struct futhark_context *ctx, struct memblock *mem_out_p_51063, int64_t *out_prim_out_51064, struct memblock newprices_mem_50257, int64_t c_28302, int64_t n_28303, int64_t Ax_28305);
FUTHARK_FUN_ATTR int futrts_entry_test_notrade(struct futhark_context *ctx, struct memblock *mem_out_p_51069, int64_t *out_prim_out_51070, int64_t n_26596, int64_t c_26597, int64_t Ax_26598);
FUTHARK_FUN_ATTR int futrts_entry_test_simple_prices(struct futhark_context *ctx, struct memblock *mem_out_p_51096, struct memblock newprices_mem_50257, int64_t c_22326, int64_t n_22327, int64_t Ax_22329);
FUTHARK_FUN_ATTR int futrts_entry_test_trade(struct futhark_context *ctx, struct memblock *mem_out_p_51099, int64_t *out_prim_out_51100, int64_t n_26698, int64_t c_26699, int64_t Ax_26700);
FUTHARK_FUN_ATTR int futrts_entry_test_utility(struct futhark_context *ctx, struct memblock *mem_out_p_51101, int64_t *out_prim_out_51102, int64_t *out_prim_out_51103, struct memblock newprices_mem_50257, int64_t c_35101, int64_t n_35102, int64_t Ax_35104);
FUTHARK_FUN_ATTR int futrts_entry_test_utility_2(struct futhark_context *ctx, struct memblock *mem_out_p_51106, int64_t *out_prim_out_51107, int64_t *out_prim_out_51108, struct memblock newprices_mem_50257, struct memblock u_a_sq_mem_50258, int64_t c_35258, int64_t n_35259, int64_t Ax_35261);
FUTHARK_FUN_ATTR int futrts_utility_10336(struct futhark_context *ctx, struct memblock *mem_out_p_51111, struct memblock acc_0_mem_50257, struct memblock acc_a_mem_50258, struct memblock acc_even_mem_50259, struct memblock maxage_mem_50260, struct memblock mum_mem_50261, struct memblock nd_mem_50262, struct memblock ns_mem_50263, struct memblock pnew_mem_50264, struct memblock pscrap_mem_50265, struct memblock psych_transcost_mem_50266, struct memblock tw_mem_50267, struct memblock u_0_mem_50268, struct memblock u_a_mem_50269, struct memblock u_a_sq_mem_50270, struct memblock p_mem_50271, int64_t n_34176, int64_t c_34177, int64_t Ax_34178, int64_t ns_34179, int64_t nd_34180, double bet_34184, double sigma_34192, double sigma_s_34193, int64_t tau_34199);

static int init_constants(struct futhark_context *ctx)
{
    (void) ctx;
    
    int err = 0;
    
    
  cleanup:
    return err;
}
static int free_constants(struct futhark_context *ctx)
{
    (void) ctx;
    return 0;
}
struct futhark_f64_1d {
    struct memblock mem;
    int64_t shape[1];
};
struct futhark_f64_1d *futhark_new_f64_1d(struct futhark_context *ctx, const double *data, int64_t dim0)
{
    int err = 0;
    struct futhark_f64_1d *bad = NULL;
    struct futhark_f64_1d *arr = (struct futhark_f64_1d *) malloc(sizeof(struct futhark_f64_1d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    if (memblock_alloc(ctx, &arr->mem, dim0 * 8, "arr->mem"))
        err = 1;
    arr->shape[0] = dim0;
    if ((size_t) dim0 * 8 > 0)
        memmove(arr->mem.mem + 0, (const unsigned char *) data + 0, (size_t) dim0 * 8);
    lock_unlock(&ctx->lock);
    if (err != 0) {
        free(arr);
        return bad;
    }
    return arr;
}
struct futhark_f64_1d *futhark_new_raw_f64_1d(struct futhark_context *ctx, unsigned char *data, int64_t dim0)
{
    int err = 0;
    struct futhark_f64_1d *bad = NULL;
    struct futhark_f64_1d *arr = (struct futhark_f64_1d *) malloc(sizeof(struct futhark_f64_1d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    arr->mem.mem = data;
    arr->shape[0] = dim0;
    lock_unlock(&ctx->lock);
    return arr;
}
int futhark_free_f64_1d(struct futhark_context *ctx, struct futhark_f64_1d *arr)
{
    lock_lock(&ctx->lock);
    if (memblock_unref(ctx, &arr->mem, "arr->mem") != 0)
        return 1;
    lock_unlock(&ctx->lock);
    free(arr);
    return 0;
}
int futhark_values_f64_1d(struct futhark_context *ctx, struct futhark_f64_1d *arr, double *data)
{
    int err = 0;
    
    lock_lock(&ctx->lock);
    if ((size_t) arr->shape[0] * 8 > 0)
        memmove((unsigned char *) data + 0, arr->mem.mem + 0, (size_t) arr->shape[0] * 8);
    lock_unlock(&ctx->lock);
    return err;
}
int futhark_index_f64_1d(struct futhark_context *ctx, double *out, struct futhark_f64_1d *arr, int64_t i0)
{
    int err = 0;
    
    if (i0 >= 0 && i0 < arr->shape[0]) {
        lock_lock(&ctx->lock);
        if (8 > 0)
            memmove((unsigned char *) out + 0, arr->mem.mem + 8 * (i0 * 1), 8);
        lock_unlock(&ctx->lock);
    } else {
        err = 1;
        set_error(ctx, strdup("Index out of bounds."));
    }
    return err;
}
unsigned char *futhark_values_raw_f64_1d(struct futhark_context *ctx, struct futhark_f64_1d *arr)
{
    (void) ctx;
    return arr->mem.mem;
}
const int64_t *futhark_shape_f64_1d(struct futhark_context *ctx, struct futhark_f64_1d *arr)
{
    (void) ctx;
    return arr->shape;
}
struct futhark_f64_2d {
    struct memblock mem;
    int64_t shape[2];
};
struct futhark_f64_2d *futhark_new_f64_2d(struct futhark_context *ctx, const double *data, int64_t dim0, int64_t dim1)
{
    int err = 0;
    struct futhark_f64_2d *bad = NULL;
    struct futhark_f64_2d *arr = (struct futhark_f64_2d *) malloc(sizeof(struct futhark_f64_2d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    if (memblock_alloc(ctx, &arr->mem, dim0 * dim1 * 8, "arr->mem"))
        err = 1;
    arr->shape[0] = dim0;
    arr->shape[1] = dim1;
    if ((size_t) (dim0 * dim1) * 8 > 0)
        memmove(arr->mem.mem + 0, (const unsigned char *) data + 0, (size_t) (dim0 * dim1) * 8);
    lock_unlock(&ctx->lock);
    if (err != 0) {
        free(arr);
        return bad;
    }
    return arr;
}
struct futhark_f64_2d *futhark_new_raw_f64_2d(struct futhark_context *ctx, unsigned char *data, int64_t dim0, int64_t dim1)
{
    int err = 0;
    struct futhark_f64_2d *bad = NULL;
    struct futhark_f64_2d *arr = (struct futhark_f64_2d *) malloc(sizeof(struct futhark_f64_2d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    arr->mem.mem = data;
    arr->shape[0] = dim0;
    arr->shape[1] = dim1;
    lock_unlock(&ctx->lock);
    return arr;
}
int futhark_free_f64_2d(struct futhark_context *ctx, struct futhark_f64_2d *arr)
{
    lock_lock(&ctx->lock);
    if (memblock_unref(ctx, &arr->mem, "arr->mem") != 0)
        return 1;
    lock_unlock(&ctx->lock);
    free(arr);
    return 0;
}
int futhark_values_f64_2d(struct futhark_context *ctx, struct futhark_f64_2d *arr, double *data)
{
    int err = 0;
    
    lock_lock(&ctx->lock);
    if ((size_t) (arr->shape[0] * arr->shape[1]) * 8 > 0)
        memmove((unsigned char *) data + 0, arr->mem.mem + 0, (size_t) (arr->shape[0] * arr->shape[1]) * 8);
    lock_unlock(&ctx->lock);
    return err;
}
int futhark_index_f64_2d(struct futhark_context *ctx, double *out, struct futhark_f64_2d *arr, int64_t i0, int64_t i1)
{
    int err = 0;
    
    if ((i0 >= 0 && i0 < arr->shape[0]) && (i1 >= 0 && i1 < arr->shape[1])) {
        lock_lock(&ctx->lock);
        if (8 > 0)
            memmove((unsigned char *) out + 0, arr->mem.mem + 8 * (i0 * arr->shape[1] + i1 * 1), 8);
        lock_unlock(&ctx->lock);
    } else {
        err = 1;
        set_error(ctx, strdup("Index out of bounds."));
    }
    return err;
}
unsigned char *futhark_values_raw_f64_2d(struct futhark_context *ctx, struct futhark_f64_2d *arr)
{
    (void) ctx;
    return arr->mem.mem;
}
const int64_t *futhark_shape_f64_2d(struct futhark_context *ctx, struct futhark_f64_2d *arr)
{
    (void) ctx;
    return arr->shape;
}

FUTHARK_FUN_ATTR int futrts_entry_test_acc_prob(struct futhark_context *ctx, struct memblock *mem_out_p_50953, int64_t *out_prim_out_50954, int64_t n_29367, int64_t c_29368, int64_t Ax_29369)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_50259_cached_sizze_50955 = 0;
    unsigned char *mem_50259 = NULL;
    int64_t mem_50278_cached_sizze_50956 = 0;
    unsigned char *mem_50278 = NULL;
    struct memblock mem_50282;
    
    mem_50282.references = NULL;
    
    struct memblock mem_out_50838;
    
    mem_out_50838.references = NULL;
    
    int64_t prim_out_50839;
    
    // trmodel.fut:133:36-39
    
    int64_t zp_lhs_48712 = mul64(c_29368, Ax_29369);
    
    // trmodel.fut:133:39-41
    
    int64_t replicate_arg0_48713 = add64((int64_t) 1, zp_lhs_48712);
    
    // trmodel.fut:274:10-276:102
    
    int64_t binop_x_50257 = (int64_t) 8 * c_29368;
    
    // trmodel.fut:274:10-276:102
    
    int64_t bytes_50258 = Ax_29369 * binop_x_50257;
    
    // trmodel_test.fut:98:16-99:18
    
    int64_t bytes_50281 = (int64_t) 8 * replicate_arg0_48713;
    
    // trmodel.fut:274:10-276:102
    if (mem_50259_cached_sizze_50955 < bytes_50258) {
        err = lexical_realloc(ctx, &mem_50259, &mem_50259_cached_sizze_50955, bytes_50258);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:274:10-276:102
    for (int64_t i_49984 = 0; i_49984 < c_29368; i_49984++) {
        // trmodel.fut:274:10-276:102
        for (int64_t i_49980 = 0; i_49980 < Ax_29369; i_49980++) {
            // trmodel.fut:275:41-43
            
            int64_t zm_rhs_41408 = smod64(i_49980, (int64_t) 2);
            
            // trmodel.fut:275:39-43
            
            int64_t i64_arg0_41409 = sub64((int64_t) 1, zm_rhs_41408);
            
            // trmodel.fut:275:32-43
            
            double i64_res_41410 = sitofp_i64_f64(i64_arg0_41409);
            
            // trmodel.fut:276:71-78
            
            double i64_res_41411 = sitofp_i64_f64(i_49980);
            
            // trmodel.fut:276:57-78
            
            double zt_res_41412 = 0.0 * i64_res_41411;
            
            // trmodel.fut:276:43-78
            
            double zm_res_41413 = 10.0 - zt_res_41412;
            
            // trmodel.fut:276:80-99
            
            double zt_res_41414 = 0.0 * i64_res_41410;
            
            // trmodel.fut:276:56-99
            
            double zm_res_41415 = zm_res_41413 - zt_res_41414;
            
            // trmodel.fut:276:32-99
            
            double exp_res_41416 = futrts_exp64(zm_res_41415);
            
            // trmodel.fut:276:25-100
            
            double zp_res_41417 = 1.0 + exp_res_41416;
            
            // trmodel.fut:276:16-100
            
            double zs_res_41418 = 1.0 / zp_res_41417;
            
            ((double *) mem_50259)[i_49984 * Ax_29369 + i_49980] = zs_res_41418;
        }
    }
    // trmodel.fut:273:8-277:13
    if (mem_50278_cached_sizze_50956 < bytes_50258) {
        err = lexical_realloc(ctx, &mem_50278, &mem_50278_cached_sizze_50956, bytes_50258);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:273:8-277:13
    // trmodel.fut:273:8-277:13
    lmad_copy_8b(ctx, 2, (uint64_t *) mem_50278, (int64_t) 0, (int64_t []) {Ax_29369, (int64_t) 1}, (uint64_t *) mem_50259, (int64_t) 0, (int64_t []) {Ax_29369, (int64_t) 1}, (int64_t []) {c_29368, Ax_29369});
    // trmodel_test.fut:98:16-99:18
    if (memblock_alloc(ctx, &mem_50282, bytes_50281, "mem_50282")) {
        err = 1;
        goto cleanup;
    }
    // trmodel_test.fut:98:16-99:18
    for (int64_t nest_i_50842 = 0; nest_i_50842 < (int64_t) 1; nest_i_50842++) {
        ((double *) mem_50282.mem)[zp_lhs_48712 + nest_i_50842] = 0.0;
    }
    // trmodel_test.fut:98:16-99:18
    
    int64_t tmp_offs_50843 = (int64_t) 0;
    
    // trmodel_test.fut:98:16-99:18
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_50282.mem, tmp_offs_50843, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_50278, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {zp_lhs_48712});
    tmp_offs_50843 += zp_lhs_48712;
    if (!(tmp_offs_50843 == zp_lhs_48712)) {
        // trmodel_test.fut:98:16-99:18
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_50282.mem, tmp_offs_50843, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_50282.mem, zp_lhs_48712, (int64_t []) {(int64_t) 1}, (int64_t []) {(int64_t) 1});
    }
    tmp_offs_50843 += (int64_t) 1;
    if (memblock_set(ctx, &mem_out_50838, &mem_50282, "mem_50282") != 0)
        return 1;
    prim_out_50839 = replicate_arg0_48713;
    if (memblock_set(ctx, &*mem_out_p_50953, &mem_out_50838, "mem_out_50838") != 0)
        return 1;
    *out_prim_out_50954 = prim_out_50839;
    
  cleanup:
    {
        free(mem_50259);
        free(mem_50278);
        if (memblock_unref(ctx, &mem_50282, "mem_50282") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_50838, "mem_out_50838") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_test_acc_prob_mat(struct futhark_context *ctx, struct memblock *mem_out_p_50957, int64_t *out_prim_out_50958, int64_t n_29623, int64_t c_29624, int64_t Ax_29625)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_50259_cached_sizze_50959 = 0;
    unsigned char *mem_50259 = NULL;
    int64_t mem_50262_cached_sizze_50960 = 0;
    unsigned char *mem_50262 = NULL;
    int64_t mem_50291_cached_sizze_50961 = 0;
    unsigned char *mem_50291 = NULL;
    int64_t mem_50293_cached_sizze_50962 = 0;
    unsigned char *mem_50293 = NULL;
    int64_t mem_50298_cached_sizze_50963 = 0;
    unsigned char *mem_50298 = NULL;
    int64_t mem_50300_cached_sizze_50964 = 0;
    unsigned char *mem_50300 = NULL;
    int64_t mem_50307_cached_sizze_50965 = 0;
    unsigned char *mem_50307 = NULL;
    int64_t mem_50310_cached_sizze_50966 = 0;
    unsigned char *mem_50310 = NULL;
    int64_t mem_50313_cached_sizze_50967 = 0;
    unsigned char *mem_50313 = NULL;
    int64_t mem_50327_cached_sizze_50968 = 0;
    unsigned char *mem_50327 = NULL;
    int64_t mem_50329_cached_sizze_50969 = 0;
    unsigned char *mem_50329 = NULL;
    int64_t mem_50331_cached_sizze_50970 = 0;
    unsigned char *mem_50331 = NULL;
    int64_t mem_50430_cached_sizze_50971 = 0;
    unsigned char *mem_50430 = NULL;
    int64_t mem_50433_cached_sizze_50972 = 0;
    unsigned char *mem_50433 = NULL;
    int64_t mem_50436_cached_sizze_50973 = 0;
    unsigned char *mem_50436 = NULL;
    int64_t mem_50450_cached_sizze_50974 = 0;
    unsigned char *mem_50450 = NULL;
    int64_t mem_50452_cached_sizze_50975 = 0;
    unsigned char *mem_50452 = NULL;
    int64_t mem_50467_cached_sizze_50976 = 0;
    unsigned char *mem_50467 = NULL;
    int64_t mem_50470_cached_sizze_50977 = 0;
    unsigned char *mem_50470 = NULL;
    int64_t mem_50473_cached_sizze_50978 = 0;
    unsigned char *mem_50473 = NULL;
    int64_t mem_50609_cached_sizze_50979 = 0;
    unsigned char *mem_50609 = NULL;
    int64_t mem_50617_cached_sizze_50980 = 0;
    unsigned char *mem_50617 = NULL;
    int64_t mem_50618_cached_sizze_50981 = 0;
    unsigned char *mem_50618 = NULL;
    int64_t mem_50632_cached_sizze_50982 = 0;
    unsigned char *mem_50632 = NULL;
    int64_t mem_50634_cached_sizze_50983 = 0;
    unsigned char *mem_50634 = NULL;
    int64_t mem_50636_cached_sizze_50984 = 0;
    unsigned char *mem_50636 = NULL;
    int64_t mem_50638_cached_sizze_50985 = 0;
    unsigned char *mem_50638 = NULL;
    int64_t mem_50640_cached_sizze_50986 = 0;
    unsigned char *mem_50640 = NULL;
    struct memblock mem_50643;
    
    mem_50643.references = NULL;
    
    struct memblock mem_param_tmp_50873;
    
    mem_param_tmp_50873.references = NULL;
    
    struct memblock mem_param_tmp_50872;
    
    mem_param_tmp_50872.references = NULL;
    
    struct memblock mem_param_tmp_50871;
    
    mem_param_tmp_50871.references = NULL;
    
    struct memblock mem_50589;
    
    mem_50589.references = NULL;
    
    struct memblock mem_50585;
    
    mem_50585.references = NULL;
    
    struct memblock mem_50581;
    
    mem_50581.references = NULL;
    
    struct memblock mem_50532;
    
    mem_50532.references = NULL;
    
    struct memblock mem_50528;
    
    mem_50528.references = NULL;
    
    struct memblock mem_50524;
    
    mem_50524.references = NULL;
    
    struct memblock mem_50539;
    
    mem_50539.references = NULL;
    
    struct memblock mem_50537;
    
    mem_50537.references = NULL;
    
    struct memblock mem_50535;
    
    mem_50535.references = NULL;
    
    struct memblock ext_mem_50560;
    
    ext_mem_50560.references = NULL;
    
    struct memblock ext_mem_50563;
    
    ext_mem_50563.references = NULL;
    
    struct memblock ext_mem_50566;
    
    ext_mem_50566.references = NULL;
    
    struct memblock mem_param_50427;
    
    mem_param_50427.references = NULL;
    
    struct memblock mem_param_50424;
    
    mem_param_50424.references = NULL;
    
    struct memblock mem_param_50421;
    
    mem_param_50421.references = NULL;
    
    struct memblock ext_mem_50597;
    
    ext_mem_50597.references = NULL;
    
    struct memblock ext_mem_50598;
    
    ext_mem_50598.references = NULL;
    
    struct memblock ext_mem_50599;
    
    ext_mem_50599.references = NULL;
    
    struct memblock mem_50417;
    
    mem_50417.references = NULL;
    
    struct memblock mem_50413;
    
    mem_50413.references = NULL;
    
    struct memblock mem_50409;
    
    mem_50409.references = NULL;
    
    struct memblock ext_mem_50602;
    
    ext_mem_50602.references = NULL;
    
    struct memblock ext_mem_50605;
    
    ext_mem_50605.references = NULL;
    
    struct memblock ext_mem_50608;
    
    ext_mem_50608.references = NULL;
    
    struct memblock mem_50304;
    
    mem_50304.references = NULL;
    
    struct memblock mem_50302;
    
    mem_50302.references = NULL;
    
    struct memblock mem_50295;
    
    mem_50295.references = NULL;
    
    struct memblock mem_out_50838;
    
    mem_out_50838.references = NULL;
    
    int64_t prim_out_50839;
    
    // trmodel.fut:133:36-39
    
    int64_t zp_lhs_48712 = mul64(c_29624, Ax_29625);
    
    // trmodel.fut:133:39-41
    
    int64_t replicate_arg0_48713 = add64((int64_t) 1, zp_lhs_48712);
    
    // trmodel.fut:285:8-51
    
    int64_t binop_x_50257 = (int64_t) 8 * c_29624;
    
    // trmodel.fut:285:8-51
    
    int64_t bytes_50258 = Ax_29625 * binop_x_50257;
    
    // trmodel.fut:285:8-51
    if (mem_50259_cached_sizze_50959 < bytes_50258) {
        err = lexical_realloc(ctx, &mem_50259, &mem_50259_cached_sizze_50959, bytes_50258);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:285:8-51
    if (mem_50262_cached_sizze_50960 < bytes_50258) {
        err = lexical_realloc(ctx, &mem_50262, &mem_50262_cached_sizze_50960, bytes_50258);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:285:8-51
    for (int64_t i_49986 = 0; i_49986 < c_29624; i_49986++) {
        // trmodel.fut:274:10-276:102
        for (int64_t i_49980 = 0; i_49980 < Ax_29625; i_49980++) {
            // trmodel.fut:275:41-43
            
            int64_t zm_rhs_49164 = smod64(i_49980, (int64_t) 2);
            
            // trmodel.fut:275:39-43
            
            int64_t i64_arg0_49165 = sub64((int64_t) 1, zm_rhs_49164);
            
            // trmodel.fut:275:32-43
            
            double i64_res_49166 = sitofp_i64_f64(i64_arg0_49165);
            
            // trmodel.fut:276:71-78
            
            double i64_res_49167 = sitofp_i64_f64(i_49980);
            
            // trmodel.fut:276:57-78
            
            double zt_res_49168 = 0.0 * i64_res_49167;
            
            // trmodel.fut:276:43-78
            
            double zm_res_49169 = 10.0 - zt_res_49168;
            
            // trmodel.fut:276:80-99
            
            double zt_res_49170 = 0.0 * i64_res_49166;
            
            // trmodel.fut:276:56-99
            
            double zm_res_49171 = zm_res_49169 - zt_res_49170;
            
            // trmodel.fut:276:32-99
            
            double exp_res_49172 = futrts_exp64(zm_res_49171);
            
            // trmodel.fut:276:25-100
            
            double zp_res_49173 = 1.0 + exp_res_49172;
            
            // trmodel.fut:276:16-100
            
            double zs_res_49174 = 1.0 / zp_res_49173;
            
            ((double *) mem_50262)[i_49986 * Ax_29625 + i_49980] = zs_res_49174;
        }
        // trmodel.fut:285:42-44
        
        int64_t zt_lhs_49176 = add64((int64_t) 1, i_49986);
        
        // trmodel.fut:285:45-48
        
        int64_t zm_lhs_49177 = mul64(Ax_29625, zt_lhs_49176);
        
        // trmodel.fut:285:48-50
        
        int64_t replicate_arg1_49178 = sub64(zm_lhs_49177, (int64_t) 1);
        
        // trmodel.fut:285:26-50
        for (int64_t nest_i_50843 = 0; nest_i_50843 < Ax_29625; nest_i_50843++) {
            ((int64_t *) mem_50259)[i_49986 * Ax_29625 + nest_i_50843] = replicate_arg1_49178;
        }
    }
    // trmodel.fut:273:8-277:13
    if (mem_50291_cached_sizze_50961 < bytes_50258) {
        err = lexical_realloc(ctx, &mem_50291, &mem_50291_cached_sizze_50961, bytes_50258);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:273:8-277:13
    // trmodel.fut:273:8-277:13
    lmad_copy_8b(ctx, 2, (uint64_t *) mem_50291, (int64_t) 0, (int64_t []) {Ax_29625, (int64_t) 1}, (uint64_t *) mem_50262, (int64_t) 0, (int64_t []) {Ax_29625, (int64_t) 1}, (int64_t []) {c_29624, Ax_29625});
    // trmodel.fut:282:40-283:32
    if (mem_50293_cached_sizze_50962 < (int64_t) 8) {
        err = lexical_realloc(ctx, &mem_50293, &mem_50293_cached_sizze_50962, (int64_t) 8);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:282:40-283:32
    for (int64_t nest_i_50844 = 0; nest_i_50844 < (int64_t) 1; nest_i_50844++) {
        ((double *) mem_50293)[nest_i_50844] = 0.0;
    }
    // trmodel.fut:282:40-283:32
    
    int64_t bytes_50294 = (int64_t) 8 * replicate_arg0_48713;
    
    // trmodel.fut:282:40-283:32
    if (memblock_alloc(ctx, &mem_50295, bytes_50294, "mem_50295")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:282:40-283:32
    
    int64_t tmp_offs_50845 = (int64_t) 0;
    
    // trmodel.fut:282:40-283:32
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_50295.mem, tmp_offs_50845, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_50291, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {zp_lhs_48712});
    tmp_offs_50845 += zp_lhs_48712;
    // trmodel.fut:282:40-283:32
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_50295.mem, tmp_offs_50845, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_50293, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {(int64_t) 1});
    tmp_offs_50845 += (int64_t) 1;
    // trmodel_test.fut:111:16-112:29
    if (mem_50298_cached_sizze_50963 < bytes_50258) {
        err = lexical_realloc(ctx, &mem_50298, &mem_50298_cached_sizze_50963, bytes_50258);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel_test.fut:111:16-112:29
    // trmodel_test.fut:111:16-112:29
    lmad_copy_8b(ctx, 2, (uint64_t *) mem_50298, (int64_t) 0, (int64_t []) {Ax_29625, (int64_t) 1}, (uint64_t *) mem_50259, (int64_t) 0, (int64_t []) {Ax_29625, (int64_t) 1}, (int64_t []) {c_29624, Ax_29625});
    // trmodel_test.fut:111:16-112:29
    if (mem_50300_cached_sizze_50964 < (int64_t) 8) {
        err = lexical_realloc(ctx, &mem_50300, &mem_50300_cached_sizze_50964, (int64_t) 8);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel_test.fut:111:16-112:29
    for (int64_t nest_i_50846 = 0; nest_i_50846 < (int64_t) 1; nest_i_50846++) {
        ((int64_t *) mem_50300)[nest_i_50846] = zp_lhs_48712;
    }
    // trmodel_test.fut:111:16-112:29
    if (memblock_alloc(ctx, &mem_50302, bytes_50294, "mem_50302")) {
        err = 1;
        goto cleanup;
    }
    // trmodel_test.fut:111:16-112:29
    
    int64_t tmp_offs_50847 = (int64_t) 0;
    
    // trmodel_test.fut:111:16-112:29
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_50302.mem, tmp_offs_50847, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_50298, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {zp_lhs_48712});
    tmp_offs_50847 += zp_lhs_48712;
    // trmodel_test.fut:111:16-112:29
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_50302.mem, tmp_offs_50847, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_50300, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {(int64_t) 1});
    tmp_offs_50847 += (int64_t) 1;
    // trmodel.fut:289:25-56
    if (memblock_alloc(ctx, &mem_50304, bytes_50294, "mem_50304")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:289:25-56
    for (int64_t i_50848 = 0; i_50848 < replicate_arg0_48713; i_50848++) {
        int64_t x_50849 = (int64_t) 0 + i_50848 * (int64_t) 1;
        
        ((int64_t *) mem_50304.mem)[i_50848] = x_50849;
    }
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:226:3-265:14
    
    bool cond_46782 = sle64(replicate_arg0_48713, (int64_t) 1);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:231:34-50
    
    int64_t zp_rhs_46783 = sdiv_safe64(zp_lhs_48712, (int64_t) 20);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:231:26-50
    
    int64_t min_num_blocks_46784 = add64((int64_t) 1, zp_rhs_46783);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:184:3-39
    
    bool loop_cond_46785 = slt64((int64_t) 1, min_num_blocks_46784);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:184:3-39
    
    bool smallest_pow_2_geq_than_res_46786;
    int64_t smallest_pow_2_geq_than_res_46787;
    bool loop_while_46788;
    int64_t x_46789;
    
    loop_while_46788 = loop_cond_46785;
    x_46789 = (int64_t) 1;
    while (loop_while_46788) {
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:184:37-39
        
        int64_t loopres_46790 = mul64((int64_t) 2, x_46789);
        
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:184:29-32
        
        bool loop_cond_46791 = slt64(loopres_46790, min_num_blocks_46784);
        bool loop_while_tmp_50850 = loop_cond_46791;
        int64_t x_tmp_50851 = loopres_46790;
        
        loop_while_46788 = loop_while_tmp_50850;
        x_46789 = x_tmp_50851;
    }
    smallest_pow_2_geq_than_res_46786 = loop_while_46788;
    smallest_pow_2_geq_than_res_46787 = x_46789;
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:234:30-42
    
    bool zzero_46792 = smallest_pow_2_geq_than_res_46787 == (int64_t) 0;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:234:30-42
    
    bool nonzzero_46793 = !zzero_46792;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75
    
    bool protect_assert_disj_46794 = cond_46782 || nonzzero_46793;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:234:30-42
    
    bool nonzzero_cert_46795;
    
    if (!protect_assert_disj_46794) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:234:30-42\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:289:8-56\n   #6  trmodel_test.fut:111:16-112:29\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:234:30-42
    
    int64_t zp_rhs_46796 = sdiv_safe64(zp_lhs_48712, smallest_pow_2_geq_than_res_46787);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:234:22-42
    
    int64_t block_sizze_46797 = add64((int64_t) 1, zp_rhs_46796);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
    
    int64_t flat_dim_46798 = smallest_pow_2_geq_than_res_46787 * block_sizze_46797;
    bool x_46799 = !cond_46782;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:238:54-65
    
    int64_t greatest_divisor_leq_than_arg1_46800 = mul64((int64_t) 2, block_sizze_46797);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:11-71
    
    bool cond_46801 = slt64((int64_t) 8, greatest_divisor_leq_than_arg1_46800);
    int64_t d_46802;
    
    if (x_46799) {
        bool x_49586;
        int64_t x_49587;
        bool loop_while_49588;
        int64_t d_49589;
        
        loop_while_49588 = cond_46801;
        d_49589 = (int64_t) 1;
        while (loop_while_49588) {
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:69-71
            
            int64_t loopres_49590 = add64((int64_t) 1, d_49589);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:36-38
            
            bool zzero_49591 = loopres_49590 == (int64_t) 0;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:36-38
            
            bool nonzzero_49592 = !zzero_49591;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:36-38
            
            bool nonzzero_cert_49593;
            
            if (!nonzzero_49592) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:36-38\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:238:5-65\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:289:8-56\n   #7  trmodel_test.fut:111:16-112:29\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:36-38
            
            int64_t zg_lhs_49594 = sdiv64(greatest_divisor_leq_than_arg1_46800, loopres_49590);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:35-64
            
            bool cond_49595 = slt64((int64_t) 8, zg_lhs_49594);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:35-64
            
            bool loop_cond_49596;
            
            if (cond_49595) {
                loop_cond_49596 = 1;
            } else {
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:57-59
                
                int64_t znze_lhs_49597 = smod64(greatest_divisor_leq_than_arg1_46800, loopres_49590);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:60-64
                
                bool loop_cond_f_res_49598 = znze_lhs_49597 == (int64_t) 0;
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:60-64
                
                bool loop_cond_f_res_49599 = !loop_cond_f_res_49598;
                
                loop_cond_49596 = loop_cond_f_res_49599;
            }
            
            bool loop_while_tmp_50852 = loop_cond_49596;
            int64_t d_tmp_50853 = loopres_49590;
            
            loop_while_49588 = loop_while_tmp_50852;
            d_49589 = d_tmp_50853;
        }
        x_49586 = loop_while_49588;
        x_49587 = d_49589;
        d_46802 = x_49587;
    } else {
        d_46802 = (int64_t) 0;
    }
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:191:7-9
    
    bool zzero_46817 = d_46802 == (int64_t) 0;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:191:7-9
    
    bool nonzzero_46818 = !zzero_46817;
    bool protect_assert_disj_46819 = cond_46782 || nonzzero_46818;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:191:7-9
    
    bool nonzzero_cert_46820;
    
    if (!protect_assert_disj_46819) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:191:7-9\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:238:5-65\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:289:8-56\n   #7  trmodel_test.fut:111:16-112:29\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:191:7-9
    
    int64_t greatest_divisor_leq_than_res_46821 = sdiv_safe64(greatest_divisor_leq_than_arg1_46800, d_46802);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:60-64
    
    bool y_46822 = slt64((int64_t) 0, replicate_arg0_48713);
    bool protect_assert_disj_46823 = cond_46782 || y_46822;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:60-64
    
    bool index_certs_46824;
    
    if (!protect_assert_disj_46823) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) replicate_arg0_48713, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:60-64\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:289:8-56\n   #6  trmodel_test.fut:111:16-112:29\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool index_concat_cmp_46825 = sle64(zp_lhs_48712, (int64_t) 0);
    int64_t index_concat_branch_46826;
    
    if (x_46799) {
        bool x_49601 = !index_concat_cmp_46825;
        int64_t new_index_49602 = squot_safe64((int64_t) 0, Ax_29625);
        int64_t binop_y_49603 = Ax_29625 * new_index_49602;
        int64_t new_index_49604 = (int64_t) 0 - binop_y_49603;
        int64_t index_concat_49605;
        
        if (x_49601) {
            int64_t x_49606 = ((int64_t *) mem_50259)[new_index_49602 * Ax_29625 + new_index_49604];
            
            index_concat_49605 = x_49606;
        } else {
            index_concat_49605 = (int64_t) 0;
        }
        
        int64_t x_49607;
        
        if (index_concat_cmp_46825) {
            x_49607 = zp_lhs_48712;
        } else {
            x_49607 = index_concat_49605;
        }
        index_concat_branch_46826 = x_49607;
    } else {
        index_concat_branch_46826 = (int64_t) 0;
    }
    
    double index_concat_branch_46834;
    
    if (x_46799) {
        bool x_49609 = !index_concat_cmp_46825;
        int64_t new_index_49610 = squot_safe64((int64_t) 0, Ax_29625);
        int64_t binop_y_49611 = Ax_29625 * new_index_49610;
        int64_t new_index_49612 = (int64_t) 0 - binop_y_49611;
        double index_concat_49613;
        
        if (x_49609) {
            double x_49614 = ((double *) mem_50262)[new_index_49610 * Ax_29625 + new_index_49612];
            
            index_concat_49613 = x_49614;
        } else {
            index_concat_49613 = 0.0;
        }
        
        double x_49615;
        
        if (index_concat_cmp_46825) {
            x_49615 = 0.0;
        } else {
            x_49615 = index_concat_49613;
        }
        index_concat_branch_46834 = x_49615;
    } else {
        index_concat_branch_46834 = 0.0;
    }
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:18-66
    
    int64_t defunc_0_reduce_res_46842;
    int64_t defunc_0_reduce_res_46843;
    double defunc_0_reduce_res_46844;
    
    if (x_46799) {
        int64_t x_49619;
        int64_t x_49620;
        double x_49621;
        int64_t redout_49989;
        int64_t redout_49990;
        double redout_49991;
        
        redout_49989 = (int64_t) 0;
        redout_49990 = index_concat_branch_46826;
        redout_49991 = index_concat_branch_46834;
        for (int64_t i_49992 = 0; i_49992 < replicate_arg0_48713; i_49992++) {
            bool index_concat_cmp_50238 = sle64(zp_lhs_48712, i_49992);
            int64_t index_concat_branch_50242;
            
            if (index_concat_cmp_50238) {
                index_concat_branch_50242 = zp_lhs_48712;
            } else {
                int64_t new_index_50253 = squot64(i_49992, Ax_29625);
                int64_t binop_y_50255 = Ax_29625 * new_index_50253;
                int64_t new_index_50256 = i_49992 - binop_y_50255;
                int64_t index_concat_50241 = ((int64_t *) mem_50259)[new_index_50253 * Ax_29625 + new_index_50256];
                
                index_concat_branch_50242 = index_concat_50241;
            }
            
            double index_concat_branch_50236;
            
            if (index_concat_cmp_50238) {
                index_concat_branch_50236 = 0.0;
            } else {
                int64_t new_index_50249 = squot64(i_49992, Ax_29625);
                int64_t binop_y_50251 = Ax_29625 * new_index_50249;
                int64_t new_index_50252 = i_49992 - binop_y_50251;
                double index_concat_50235 = ((double *) mem_50262)[new_index_50249 * Ax_29625 + new_index_50252];
                
                index_concat_branch_50236 = index_concat_50235;
            }
            // ../lib/github.com/diku-dk/sparse/mono.fut:75:41-74
            
            bool cond_49631 = slt64(redout_49989, i_49992);
            
            // ../lib/github.com/diku-dk/sparse/mono.fut:75:53-73
            
            bool cond_49632 = redout_49989 == i_49992;
            
            // ../lib/github.com/diku-dk/sparse/mono.fut:75:68-73
            
            bool lifted_lambda_res_f_res_t_res_49633 = sle64(redout_49990, index_concat_branch_50242);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:34-58
            
            bool x_49634 = cond_49632 && lifted_lambda_res_f_res_t_res_49633;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:34-58
            
            bool x_49635 = !cond_49631;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:34-58
            
            bool y_49636 = x_49634 && x_49635;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:34-58
            
            bool lifted_lambda_res_49637 = cond_49631 || y_49636;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:18-66
            
            int64_t defunc_0_op_res_49638;
            
            if (lifted_lambda_res_49637) {
                defunc_0_op_res_49638 = i_49992;
            } else {
                defunc_0_op_res_49638 = redout_49989;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:18-66
            
            int64_t defunc_0_op_res_49639;
            
            if (lifted_lambda_res_49637) {
                defunc_0_op_res_49639 = index_concat_branch_50242;
            } else {
                defunc_0_op_res_49639 = redout_49990;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:18-66
            
            double defunc_0_op_res_49640;
            
            if (lifted_lambda_res_49637) {
                defunc_0_op_res_49640 = index_concat_branch_50236;
            } else {
                defunc_0_op_res_49640 = redout_49991;
            }
            
            int64_t redout_tmp_50854 = defunc_0_op_res_49638;
            int64_t redout_tmp_50855 = defunc_0_op_res_49639;
            double redout_tmp_50856 = defunc_0_op_res_49640;
            
            redout_49989 = redout_tmp_50854;
            redout_49990 = redout_tmp_50855;
            redout_49991 = redout_tmp_50856;
        }
        x_49619 = redout_49989;
        x_49620 = redout_49990;
        x_49621 = redout_49991;
        defunc_0_reduce_res_46842 = x_49619;
        defunc_0_reduce_res_46843 = x_49620;
        defunc_0_reduce_res_46844 = x_49621;
    } else {
        defunc_0_reduce_res_46842 = (int64_t) 0;
        defunc_0_reduce_res_46843 = (int64_t) 0;
        defunc_0_reduce_res_46844 = 0.0;
    }
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
    
    bool bounds_invalid_upwards_46867 = slt64(smallest_pow_2_geq_than_res_46787, (int64_t) 0);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
    
    bool valid_46868 = !bounds_invalid_upwards_46867;
    bool protect_assert_disj_46869 = cond_46782 || valid_46868;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
    
    bool range_valid_c_46870;
    
    if (!protect_assert_disj_46869) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) smallest_pow_2_geq_than_res_46787, " is invalid.", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:289:8-56\n   #6  trmodel_test.fut:111:16-112:29\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:244:19-246:44
    
    bool bounds_invalid_upwards_46871 = slt64(block_sizze_46797, (int64_t) 0);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:244:19-246:44
    
    bool valid_46872 = !bounds_invalid_upwards_46871;
    bool protect_assert_disj_46873 = cond_46782 || valid_46872;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:244:19-246:44
    
    bool range_valid_c_46874;
    
    if (!protect_assert_disj_46873) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) block_sizze_46797, " is invalid.", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:244:19-246:44\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:289:8-56\n   #6  trmodel_test.fut:111:16-112:29\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:163:3-176:6
    
    bool cond_46875 = sle64(block_sizze_46797, (int64_t) 1);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:166:25-27
    
    int64_t tmp_46876 = sub64(block_sizze_46797, (int64_t) 2);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:166:3-176:6
    
    bool bounds_invalid_upwards_46877 = slt64(tmp_46876, (int64_t) 0);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:166:3-176:6
    
    int64_t distance_46878 = add64((int64_t) 1, tmp_46876);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:166:3-176:6
    
    bool valid_46879 = !bounds_invalid_upwards_46877;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
    
    bool protect_assert_disj_46880 = cond_46875 || valid_46879;
    bool protect_assert_disj_46881 = cond_46782 || protect_assert_disj_46880;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:166:3-176:6
    
    bool range_valid_c_46882;
    
    if (!protect_assert_disj_46881) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "...", (long long) tmp_46876, " is invalid.", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:166:3-176:6\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:248:7-37\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:289:8-56\n   #7  trmodel_test.fut:111:16-112:29\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:251:5-262:26
    
    bool loop_cond_46883 = slt64(block_sizze_46797, flat_dim_46798);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:147:30-42
    
    bool zzero_46884 = greatest_divisor_leq_than_res_46821 == (int64_t) 0;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:147:30-42
    
    bool nonzzero_46885 = !zzero_46884;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:265:3-14
    
    bool empty_slice_46886 = replicate_arg0_48713 == (int64_t) 0;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
    
    int64_t binop_x_50305 = (int64_t) 8 * smallest_pow_2_geq_than_res_46787;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
    
    int64_t bytes_50306 = block_sizze_46797 * binop_x_50305;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:244:19-246:44
    
    int64_t bytes_50326 = (int64_t) 8 * block_sizze_46797;
    
    if (cond_46782) {
        if (memblock_set(ctx, &ext_mem_50608, &mem_50304, "mem_50304") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_50605, &mem_50302, "mem_50302") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_50602, &mem_50295, "mem_50295") != 0)
            return 1;
    } else {
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
        if (mem_50307_cached_sizze_50965 < bytes_50306) {
            err = lexical_realloc(ctx, &mem_50307, &mem_50307_cached_sizze_50965, bytes_50306);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
        if (mem_50310_cached_sizze_50966 < bytes_50306) {
            err = lexical_realloc(ctx, &mem_50310, &mem_50310_cached_sizze_50966, bytes_50306);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
        if (mem_50313_cached_sizze_50967 < bytes_50306) {
            err = lexical_realloc(ctx, &mem_50313, &mem_50313_cached_sizze_50967, bytes_50306);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:244:19-246:44
        if (mem_50327_cached_sizze_50968 < bytes_50326) {
            err = lexical_realloc(ctx, &mem_50327, &mem_50327_cached_sizze_50968, bytes_50326);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:244:19-246:44
        if (mem_50329_cached_sizze_50969 < bytes_50326) {
            err = lexical_realloc(ctx, &mem_50329, &mem_50329_cached_sizze_50969, bytes_50326);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:244:19-246:44
        if (mem_50331_cached_sizze_50970 < bytes_50326) {
            err = lexical_realloc(ctx, &mem_50331, &mem_50331_cached_sizze_50970, bytes_50326);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
        for (int64_t i_50009 = 0; i_50009 < smallest_pow_2_geq_than_res_46787; i_50009++) {
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:245:18-29
            
            int64_t zp_lhs_46897 = mul64(block_sizze_46797, i_50009);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:244:19-246:44
            for (int64_t i_49999 = 0; i_49999 < block_sizze_46797; i_49999++) {
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:245:30-33
                
                int64_t k_46902 = add64(zp_lhs_46897, i_49999);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:246:12-44
                
                bool cond_46903 = slt64(k_46902, replicate_arg0_48713);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:246:12-44
                
                int64_t lifted_lambda_res_46904;
                int64_t lifted_lambda_res_46905;
                double lifted_lambda_res_46906;
                
                if (cond_46903) {
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:246:26-30
                    
                    bool x_49647 = sle64((int64_t) 0, k_46902);
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:246:26-30
                    
                    bool bounds_check_49648 = cond_46903 && x_49647;
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:246:26-30
                    
                    bool index_certs_49649;
                    
                    if (!bounds_check_49648) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) k_46902, "] out of bounds for array of shape [", (long long) replicate_arg0_48713, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:246:26-30\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:289:8-56\n   #6  trmodel_test.fut:111:16-112:29\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    bool index_concat_cmp_49650 = sle64(zp_lhs_48712, k_46902);
                    int64_t index_concat_branch_49651;
                    
                    if (index_concat_cmp_49650) {
                        index_concat_branch_49651 = zp_lhs_48712;
                    } else {
                        int64_t new_index_49652 = squot64(k_46902, Ax_29625);
                        int64_t binop_y_49653 = Ax_29625 * new_index_49652;
                        int64_t new_index_49654 = k_46902 - binop_y_49653;
                        int64_t index_concat_49655 = ((int64_t *) mem_50259)[new_index_49652 * Ax_29625 + new_index_49654];
                        
                        index_concat_branch_49651 = index_concat_49655;
                    }
                    
                    double index_concat_branch_49656;
                    
                    if (index_concat_cmp_49650) {
                        index_concat_branch_49656 = 0.0;
                    } else {
                        int64_t new_index_49657 = squot64(k_46902, Ax_29625);
                        int64_t binop_y_49658 = Ax_29625 * new_index_49657;
                        int64_t new_index_49659 = k_46902 - binop_y_49658;
                        double index_concat_49660 = ((double *) mem_50262)[new_index_49657 * Ax_29625 + new_index_49659];
                        
                        index_concat_branch_49656 = index_concat_49660;
                    }
                    lifted_lambda_res_46904 = k_46902;
                    lifted_lambda_res_46905 = index_concat_branch_49651;
                    lifted_lambda_res_46906 = index_concat_branch_49656;
                } else {
                    lifted_lambda_res_46904 = defunc_0_reduce_res_46842;
                    lifted_lambda_res_46905 = defunc_0_reduce_res_46843;
                    lifted_lambda_res_46906 = defunc_0_reduce_res_46844;
                }
                ((int64_t *) mem_50327)[i_49999] = lifted_lambda_res_46904;
                ((int64_t *) mem_50329)[i_49999] = lifted_lambda_res_46905;
                ((double *) mem_50331)[i_49999] = lifted_lambda_res_46906;
            }
            if (!cond_46875) {
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:166:3-176:6
                for (int64_t i_46927 = 0; i_46927 < distance_46878; i_46927++) {
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:34-36
                    
                    int64_t gt_arg1_46931 = add64((int64_t) 1, i_46927);
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37
                    
                    bool x_46932 = sle64((int64_t) 0, gt_arg1_46931);
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37
                    
                    bool y_46933 = slt64(gt_arg1_46931, block_sizze_46797);
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37
                    
                    bool bounds_check_46934 = x_46932 && y_46933;
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37
                    
                    bool index_certs_46935;
                    
                    if (!bounds_check_46934) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) gt_arg1_46931, "] out of bounds for array of shape [", (long long) block_sizze_46797, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:248:7-37\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:289:8-56\n   #7  trmodel_test.fut:111:16-112:29\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30
                    
                    bool y_46938 = slt64(i_46927, block_sizze_46797);
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30
                    
                    bool index_certs_46939;
                    
                    if (!y_46938) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_46927, "] out of bounds for array of shape [", (long long) block_sizze_46797, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:248:7-37\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:289:8-56\n   #7  trmodel_test.fut:111:16-112:29\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37
                    
                    int64_t gt_arg1_46936 = ((int64_t *) mem_50327)[gt_arg1_46931];
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37
                    
                    int64_t gt_arg1_46937 = ((int64_t *) mem_50329)[gt_arg1_46931];
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30
                    
                    int64_t gt_arg0_46940 = ((int64_t *) mem_50327)[i_46927];
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30
                    
                    int64_t gt_arg0_46941 = ((int64_t *) mem_50329)[i_46927];
                    
                    // ../lib/github.com/diku-dk/sparse/mono.fut:75:41-74
                    
                    bool cond_46942 = slt64(gt_arg0_46940, gt_arg1_46936);
                    
                    // ../lib/github.com/diku-dk/sparse/mono.fut:75:53-73
                    
                    bool cond_46943 = gt_arg0_46940 == gt_arg1_46936;
                    
                    // ../lib/github.com/diku-dk/sparse/mono.fut:75:68-73
                    
                    bool lifted_lambda_res_f_res_t_res_46944 = sle64(gt_arg0_46941, gt_arg1_46937);
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:18-25
                    
                    bool x_46945 = cond_46943 && lifted_lambda_res_f_res_t_res_46944;
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:18-25
                    
                    bool x_46946 = !cond_46942;
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:18-25
                    
                    bool y_46947 = x_46945 && x_46946;
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:18-25
                    
                    bool lifted_lambda_res_46948 = cond_46942 || y_46947;
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:16-26
                    
                    bool defunc_0_lifted_gt_res_46949 = !lifted_lambda_res_46948;
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:168:7-174:17
                    
                    bool s_46950;
                    int64_t s_46954;
                    bool loop_while_46955;
                    int64_t j_46959;
                    
                    loop_while_46955 = defunc_0_lifted_gt_res_46949;
                    j_46959 = i_46927;
                    while (loop_while_46955) {
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28
                        
                        bool x_46960 = sle64((int64_t) 0, j_46959);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28
                        
                        bool y_46961 = slt64(j_46959, block_sizze_46797);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28
                        
                        bool bounds_check_46962 = x_46960 && y_46961;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28
                        
                        bool index_certs_46963;
                        
                        if (!bounds_check_46962) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_46959, "] out of bounds for array of shape [", (long long) block_sizze_46797, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:248:7-37\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:289:8-56\n   #7  trmodel_test.fut:111:16-112:29\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:38-40
                        
                        int64_t copy_arg0_46967 = add64((int64_t) 1, j_46959);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41
                        
                        bool x_46968 = sle64((int64_t) 0, copy_arg0_46967);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41
                        
                        bool y_46969 = slt64(copy_arg0_46967, block_sizze_46797);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41
                        
                        bool bounds_check_46970 = x_46968 && y_46969;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41
                        
                        bool index_certs_46971;
                        
                        if (!bounds_check_46970) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) copy_arg0_46967, "] out of bounds for array of shape [", (long long) block_sizze_46797, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:248:7-37\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:289:8-56\n   #7  trmodel_test.fut:111:16-112:29\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28
                        
                        int64_t copy_arg0_46964 = ((int64_t *) mem_50327)[j_46959];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28
                        
                        int64_t copy_arg0_46965 = ((int64_t *) mem_50329)[j_46959];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28
                        
                        double copy_arg0_46966 = ((double *) mem_50331)[j_46959];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41
                        
                        int64_t copy_arg0_46972 = ((int64_t *) mem_50327)[copy_arg0_46967];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41
                        
                        int64_t copy_arg0_46973 = ((int64_t *) mem_50329)[copy_arg0_46967];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41
                        
                        double copy_arg0_46974 = ((double *) mem_50331)[copy_arg0_46967];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:17-41
                        ((int64_t *) mem_50327)[j_46959] = copy_arg0_46972;
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:17-41
                        ((int64_t *) mem_50329)[j_46959] = copy_arg0_46973;
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:17-41
                        ((double *) mem_50331)[j_46959] = copy_arg0_46974;
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:172:17-35
                        ((int64_t *) mem_50327)[copy_arg0_46967] = copy_arg0_46964;
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:172:17-35
                        ((int64_t *) mem_50329)[copy_arg0_46967] = copy_arg0_46965;
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:172:17-35
                        ((double *) mem_50331)[copy_arg0_46967] = copy_arg0_46966;
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:174:14-16
                        
                        int64_t tmp_46981 = sub64(j_46959, (int64_t) 1);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:13-37
                        
                        bool cond_46982 = sle64((int64_t) 0, tmp_46981);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:13-37
                        
                        bool loop_cond_46983;
                        
                        if (cond_46982) {
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30
                            
                            bool y_49663 = slt64(tmp_46981, block_sizze_46797);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30
                            
                            bool bounds_check_49664 = cond_46982 && y_49663;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30
                            
                            bool index_certs_49665;
                            
                            if (!bounds_check_49664) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_46981, "] out of bounds for array of shape [", (long long) block_sizze_46797, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:248:7-37\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:289:8-56\n   #7  trmodel_test.fut:111:16-112:29\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37
                            
                            int64_t gt_arg1_49661 = ((int64_t *) mem_50327)[j_46959];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37
                            
                            int64_t gt_arg1_49662 = ((int64_t *) mem_50329)[j_46959];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30
                            
                            int64_t gt_arg0_49666 = ((int64_t *) mem_50327)[tmp_46981];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30
                            
                            int64_t gt_arg0_49667 = ((int64_t *) mem_50329)[tmp_46981];
                            
                            // ../lib/github.com/diku-dk/sparse/mono.fut:75:41-74
                            
                            bool cond_49668 = slt64(gt_arg0_49666, gt_arg1_49661);
                            
                            // ../lib/github.com/diku-dk/sparse/mono.fut:75:53-73
                            
                            bool cond_49669 = gt_arg0_49666 == gt_arg1_49661;
                            
                            // ../lib/github.com/diku-dk/sparse/mono.fut:75:68-73
                            
                            bool lifted_lambda_res_f_res_t_res_49670 = sle64(gt_arg0_49667, gt_arg1_49662);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:18-25
                            
                            bool x_49671 = cond_49669 && lifted_lambda_res_f_res_t_res_49670;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:18-25
                            
                            bool x_49672 = !cond_49668;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:18-25
                            
                            bool y_49673 = x_49671 && x_49672;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:18-25
                            
                            bool lifted_lambda_res_49674 = cond_49668 || y_49673;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:16-26
                            
                            bool defunc_0_lifted_gt_res_49675 = !lifted_lambda_res_49674;
                            
                            loop_cond_46983 = defunc_0_lifted_gt_res_49675;
                        } else {
                            loop_cond_46983 = 0;
                        }
                        
                        bool loop_while_tmp_50866 = loop_cond_46983;
                        int64_t j_tmp_50870 = tmp_46981;
                        
                        loop_while_46955 = loop_while_tmp_50866;
                        j_46959 = j_tmp_50870;
                    }
                    s_46950 = loop_while_46955;
                    s_46954 = j_46959;
                }
            }
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_50307, i_50009 * block_sizze_46797, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_50331, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {block_sizze_46797});
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_50310, i_50009 * block_sizze_46797, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_50329, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {block_sizze_46797});
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_50313, i_50009 * block_sizze_46797, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_50327, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {block_sizze_46797});
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
        if (memblock_alloc(ctx, &mem_50409, bytes_50306, "mem_50409")) {
            err = 1;
            goto cleanup;
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
        lmad_copy_8b(ctx, 2, (uint64_t *) mem_50409.mem, (int64_t) 0, (int64_t []) {block_sizze_46797, (int64_t) 1}, (uint64_t *) mem_50313, (int64_t) 0, (int64_t []) {block_sizze_46797, (int64_t) 1}, (int64_t []) {smallest_pow_2_geq_than_res_46787, block_sizze_46797});
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
        if (memblock_alloc(ctx, &mem_50413, bytes_50306, "mem_50413")) {
            err = 1;
            goto cleanup;
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
        lmad_copy_8b(ctx, 2, (uint64_t *) mem_50413.mem, (int64_t) 0, (int64_t []) {block_sizze_46797, (int64_t) 1}, (uint64_t *) mem_50310, (int64_t) 0, (int64_t []) {block_sizze_46797, (int64_t) 1}, (int64_t []) {smallest_pow_2_geq_than_res_46787, block_sizze_46797});
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
        if (memblock_alloc(ctx, &mem_50417, bytes_50306, "mem_50417")) {
            err = 1;
            goto cleanup;
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
        lmad_copy_8b(ctx, 2, (uint64_t *) mem_50417.mem, (int64_t) 0, (int64_t []) {block_sizze_46797, (int64_t) 1}, (uint64_t *) mem_50307, (int64_t) 0, (int64_t []) {block_sizze_46797, (int64_t) 1}, (int64_t []) {smallest_pow_2_geq_than_res_46787, block_sizze_46797});
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:251:5-262:26
        
        int64_t data_47002;
        bool data_47003;
        int64_t data_47007;
        int64_t loop_dz2084Uz2082U_47008;
        bool loop_while_47009;
        int64_t stride_47013;
        
        if (memblock_set(ctx, &mem_param_50421, &mem_50409, "mem_50409") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_50424, &mem_50413, "mem_50413") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_50427, &mem_50417, "mem_50417") != 0)
            return 1;
        loop_dz2084Uz2082U_47008 = flat_dim_46798;
        loop_while_47009 = loop_cond_46883;
        stride_47013 = block_sizze_46797;
        while (loop_while_47009) {
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:253:27-35
            
            int64_t next_stride_47014 = mul64((int64_t) 2, stride_47013);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:254:33-46
            
            bool zzero_47015 = next_stride_47014 == (int64_t) 0;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:254:33-46
            
            bool nonzzero_47016 = !zzero_47015;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:254:33-46
            
            bool nonzzero_cert_47017;
            
            if (!nonzzero_47016) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:254:33-46\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:289:8-56\n   #6  trmodel_test.fut:111:16-112:29\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:254:33-46
            
            int64_t num_merges_47018 = sdiv64(flat_dim_46798, next_stride_47014);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool bounds_invalid_upwards_47019 = slt64(num_merges_47018, (int64_t) 0);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool valid_47020 = !bounds_invalid_upwards_47019;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool range_valid_c_47021;
            
            if (!valid_47020) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) num_merges_47018, " is invalid.", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:289:8-56\n   #6  trmodel_test.fut:111:16-112:29\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56
            
            int64_t m_47023 = sub64(next_stride_47014, (int64_t) 1);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56
            
            bool zzero_leq_i_p_m_t_s_47024 = sle64((int64_t) 0, m_47023);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:144:3-155:47
            
            bool cond_47026 = slt64(next_stride_47014, (int64_t) 10);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59
            
            bool protect_assert_disj_47027 = nonzzero_46885 || cond_47026;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:147:30-42
            
            bool nonzzero_cert_47028;
            
            if (!protect_assert_disj_47027) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:147:30-42\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:289:8-56\n   #7  trmodel_test.fut:111:16-112:29\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:147:30-42
            
            int64_t zeze_lhs_47029 = smod_safe64(next_stride_47014, greatest_divisor_leq_than_res_46821);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:147:43-47
            
            bool num_blocks_47030 = zeze_lhs_47029 == (int64_t) 0;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59
            
            bool protect_assert_disj_47031 = cond_47026 || num_blocks_47030;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:147:20-65
            
            bool assert_c_47032;
            
            if (!protect_assert_disj_47031) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "Assertion is false: (n % block_size == 0)", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:147:20-65\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:289:8-56\n   #7  trmodel_test.fut:111:16-112:29\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:147:20-65
            
            int64_t num_blocks_47033 = sdiv_safe64(next_stride_47014, greatest_divisor_leq_than_res_46821);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:15-27
            
            int64_t dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_47034 = add64((int64_t) 1, num_blocks_47033);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:34-41
            
            int64_t j_m_i_47035 = sub64(next_stride_47014, stride_47013);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
            
            int64_t flat_dim_47036 = greatest_divisor_leq_than_res_46821 * num_blocks_47033;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84
            
            bool bounds_invalid_upwards_47037 = slt64(dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_47034, (int64_t) 0);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool empty_slice_47038 = j_m_i_47035 == (int64_t) 0;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            int64_t m_47039 = sub64(j_m_i_47035, (int64_t) 1);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool zzero_lte_i_47040 = sle64((int64_t) 0, stride_47013);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool i_lte_j_47041 = sle64(stride_47013, next_stride_47014);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59
            
            bool empty_slice_47042 = stride_47013 == (int64_t) 0;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59
            
            int64_t m_47043 = sub64(stride_47013, (int64_t) 1);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
            
            bool bounds_invalid_upwards_47044 = slt64(num_blocks_47033, (int64_t) 0);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:15-54
            
            bool cond_47045 = slt64((int64_t) 0, stride_47013);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84
            
            bool valid_47046 = !bounds_invalid_upwards_47037;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            int64_t i_p_m_t_s_47047 = add64(stride_47013, m_47039);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59
            
            bool zzero_leq_i_p_m_t_s_47048 = sle64((int64_t) 0, m_47043);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59
            
            bool i_p_m_t_s_leq_w_47049 = slt64(m_47043, next_stride_47014);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
            
            bool valid_47050 = !bounds_invalid_upwards_47044;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:3-46
            
            bool i_p_m_t_s_leq_w_47051 = slt64(m_47023, flat_dim_47036);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54
            
            bool y_47052 = slt64((int64_t) 0, j_m_i_47035);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool protect_assert_disj_47053 = cond_47026 || valid_47046;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84
            
            bool range_valid_c_47054;
            
            if (!protect_assert_disj_47053) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_47034, " is invalid.", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:289:8-56\n   #7  trmodel_test.fut:111:16-112:29\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool zzero_leq_i_p_m_t_s_47055 = sle64((int64_t) 0, i_p_m_t_s_47047);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool i_p_m_t_s_leq_w_47056 = slt64(i_p_m_t_s_47047, next_stride_47014);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59
            
            bool y_47057 = zzero_leq_i_p_m_t_s_47048 && i_p_m_t_s_leq_w_47049;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool protect_assert_disj_47058 = cond_47026 || valid_47050;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
            
            bool range_valid_c_47059;
            
            if (!protect_assert_disj_47058) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) num_blocks_47033, " is invalid.", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:289:8-56\n   #7  trmodel_test.fut:111:16-112:29\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:3-46
            
            bool y_47060 = zzero_leq_i_p_m_t_s_47024 && i_p_m_t_s_leq_w_47051;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool y_47061 = zzero_lte_i_47040 && i_p_m_t_s_leq_w_47056;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59
            
            bool forwards_ok_47062 = zzero_lte_i_47040 && y_47057;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:3-46
            
            bool ok_or_empty_47063 = zzero_47015 || y_47060;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool protect_assert_disj_47064 = cond_47045 || y_47052;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool y_47065 = zzero_leq_i_p_m_t_s_47055 && y_47061;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59
            
            bool ok_or_empty_47066 = empty_slice_47042 || forwards_ok_47062;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool protect_assert_disj_47067 = cond_47026 || ok_or_empty_47063;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:3-46
            
            bool index_certs_47068;
            
            if (!protect_assert_disj_47067) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) next_stride_47014, "] out of bounds for array of shape [", (long long) flat_dim_47036, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:3-46\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:289:8-56\n   #7  trmodel_test.fut:111:16-112:29\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool loop_not_taken_47069 = !cond_47026;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool protect_assert_disj_47070 = protect_assert_disj_47064 || loop_not_taken_47069;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54
            
            bool index_certs_47071;
            
            if (!protect_assert_disj_47070) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_47035, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:5-43\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:289:8-56\n   #8  trmodel_test.fut:111:16-112:29\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool forwards_ok_47072 = i_lte_j_47041 && y_47065;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool protect_assert_disj_47073 = cond_47026 || ok_or_empty_47066;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59
            
            bool index_certs_47074;
            
            if (!protect_assert_disj_47073) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) stride_47013, "] out of bounds for array of shape [", (long long) next_stride_47014, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:289:8-56\n   #7  trmodel_test.fut:111:16-112:29\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool protect_assert_disj_47075 = ok_or_empty_47066 || loop_not_taken_47069;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:26-33
            
            bool index_certs_47076;
            
            if (!protect_assert_disj_47075) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) stride_47013, "] out of bounds for array of shape [", (long long) next_stride_47014, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:26-33\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:289:8-56\n   #7  trmodel_test.fut:111:16-112:29\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool ok_or_empty_47077 = empty_slice_47038 || forwards_ok_47072;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool protect_assert_disj_47078 = cond_47026 || ok_or_empty_47077;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool index_certs_47079;
            
            if (!protect_assert_disj_47078) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) stride_47013, ":] out of bounds for array of shape [", (long long) next_stride_47014, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:289:8-56\n   #7  trmodel_test.fut:111:16-112:29\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool protect_assert_disj_47080 = loop_not_taken_47069 || ok_or_empty_47077;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:34-41
            
            bool index_certs_47081;
            
            if (!protect_assert_disj_47080) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) stride_47013, ":] out of bounds for array of shape [", (long long) next_stride_47014, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:34-41\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:289:8-56\n   #7  trmodel_test.fut:111:16-112:29\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            int64_t binop_x_50428 = (int64_t) 8 * num_merges_47018;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            int64_t bytes_50429 = next_stride_47014 * binop_x_50428;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56
            
            bool i_lte_j_47025 = sle64((int64_t) 0, next_stride_47014);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            if (mem_50430_cached_sizze_50971 < bytes_50429) {
                err = lexical_realloc(ctx, &mem_50430, &mem_50430_cached_sizze_50971, bytes_50429);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            if (mem_50433_cached_sizze_50972 < bytes_50429) {
                err = lexical_realloc(ctx, &mem_50433, &mem_50433_cached_sizze_50972, bytes_50429);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            if (mem_50436_cached_sizze_50973 < bytes_50429) {
                err = lexical_realloc(ctx, &mem_50436, &mem_50436_cached_sizze_50973, bytes_50429);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84
            
            int64_t bytes_50449 = (int64_t) 8 * dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_47034;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
            
            int64_t binop_x_50465 = (int64_t) 8 * num_blocks_47033;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
            
            int64_t bytes_50466 = greatest_divisor_leq_than_res_46821 * binop_x_50465;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
            
            int64_t bytes_50534 = (int64_t) 16 * stride_47013;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            for (int64_t i_50036 = 0; i_50036 < num_merges_47018; i_50036++) {
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:257:26-39
                
                int64_t start_47086 = mul64(next_stride_47014, i_50036);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                int64_t j_m_i_47087 = sub64(loop_dz2084Uz2082U_47008, start_47086);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool empty_slice_47088 = j_m_i_47087 == (int64_t) 0;
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                int64_t m_47089 = sub64(j_m_i_47087, (int64_t) 1);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                int64_t i_p_m_t_s_47090 = add64(start_47086, m_47089);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool zzero_leq_i_p_m_t_s_47091 = sle64((int64_t) 0, i_p_m_t_s_47090);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool i_p_m_t_s_leq_w_47092 = slt64(i_p_m_t_s_47090, loop_dz2084Uz2082U_47008);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool zzero_lte_i_47093 = sle64((int64_t) 0, start_47086);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool i_lte_j_47094 = sle64(start_47086, loop_dz2084Uz2082U_47008);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool y_47095 = i_p_m_t_s_leq_w_47092 && zzero_lte_i_47093;
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool y_47096 = zzero_leq_i_p_m_t_s_47091 && y_47095;
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool forwards_ok_47097 = i_lte_j_47094 && y_47096;
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool ok_or_empty_47098 = empty_slice_47088 || forwards_ok_47097;
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool index_certs_47099;
                
                if (!ok_or_empty_47098) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) start_47086, ":] out of bounds for array of shape [", (long long) loop_dz2084Uz2082U_47008, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:289:8-56\n   #6  trmodel_test.fut:111:16-112:29\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56
                
                bool i_p_m_t_s_leq_w_47100 = slt64(m_47023, j_m_i_47087);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56
                
                bool y_47101 = zzero_leq_i_p_m_t_s_47024 && i_p_m_t_s_leq_w_47100;
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56
                
                bool forwards_ok_47102 = i_lte_j_47025 && y_47101;
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56
                
                bool ok_or_empty_47103 = zzero_47015 || forwards_ok_47102;
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56
                
                bool index_certs_47104;
                
                if (!ok_or_empty_47103) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) next_stride_47014, "] out of bounds for array of shape [", (long long) j_m_i_47087, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:289:8-56\n   #6  trmodel_test.fut:111:16-112:29\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                if (cond_47026) {
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:15-54
                    
                    int64_t dummy_49712;
                    int64_t dummy_49713;
                    double dummy_49714;
                    
                    if (cond_47045) {
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                        
                        int64_t head_res_49715 = ((int64_t *) mem_param_50421.mem)[start_47086];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                        
                        int64_t head_res_49716 = ((int64_t *) mem_param_50424.mem)[start_47086];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                        
                        double head_res_49717 = ((double *) mem_param_50427.mem)[start_47086];
                        
                        dummy_49712 = head_res_49715;
                        dummy_49713 = head_res_49716;
                        dummy_49714 = head_res_49717;
                    } else {
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                        
                        int64_t index_primexp_49718 = stride_47013 + start_47086;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                        
                        int64_t head_res_49719 = ((int64_t *) mem_param_50421.mem)[index_primexp_49718];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                        
                        int64_t head_res_49720 = ((int64_t *) mem_param_50424.mem)[index_primexp_49718];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                        
                        double head_res_49721 = ((double *) mem_param_50427.mem)[index_primexp_49718];
                        
                        dummy_49712 = head_res_49719;
                        dummy_49713 = head_res_49720;
                        dummy_49714 = head_res_49721;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
                    if (memblock_alloc(ctx, &mem_50535, bytes_50534, "mem_50535")) {
                        err = 1;
                        goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
                    for (int64_t nest_i_50883 = 0; nest_i_50883 < next_stride_47014; nest_i_50883++) {
                        ((int64_t *) mem_50535.mem)[nest_i_50883] = dummy_49712;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
                    if (memblock_alloc(ctx, &mem_50537, bytes_50534, "mem_50537")) {
                        err = 1;
                        goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
                    for (int64_t nest_i_50884 = 0; nest_i_50884 < next_stride_47014; nest_i_50884++) {
                        ((int64_t *) mem_50537.mem)[nest_i_50884] = dummy_49713;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
                    if (memblock_alloc(ctx, &mem_50539, bytes_50534, "mem_50539")) {
                        err = 1;
                        goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
                    for (int64_t nest_i_50885 = 0; nest_i_50885 < next_stride_47014; nest_i_50885++) {
                        ((double *) mem_50539.mem)[nest_i_50885] = dummy_49714;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:5-110:29
                    
                    int64_t data_49725;
                    int64_t i_49730 = (int64_t) 0;
                    
                    for (int64_t k_49729 = 0; k_49729 < next_stride_47014; k_49729++) {
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:103:16-18
                        
                        int64_t j_49734 = sub64(k_49729, i_49730);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:9-108:20
                        
                        bool cond_49735 = j_49734 == j_m_i_47035;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:9-108:20
                        
                        bool cond_49736;
                        
                        if (cond_49735) {
                            cond_49736 = 1;
                        } else {
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:30-59
                            
                            bool cond_49737 = slt64(i_49730, stride_47013);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:30-59
                            
                            bool cond_f_res_49738;
                            
                            if (cond_49737) {
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59
                                
                                bool x_49739 = sle64((int64_t) 0, j_49734);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59
                                
                                bool y_49740 = slt64(j_49734, j_m_i_47035);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59
                                
                                bool bounds_check_49741 = x_49739 && y_49740;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59
                                
                                bool index_certs_49742;
                                
                                if (!bounds_check_49741) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_49734, "] out of bounds for array of shape [", (long long) j_m_i_47035, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:5-43\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:289:8-56\n   #8  trmodel_test.fut:111:16-112:29\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54
                                
                                bool x_49747 = sle64((int64_t) 0, i_49730);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54
                                
                                bool bounds_check_49748 = cond_49737 && x_49747;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54
                                
                                bool index_certs_49749;
                                
                                if (!bounds_check_49748) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_49730, "] out of bounds for array of shape [", (long long) stride_47013, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:5-43\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:289:8-56\n   #8  trmodel_test.fut:111:16-112:29\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59
                                
                                int64_t index_primexp_49743 = stride_47013 + j_49734;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t index_primexp_49744 = start_47086 + index_primexp_49743;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t leq_arg1_49745 = ((int64_t *) mem_param_50421.mem)[index_primexp_49744];
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t leq_arg1_49746 = ((int64_t *) mem_param_50424.mem)[index_primexp_49744];
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t index_primexp_49750 = start_47086 + i_49730;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t leq_arg0_49751 = ((int64_t *) mem_param_50421.mem)[index_primexp_49750];
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t leq_arg0_49752 = ((int64_t *) mem_param_50424.mem)[index_primexp_49750];
                                
                                // ../lib/github.com/diku-dk/sparse/mono.fut:75:41-74
                                
                                bool cond_49753 = slt64(leq_arg0_49751, leq_arg1_49745);
                                
                                // ../lib/github.com/diku-dk/sparse/mono.fut:75:53-73
                                
                                bool cond_49754 = leq_arg0_49751 == leq_arg1_49745;
                                
                                // ../lib/github.com/diku-dk/sparse/mono.fut:75:68-73
                                
                                bool lifted_lambda_res_f_res_t_res_49755 = sle64(leq_arg0_49752, leq_arg1_49746);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:46-59
                                
                                bool x_49756 = cond_49754 && lifted_lambda_res_f_res_t_res_49755;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:46-59
                                
                                bool x_49757 = !cond_49753;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:46-59
                                
                                bool y_49758 = x_49756 && x_49757;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:46-59
                                
                                bool lifted_lambda_res_49759 = cond_49753 || y_49758;
                                
                                cond_f_res_49738 = lifted_lambda_res_49759;
                            } else {
                                cond_f_res_49738 = 0;
                            }
                            cond_49736 = cond_f_res_49738;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:9-108:20
                        
                        int64_t loopres_49760;
                        int64_t loopres_49761;
                        int64_t loopres_49762;
                        double loopres_49763;
                        
                        if (cond_49736) {
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21
                            
                            bool x_49765 = sle64((int64_t) 0, i_49730);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21
                            
                            bool y_49766 = slt64(i_49730, stride_47013);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21
                            
                            bool bounds_check_49767 = x_49765 && y_49766;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21
                            
                            bool index_certs_49768;
                            
                            if (!bounds_check_49767) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_49730, "] out of bounds for array of shape [", (long long) stride_47013, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:5-43\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:289:8-56\n   #8  trmodel_test.fut:111:16-112:29\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:13-15
                            
                            int64_t tmp_49764 = add64((int64_t) 1, i_49730);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t index_primexp_49769 = start_47086 + i_49730;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t tmp_49770 = ((int64_t *) mem_param_50421.mem)[index_primexp_49769];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t tmp_49771 = ((int64_t *) mem_param_50424.mem)[index_primexp_49769];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            double tmp_49772 = ((double *) mem_param_50427.mem)[index_primexp_49769];
                            
                            loopres_49760 = tmp_49764;
                            loopres_49761 = tmp_49770;
                            loopres_49762 = tmp_49771;
                            loopres_49763 = tmp_49772;
                        } else {
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19
                            
                            bool x_49773 = sle64((int64_t) 0, j_49734);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19
                            
                            bool y_49774 = slt64(j_49734, j_m_i_47035);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19
                            
                            bool bounds_check_49775 = x_49773 && y_49774;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19
                            
                            bool index_certs_49776;
                            
                            if (!bounds_check_49775) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_49734, "] out of bounds for array of shape [", (long long) j_m_i_47035, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:5-43\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:289:8-56\n   #8  trmodel_test.fut:111:16-112:29\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59
                            
                            int64_t index_primexp_49777 = stride_47013 + j_49734;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t index_primexp_49778 = start_47086 + index_primexp_49777;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t tmp_49779 = ((int64_t *) mem_param_50421.mem)[index_primexp_49778];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t tmp_49780 = ((int64_t *) mem_param_50424.mem)[index_primexp_49778];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            double tmp_49781 = ((double *) mem_param_50427.mem)[index_primexp_49778];
                            
                            loopres_49760 = i_49730;
                            loopres_49761 = tmp_49779;
                            loopres_49762 = tmp_49780;
                            loopres_49763 = tmp_49781;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:110:11-28
                        ((int64_t *) mem_50535.mem)[k_49729] = loopres_49761;
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:110:11-28
                        ((int64_t *) mem_50537.mem)[k_49729] = loopres_49762;
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:110:11-28
                        ((double *) mem_50539.mem)[k_49729] = loopres_49763;
                        
                        int64_t i_tmp_50886 = loopres_49760;
                        
                        i_49730 = i_tmp_50886;
                    }
                    data_49725 = i_49730;
                    if (memblock_set(ctx, &ext_mem_50566, &mem_50535, "mem_50535") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_50563, &mem_50537, "mem_50537") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_50560, &mem_50539, "mem_50539") != 0)
                        return 1;
                } else {
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84
                    if (mem_50450_cached_sizze_50974 < bytes_50449) {
                        err = lexical_realloc(ctx, &mem_50450, &mem_50450_cached_sizze_50974, bytes_50449);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84
                    if (mem_50452_cached_sizze_50975 < bytes_50449) {
                        err = lexical_realloc(ctx, &mem_50452, &mem_50452_cached_sizze_50975, bytes_50449);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84
                    for (int64_t i_50017 = 0; i_50017 < dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_47034; i_50017++) {
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83
                        
                        int64_t split_count_arg3_47185 = mul64(greatest_divisor_leq_than_res_46821, i_50017);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:32:15-39
                        
                        int64_t min_res_47186 = smin64(stride_47013, split_count_arg3_47185);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:33:15-39
                        
                        int64_t min_res_47187 = smin64(j_m_i_47035, split_count_arg3_47185);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:36:27-37
                        
                        int64_t zm_lhs_47188 = add64(min_res_47186, min_res_47187);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:36:39-46
                        
                        int64_t slack_47189 = sub64(zm_lhs_47188, split_count_arg3_47185);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:37:17-39
                        
                        int64_t min_res_47190 = smin64(min_res_47186, slack_47189);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:38:17-39
                        
                        int64_t min_res_47191 = smin64(min_res_47187, min_res_47190);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:40:32-39
                        
                        int64_t max_arg1_47192 = sub64(min_res_47186, min_res_47191);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:40:15-39
                        
                        int64_t max_res_47193 = smax64((int64_t) 0, max_arg1_47192);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:41:32-39
                        
                        int64_t max_arg1_47194 = sub64(min_res_47187, min_res_47191);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:41:15-39
                        
                        int64_t max_res_47195 = smax64((int64_t) 0, max_arg1_47194);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:43:23-40
                        
                        int64_t zm_lhs_47196 = sub64(split_count_arg3_47185, max_res_47193);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:43:42-59
                        
                        int64_t count_47197 = sub64(zm_lhs_47196, max_res_47195);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:81:5-83:39
                        
                        bool loop_cond_47198 = slt64((int64_t) 0, count_47197);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:81:5-83:39
                        
                        bool defunc_0_split_count_res_47199;
                        int64_t defunc_0_split_count_res_47200;
                        int64_t defunc_0_split_count_res_47201;
                        int64_t defunc_0_split_count_res_47202;
                        int64_t defunc_0_split_count_res_47203;
                        int64_t defunc_0_split_count_res_47204;
                        bool loop_while_47205;
                        int64_t ss_47206;
                        int64_t ss_47207;
                        int64_t tt_47208;
                        int64_t tt_47209;
                        int64_t count_47210;
                        
                        loop_while_47205 = loop_cond_47198;
                        ss_47206 = max_res_47193;
                        ss_47207 = min_res_47186;
                        tt_47208 = max_res_47195;
                        tt_47209 = min_res_47187;
                        count_47210 = count_47197;
                        while (loop_while_47205) {
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:48:11-15
                            
                            int64_t zlze_lhs_47211 = sub64(ss_47207, ss_47206);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:48:5-78:40
                            
                            bool cond_47212 = sle64(zlze_lhs_47211, (int64_t) 0);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38
                            
                            int64_t defunc_0_lifted_step_res_47213;
                            int64_t defunc_0_lifted_step_res_47214;
                            int64_t defunc_0_lifted_step_res_47215;
                            int64_t defunc_0_lifted_step_res_47216;
                            
                            if (cond_47212) {
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:49:24-30
                                
                                int64_t tmp_49785 = add64(tt_47208, count_47210);
                                
                                defunc_0_lifted_step_res_47213 = ss_47206;
                                defunc_0_lifted_step_res_47214 = tmp_49785;
                                defunc_0_lifted_step_res_47215 = tt_47209;
                                defunc_0_lifted_step_res_47216 = (int64_t) 0;
                            } else {
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:50:16-20
                                
                                int64_t zlze_lhs_47218 = sub64(tt_47209, tt_47208);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:50:10-78:40
                                
                                bool cond_47219 = sle64(zlze_lhs_47218, (int64_t) 0);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38
                                
                                int64_t defunc_0_lifted_step_res_f_res_47220;
                                int64_t defunc_0_lifted_step_res_f_res_47221;
                                int64_t defunc_0_lifted_step_res_f_res_47222;
                                int64_t defunc_0_lifted_step_res_f_res_47223;
                                
                                if (cond_47219) {
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:51:12-18
                                    
                                    int64_t tmp_49786 = add64(ss_47206, count_47210);
                                    
                                    defunc_0_lifted_step_res_f_res_47220 = tmp_49786;
                                    defunc_0_lifted_step_res_f_res_47221 = tt_47208;
                                    defunc_0_lifted_step_res_f_res_47222 = tt_47209;
                                    defunc_0_lifted_step_res_f_res_47223 = (int64_t) 0;
                                } else {
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:52:10-78:40
                                    
                                    bool cond_47225 = count_47210 == (int64_t) 1;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38
                                    
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_47226;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_47227;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_47228;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_47229;
                                    
                                    if (cond_47225) {
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:21-27
                                        
                                        bool x_49788 = sle64((int64_t) 0, ss_47206);
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:21-27
                                        
                                        bool y_49789 = slt64(ss_47206, stride_47013);
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:21-27
                                        
                                        bool bounds_check_49790 = x_49788 && y_49789;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:21-27
                                        
                                        bool index_certs_49791;
                                        
                                        if (!bounds_check_49790) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) ss_47206, "] out of bounds for array of shape [", (long long) stride_47013, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:21-27\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:36-83\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #4  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #7  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #8  trmodel.fut:289:8-56\n   #9  trmodel_test.fut:111:16-112:29\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:14-20
                                        
                                        bool x_49795 = sle64((int64_t) 0, tt_47208);
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:14-20
                                        
                                        bool y_49796 = slt64(tt_47208, j_m_i_47035);
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:14-20
                                        
                                        bool bounds_check_49797 = x_49795 && y_49796;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:14-20
                                        
                                        bool index_certs_49798;
                                        
                                        if (!bounds_check_49797) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tt_47208, "] out of bounds for array of shape [", (long long) j_m_i_47035, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:14-20\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:36-83\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #4  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #7  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #8  trmodel.fut:289:8-56\n   #9  trmodel_test.fut:111:16-112:29\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                        
                                        int64_t index_primexp_49792 = start_47086 + ss_47206;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                        
                                        int64_t leq_arg1_49793 = ((int64_t *) mem_param_50421.mem)[index_primexp_49792];
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                        
                                        int64_t leq_arg1_49794 = ((int64_t *) mem_param_50424.mem)[index_primexp_49792];
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84
                                        
                                        int64_t index_primexp_49799 = stride_47013 + tt_47208;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                        
                                        int64_t index_primexp_49800 = start_47086 + index_primexp_49799;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                        
                                        int64_t leq_arg0_49801 = ((int64_t *) mem_param_50421.mem)[index_primexp_49800];
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                        
                                        int64_t leq_arg0_49802 = ((int64_t *) mem_param_50424.mem)[index_primexp_49800];
                                        
                                        // ../lib/github.com/diku-dk/sparse/mono.fut:75:41-74
                                        
                                        bool cond_49803 = slt64(leq_arg0_49801, leq_arg1_49793);
                                        
                                        // ../lib/github.com/diku-dk/sparse/mono.fut:75:53-73
                                        
                                        bool cond_49804 = leq_arg0_49801 == leq_arg1_49793;
                                        
                                        // ../lib/github.com/diku-dk/sparse/mono.fut:75:68-73
                                        
                                        bool lifted_lambda_res_f_res_t_res_49805 = sle64(leq_arg0_49802, leq_arg1_49794);
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:7-56:38
                                        
                                        bool x_49806 = cond_49804 && lifted_lambda_res_f_res_t_res_49805;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:7-56:38
                                        
                                        bool x_49807 = !cond_49803;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:7-56:38
                                        
                                        bool y_49808 = x_49806 && x_49807;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:7-56:38
                                        
                                        bool lifted_lambda_res_49809 = cond_49803 || y_49808;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38
                                        
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_t_res_49810;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_t_res_49811;
                                        
                                        if (lifted_lambda_res_49809) {
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:54:26-28
                                            
                                            int64_t tmp_49812 = add64((int64_t) 1, tt_47208);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_49810 = ss_47206;
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_49811 = tmp_49812;
                                        } else {
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:56:14-16
                                            
                                            int64_t tmp_49813 = add64((int64_t) 1, ss_47206);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_49810 = tmp_49813;
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_49811 = tt_47208;
                                        }
                                        defunc_0_lifted_step_res_f_res_f_res_47226 = defunc_0_lifted_step_res_f_res_f_res_t_res_49810;
                                        defunc_0_lifted_step_res_f_res_f_res_47227 = defunc_0_lifted_step_res_f_res_f_res_t_res_49811;
                                        defunc_0_lifted_step_res_f_res_f_res_47228 = tt_47209;
                                        defunc_0_lifted_step_res_f_res_f_res_47229 = (int64_t) 0;
                                    } else {
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:58:19-22
                                        
                                        int64_t m_47256 = sdiv64(count_47210, (int64_t) 2);
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:59:19-22
                                        
                                        int64_t n_47257 = sub64(count_47210, m_47256);
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:71:7-73:30
                                        
                                        bool cond_47258 = n_47257 == (int64_t) 0;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:72:10-12
                                        
                                        int64_t zgze_lhs_47259 = add64(ss_47206, m_47256);
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:72:13-19
                                        
                                        bool cond_f_res_47260 = sle64(ss_47207, zgze_lhs_47259);
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38
                                        
                                        bool x_47261 = !cond_47258;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38
                                        
                                        bool y_47262 = cond_f_res_47260 && x_47261;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38
                                        
                                        bool cond_47263 = cond_47258 || y_47262;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:71:7-73:30
                                        
                                        bool leq_y_x_47264;
                                        
                                        if (cond_47263) {
                                            leq_y_x_47264 = 1;
                                        } else {
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:22-30
                                            
                                            bool x_47265 = sle64((int64_t) 0, zgze_lhs_47259);
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:22-30
                                            
                                            bool y_47266 = slt64(zgze_lhs_47259, stride_47013);
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:22-30
                                            
                                            bool bounds_check_47267 = x_47265 && y_47266;
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:22-30
                                            
                                            bool index_certs_47268;
                                            
                                            if (!bounds_check_47267) {
                                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) zgze_lhs_47259, "] out of bounds for array of shape [", (long long) stride_47013, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:22-30\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:36-83\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #4  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #7  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #8  trmodel.fut:289:8-56\n   #9  trmodel_test.fut:111:16-112:29\n"));
                                                err = FUTHARK_PROGRAM_ERROR;
                                                goto cleanup;
                                            }
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:16-18
                                            
                                            int64_t zm_lhs_47272 = add64(tt_47208, n_47257);
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:18-20
                                            
                                            int64_t leq_arg0_47273 = sub64(zm_lhs_47272, (int64_t) 1);
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:11-21
                                            
                                            bool x_47274 = sle64((int64_t) 0, leq_arg0_47273);
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:11-21
                                            
                                            bool y_47275 = slt64(leq_arg0_47273, j_m_i_47035);
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:11-21
                                            
                                            bool bounds_check_47276 = x_47274 && y_47275;
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:11-21
                                            
                                            bool index_certs_47277;
                                            
                                            if (!bounds_check_47276) {
                                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) leq_arg0_47273, "] out of bounds for array of shape [", (long long) j_m_i_47035, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:11-21\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:36-83\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #4  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #7  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #8  trmodel.fut:289:8-56\n   #9  trmodel_test.fut:111:16-112:29\n"));
                                                err = FUTHARK_PROGRAM_ERROR;
                                                goto cleanup;
                                            }
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                            
                                            int64_t index_primexp_47269 = start_47086 + zgze_lhs_47259;
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                            
                                            int64_t leq_arg1_47270 = ((int64_t *) mem_param_50421.mem)[index_primexp_47269];
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                            
                                            int64_t leq_arg1_47271 = ((int64_t *) mem_param_50424.mem)[index_primexp_47269];
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84
                                            
                                            int64_t index_primexp_47278 = stride_47013 + leq_arg0_47273;
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                            
                                            int64_t index_primexp_47279 = start_47086 + index_primexp_47278;
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                            
                                            int64_t leq_arg0_47280 = ((int64_t *) mem_param_50421.mem)[index_primexp_47279];
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                            
                                            int64_t leq_arg0_47281 = ((int64_t *) mem_param_50424.mem)[index_primexp_47279];
                                            
                                            // ../lib/github.com/diku-dk/sparse/mono.fut:75:41-74
                                            
                                            bool cond_47282 = slt64(leq_arg0_47280, leq_arg1_47270);
                                            
                                            // ../lib/github.com/diku-dk/sparse/mono.fut:75:53-73
                                            
                                            bool cond_47283 = leq_arg0_47280 == leq_arg1_47270;
                                            
                                            // ../lib/github.com/diku-dk/sparse/mono.fut:75:68-73
                                            
                                            bool lifted_lambda_res_f_res_t_res_47284 = sle64(leq_arg0_47281, leq_arg1_47271);
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:7-30
                                            
                                            bool x_47285 = cond_47283 && lifted_lambda_res_f_res_t_res_47284;
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:7-30
                                            
                                            bool x_47286 = !cond_47282;
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:7-30
                                            
                                            bool y_47287 = x_47285 && x_47286;
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:7-30
                                            
                                            bool lifted_lambda_res_47288 = cond_47282 || y_47287;
                                            
                                            leq_y_x_47264 = lifted_lambda_res_47288;
                                        }
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38
                                        
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_47289;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_47290;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_47291;
                                        
                                        if (leq_y_x_47264) {
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:76:24-26
                                            
                                            int64_t tmp_49814 = add64(tt_47208, n_47257);
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:76:39-41
                                            
                                            int64_t tmp_49815 = sub64(count_47210, n_47257);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_47289 = tmp_49814;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_47290 = tt_47209;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_47291 = tmp_49815;
                                        } else {
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:78:29-31
                                            
                                            int64_t tmp_47294 = add64(tt_47208, n_47257);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_47289 = tt_47208;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_47290 = tmp_47294;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_47291 = count_47210;
                                        }
                                        defunc_0_lifted_step_res_f_res_f_res_47226 = ss_47206;
                                        defunc_0_lifted_step_res_f_res_f_res_47227 = defunc_0_lifted_step_res_f_res_f_res_f_res_47289;
                                        defunc_0_lifted_step_res_f_res_f_res_47228 = defunc_0_lifted_step_res_f_res_f_res_f_res_47290;
                                        defunc_0_lifted_step_res_f_res_f_res_47229 = defunc_0_lifted_step_res_f_res_f_res_f_res_47291;
                                    }
                                    defunc_0_lifted_step_res_f_res_47220 = defunc_0_lifted_step_res_f_res_f_res_47226;
                                    defunc_0_lifted_step_res_f_res_47221 = defunc_0_lifted_step_res_f_res_f_res_47227;
                                    defunc_0_lifted_step_res_f_res_47222 = defunc_0_lifted_step_res_f_res_f_res_47228;
                                    defunc_0_lifted_step_res_f_res_47223 = defunc_0_lifted_step_res_f_res_f_res_47229;
                                }
                                defunc_0_lifted_step_res_47213 = defunc_0_lifted_step_res_f_res_47220;
                                defunc_0_lifted_step_res_47214 = defunc_0_lifted_step_res_f_res_47221;
                                defunc_0_lifted_step_res_47215 = defunc_0_lifted_step_res_f_res_47222;
                                defunc_0_lifted_step_res_47216 = defunc_0_lifted_step_res_f_res_47223;
                            }
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:32:32-39
                            
                            int64_t min_arg1_47295 = add64(defunc_0_lifted_step_res_47213, defunc_0_lifted_step_res_47216);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:32:15-39
                            
                            int64_t min_res_47296 = smin64(ss_47207, min_arg1_47295);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:33:32-39
                            
                            int64_t min_arg1_47297 = add64(defunc_0_lifted_step_res_47214, defunc_0_lifted_step_res_47216);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:33:15-39
                            
                            int64_t min_res_47298 = smin64(defunc_0_lifted_step_res_47215, min_arg1_47297);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:36:21-25
                            
                            int64_t zp_lhs_47299 = sub64(min_res_47296, defunc_0_lifted_step_res_47213);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:36:33-37
                            
                            int64_t zp_rhs_47300 = sub64(min_res_47298, defunc_0_lifted_step_res_47214);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:36:27-37
                            
                            int64_t zm_lhs_47301 = add64(zp_lhs_47299, zp_rhs_47300);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:36:39-46
                            
                            int64_t slack_47302 = sub64(zm_lhs_47301, defunc_0_lifted_step_res_47216);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:37:17-39
                            
                            int64_t min_res_47303 = smin64(zp_lhs_47299, slack_47302);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:38:17-39
                            
                            int64_t min_res_47304 = smin64(zp_rhs_47300, min_res_47303);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:40:32-39
                            
                            int64_t max_arg1_47305 = sub64(min_res_47296, min_res_47304);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:40:15-39
                            
                            int64_t max_res_47306 = smax64(defunc_0_lifted_step_res_47213, max_arg1_47305);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:41:32-39
                            
                            int64_t max_arg1_47307 = sub64(min_res_47298, min_res_47304);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:41:15-39
                            
                            int64_t max_res_47308 = smax64(defunc_0_lifted_step_res_47214, max_arg1_47307);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:43:30-40
                            
                            int64_t zm_rhs_47309 = sub64(max_res_47306, defunc_0_lifted_step_res_47213);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:43:23-40
                            
                            int64_t zm_lhs_47310 = sub64(defunc_0_lifted_step_res_47216, zm_rhs_47309);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:43:49-59
                            
                            int64_t zm_rhs_47311 = sub64(max_res_47308, defunc_0_lifted_step_res_47214);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:43:42-59
                            
                            int64_t count_47312 = sub64(zm_lhs_47310, zm_rhs_47311);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:82:17-20
                            
                            bool loop_cond_47313 = slt64((int64_t) 0, count_47312);
                            bool loop_while_tmp_50892 = loop_cond_47313;
                            int64_t ss_tmp_50893 = max_res_47306;
                            int64_t ss_tmp_50894 = min_res_47296;
                            int64_t tt_tmp_50895 = max_res_47308;
                            int64_t tt_tmp_50896 = min_res_47298;
                            int64_t count_tmp_50897 = count_47312;
                            
                            loop_while_47205 = loop_while_tmp_50892;
                            ss_47206 = ss_tmp_50893;
                            ss_47207 = ss_tmp_50894;
                            tt_47208 = tt_tmp_50895;
                            tt_47209 = tt_tmp_50896;
                            count_47210 = count_tmp_50897;
                        }
                        defunc_0_split_count_res_47199 = loop_while_47205;
                        defunc_0_split_count_res_47200 = ss_47206;
                        defunc_0_split_count_res_47201 = ss_47207;
                        defunc_0_split_count_res_47202 = tt_47208;
                        defunc_0_split_count_res_47203 = tt_47209;
                        defunc_0_split_count_res_47204 = count_47210;
                        ((int64_t *) mem_50450)[i_50017] = defunc_0_split_count_res_47200;
                        ((int64_t *) mem_50452)[i_50017] = defunc_0_split_count_res_47202;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
                    if (mem_50467_cached_sizze_50976 < bytes_50466) {
                        err = lexical_realloc(ctx, &mem_50467, &mem_50467_cached_sizze_50976, bytes_50466);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
                    if (mem_50470_cached_sizze_50977 < bytes_50466) {
                        err = lexical_realloc(ctx, &mem_50470, &mem_50470_cached_sizze_50977, bytes_50466);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
                    if (mem_50473_cached_sizze_50978 < bytes_50466) {
                        err = lexical_realloc(ctx, &mem_50473, &mem_50473_cached_sizze_50978, bytes_50466);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
                    for (int64_t i_50026 = 0; i_50026 < num_blocks_47033; i_50026++) {
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:151:22-34
                        
                        bool y_47320 = slt64(i_50026, dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_47034);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:151:22-34
                        
                        bool index_certs_47322;
                        
                        if (!y_47320) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_50026, "] out of bounds for array of shape [", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_47034, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:151:22-34\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:289:8-56\n   #7  trmodel_test.fut:111:16-112:29\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:151:22-34
                        
                        int64_t defunc_0_f_res_47323 = ((int64_t *) mem_50450)[i_50026];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:151:22-34
                        
                        int64_t defunc_0_f_res_47324 = ((int64_t *) mem_50452)[i_50026];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:152:33-35
                        
                        int64_t tmp_47325 = add64((int64_t) 1, i_50026);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36
                        
                        bool x_47326 = sle64((int64_t) 0, tmp_47325);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36
                        
                        bool y_47327 = slt64(tmp_47325, dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_47034);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36
                        
                        bool bounds_check_47328 = x_47326 && y_47327;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36
                        
                        bool index_certs_47329;
                        
                        if (!bounds_check_47328) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_47325, "] out of bounds for array of shape [", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_47034, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:289:8-56\n   #7  trmodel_test.fut:111:16-112:29\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36
                        
                        int64_t defunc_0_f_res_47330 = ((int64_t *) mem_50450)[tmp_47325];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36
                        
                        int64_t defunc_0_f_res_47331 = ((int64_t *) mem_50452)[tmp_47325];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:45-49
                        
                        int64_t merge_sequential_arg2_47332 = add64(stride_47013, defunc_0_f_res_47324);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:53-57
                        
                        int64_t merge_sequential_arg2_47333 = add64(stride_47013, defunc_0_f_res_47331);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        int64_t j_m_i_47334 = sub64(merge_sequential_arg2_47333, merge_sequential_arg2_47332);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool empty_slice_47335 = j_m_i_47334 == (int64_t) 0;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        int64_t m_47336 = sub64(j_m_i_47334, (int64_t) 1);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        int64_t i_p_m_t_s_47337 = add64(merge_sequential_arg2_47332, m_47336);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool zzero_leq_i_p_m_t_s_47338 = sle64((int64_t) 0, i_p_m_t_s_47337);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool i_p_m_t_s_leq_w_47339 = slt64(i_p_m_t_s_47337, next_stride_47014);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool zzero_lte_i_47340 = sle64((int64_t) 0, merge_sequential_arg2_47332);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool i_lte_j_47341 = sle64(merge_sequential_arg2_47332, merge_sequential_arg2_47333);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool y_47342 = i_p_m_t_s_leq_w_47339 && zzero_lte_i_47340;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool y_47343 = zzero_leq_i_p_m_t_s_47338 && y_47342;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool forwards_ok_47344 = i_lte_j_47341 && y_47343;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool ok_or_empty_47345 = empty_slice_47335 || forwards_ok_47344;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool index_certs_47346;
                        
                        if (!ok_or_empty_47345) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) merge_sequential_arg2_47332, ":", (long long) merge_sequential_arg2_47333, "] out of bounds for array of shape [", (long long) next_stride_47014, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:289:8-56\n   #7  trmodel_test.fut:111:16-112:29\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        int64_t j_m_i_47347 = sub64(defunc_0_f_res_47330, defunc_0_f_res_47323);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool empty_slice_47348 = j_m_i_47347 == (int64_t) 0;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        int64_t m_47349 = sub64(j_m_i_47347, (int64_t) 1);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        int64_t i_p_m_t_s_47350 = add64(defunc_0_f_res_47323, m_47349);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool zzero_leq_i_p_m_t_s_47351 = sle64((int64_t) 0, i_p_m_t_s_47350);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool i_p_m_t_s_leq_w_47352 = slt64(i_p_m_t_s_47350, next_stride_47014);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool zzero_lte_i_47353 = sle64((int64_t) 0, defunc_0_f_res_47323);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool i_lte_j_47354 = sle64(defunc_0_f_res_47323, defunc_0_f_res_47330);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool y_47355 = i_p_m_t_s_leq_w_47352 && zzero_lte_i_47353;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool y_47356 = zzero_leq_i_p_m_t_s_47351 && y_47355;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool forwards_ok_47357 = i_lte_j_47354 && y_47356;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool ok_or_empty_47358 = empty_slice_47348 || forwards_ok_47357;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool index_certs_47359;
                        
                        if (!ok_or_empty_47358) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) defunc_0_f_res_47323, ":", (long long) defunc_0_f_res_47330, "] out of bounds for array of shape [", (long long) next_stride_47014, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:289:8-56\n   #7  trmodel_test.fut:111:16-112:29\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:15-54
                        
                        bool cond_47360 = slt64((int64_t) 0, j_m_i_47347);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:15-54
                        
                        int64_t dummy_47361;
                        int64_t dummy_47362;
                        double dummy_47363;
                        
                        if (cond_47360) {
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:36-42
                            
                            bool index_certs_49816;
                            
                            if (!cond_47360) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_47347, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:36-42\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:8-69\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:289:8-56\n   #8  trmodel_test.fut:111:16-112:29\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t index_primexp_49817 = start_47086 + defunc_0_f_res_47323;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t head_res_49818 = ((int64_t *) mem_param_50421.mem)[index_primexp_49817];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t head_res_49819 = ((int64_t *) mem_param_50424.mem)[index_primexp_49817];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            double head_res_49820 = ((double *) mem_param_50427.mem)[index_primexp_49817];
                            
                            dummy_47361 = head_res_49818;
                            dummy_47362 = head_res_49819;
                            dummy_47363 = head_res_49820;
                        } else {
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54
                            
                            bool y_47369 = slt64((int64_t) 0, j_m_i_47334);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54
                            
                            bool index_certs_47370;
                            
                            if (!y_47369) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_47334, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:8-69\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:289:8-56\n   #8  trmodel_test.fut:111:16-112:29\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t index_primexp_47371 = start_47086 + merge_sequential_arg2_47332;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t head_res_47372 = ((int64_t *) mem_param_50421.mem)[index_primexp_47371];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t head_res_47373 = ((int64_t *) mem_param_50424.mem)[index_primexp_47371];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            double head_res_47374 = ((double *) mem_param_50427.mem)[index_primexp_47371];
                            
                            dummy_47361 = head_res_47372;
                            dummy_47362 = head_res_47373;
                            dummy_47363 = head_res_47374;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
                        for (int64_t nest_i_50901 = 0; nest_i_50901 < greatest_divisor_leq_than_res_46821; nest_i_50901++) {
                            ((int64_t *) mem_50473)[i_50026 * greatest_divisor_leq_than_res_46821 + nest_i_50901] = dummy_47361;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
                        for (int64_t nest_i_50902 = 0; nest_i_50902 < greatest_divisor_leq_than_res_46821; nest_i_50902++) {
                            ((int64_t *) mem_50470)[i_50026 * greatest_divisor_leq_than_res_46821 + nest_i_50902] = dummy_47362;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
                        for (int64_t nest_i_50903 = 0; nest_i_50903 < greatest_divisor_leq_than_res_46821; nest_i_50903++) {
                            ((double *) mem_50467)[i_50026 * greatest_divisor_leq_than_res_46821 + nest_i_50903] = dummy_47363;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:5-110:29
                        
                        int64_t data_47378;
                        int64_t i_47383 = (int64_t) 0;
                        
                        for (int64_t k_47382 = 0; k_47382 < greatest_divisor_leq_than_res_46821; k_47382++) {
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:103:16-18
                            
                            int64_t j_47387 = sub64(k_47382, i_47383);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:9-108:20
                            
                            bool cond_47388 = j_47387 == j_m_i_47334;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:9-108:20
                            
                            bool cond_47389;
                            
                            if (cond_47388) {
                                cond_47389 = 1;
                            } else {
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:30-59
                                
                                bool cond_47390 = slt64(i_47383, j_m_i_47347);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:30-59
                                
                                bool cond_f_res_47391;
                                
                                if (cond_47390) {
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59
                                    
                                    bool x_49821 = sle64((int64_t) 0, j_47387);
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59
                                    
                                    bool y_49822 = slt64(j_47387, j_m_i_47334);
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59
                                    
                                    bool bounds_check_49823 = x_49821 && y_49822;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59
                                    
                                    bool index_certs_49824;
                                    
                                    if (!bounds_check_49823) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_47387, "] out of bounds for array of shape [", (long long) j_m_i_47334, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:8-69\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:289:8-56\n   #8  trmodel_test.fut:111:16-112:29\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54
                                    
                                    bool x_49829 = sle64((int64_t) 0, i_47383);
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54
                                    
                                    bool bounds_check_49830 = cond_47390 && x_49829;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54
                                    
                                    bool index_certs_49831;
                                    
                                    if (!bounds_check_49830) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_47383, "] out of bounds for array of shape [", (long long) j_m_i_47347, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:8-69\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:289:8-56\n   #8  trmodel_test.fut:111:16-112:29\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
                                    
                                    int64_t index_primexp_49825 = merge_sequential_arg2_47332 + j_47387;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                    
                                    int64_t index_primexp_49826 = start_47086 + index_primexp_49825;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                    
                                    int64_t leq_arg1_49827 = ((int64_t *) mem_param_50421.mem)[index_primexp_49826];
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                    
                                    int64_t leq_arg1_49828 = ((int64_t *) mem_param_50424.mem)[index_primexp_49826];
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
                                    
                                    int64_t index_primexp_49832 = defunc_0_f_res_47323 + i_47383;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                    
                                    int64_t index_primexp_49833 = start_47086 + index_primexp_49832;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                    
                                    int64_t leq_arg0_49834 = ((int64_t *) mem_param_50421.mem)[index_primexp_49833];
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                    
                                    int64_t leq_arg0_49835 = ((int64_t *) mem_param_50424.mem)[index_primexp_49833];
                                    
                                    // ../lib/github.com/diku-dk/sparse/mono.fut:75:41-74
                                    
                                    bool cond_49836 = slt64(leq_arg0_49834, leq_arg1_49827);
                                    
                                    // ../lib/github.com/diku-dk/sparse/mono.fut:75:53-73
                                    
                                    bool cond_49837 = leq_arg0_49834 == leq_arg1_49827;
                                    
                                    // ../lib/github.com/diku-dk/sparse/mono.fut:75:68-73
                                    
                                    bool lifted_lambda_res_f_res_t_res_49838 = sle64(leq_arg0_49835, leq_arg1_49828);
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:46-59
                                    
                                    bool x_49839 = cond_49837 && lifted_lambda_res_f_res_t_res_49838;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:46-59
                                    
                                    bool x_49840 = !cond_49836;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:46-59
                                    
                                    bool y_49841 = x_49839 && x_49840;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:46-59
                                    
                                    bool lifted_lambda_res_49842 = cond_49836 || y_49841;
                                    
                                    cond_f_res_47391 = lifted_lambda_res_49842;
                                } else {
                                    cond_f_res_47391 = 0;
                                }
                                cond_47389 = cond_f_res_47391;
                            }
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:9-108:20
                            
                            int64_t loopres_47414;
                            int64_t loopres_47415;
                            int64_t loopres_47416;
                            double loopres_47417;
                            
                            if (cond_47389) {
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21
                                
                                bool x_49844 = sle64((int64_t) 0, i_47383);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21
                                
                                bool y_49845 = slt64(i_47383, j_m_i_47347);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21
                                
                                bool bounds_check_49846 = x_49844 && y_49845;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21
                                
                                bool index_certs_49847;
                                
                                if (!bounds_check_49846) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_47383, "] out of bounds for array of shape [", (long long) j_m_i_47347, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:8-69\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:289:8-56\n   #8  trmodel_test.fut:111:16-112:29\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:13-15
                                
                                int64_t tmp_49843 = add64((int64_t) 1, i_47383);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
                                
                                int64_t index_primexp_49848 = defunc_0_f_res_47323 + i_47383;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t index_primexp_49849 = start_47086 + index_primexp_49848;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t tmp_49850 = ((int64_t *) mem_param_50421.mem)[index_primexp_49849];
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t tmp_49851 = ((int64_t *) mem_param_50424.mem)[index_primexp_49849];
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                double tmp_49852 = ((double *) mem_param_50427.mem)[index_primexp_49849];
                                
                                loopres_47414 = tmp_49843;
                                loopres_47415 = tmp_49850;
                                loopres_47416 = tmp_49851;
                                loopres_47417 = tmp_49852;
                            } else {
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19
                                
                                bool x_47428 = sle64((int64_t) 0, j_47387);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19
                                
                                bool y_47429 = slt64(j_47387, j_m_i_47334);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19
                                
                                bool bounds_check_47430 = x_47428 && y_47429;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19
                                
                                bool index_certs_47431;
                                
                                if (!bounds_check_47430) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_47387, "] out of bounds for array of shape [", (long long) j_m_i_47334, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:8-69\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:289:8-56\n   #8  trmodel_test.fut:111:16-112:29\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
                                
                                int64_t index_primexp_47432 = merge_sequential_arg2_47332 + j_47387;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t index_primexp_47433 = start_47086 + index_primexp_47432;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t tmp_47434 = ((int64_t *) mem_param_50421.mem)[index_primexp_47433];
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t tmp_47435 = ((int64_t *) mem_param_50424.mem)[index_primexp_47433];
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                double tmp_47436 = ((double *) mem_param_50427.mem)[index_primexp_47433];
                                
                                loopres_47414 = i_47383;
                                loopres_47415 = tmp_47434;
                                loopres_47416 = tmp_47435;
                                loopres_47417 = tmp_47436;
                            }
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:110:11-28
                            ((int64_t *) mem_50473)[i_50026 * greatest_divisor_leq_than_res_46821 + k_47382] = loopres_47415;
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:110:11-28
                            ((int64_t *) mem_50470)[i_50026 * greatest_divisor_leq_than_res_46821 + k_47382] = loopres_47416;
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:110:11-28
                            ((double *) mem_50467)[i_50026 * greatest_divisor_leq_than_res_46821 + k_47382] = loopres_47417;
                            
                            int64_t i_tmp_50904 = loopres_47414;
                            
                            i_47383 = i_tmp_50904;
                        }
                        data_47378 = i_47383;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
                    if (memblock_alloc(ctx, &mem_50524, bytes_50466, "mem_50524")) {
                        err = 1;
                        goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
                    lmad_copy_8b(ctx, 2, (uint64_t *) mem_50524.mem, (int64_t) 0, (int64_t []) {greatest_divisor_leq_than_res_46821, (int64_t) 1}, (uint64_t *) mem_50473, (int64_t) 0, (int64_t []) {greatest_divisor_leq_than_res_46821, (int64_t) 1}, (int64_t []) {num_blocks_47033, greatest_divisor_leq_than_res_46821});
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
                    if (memblock_alloc(ctx, &mem_50528, bytes_50466, "mem_50528")) {
                        err = 1;
                        goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
                    lmad_copy_8b(ctx, 2, (uint64_t *) mem_50528.mem, (int64_t) 0, (int64_t []) {greatest_divisor_leq_than_res_46821, (int64_t) 1}, (uint64_t *) mem_50470, (int64_t) 0, (int64_t []) {greatest_divisor_leq_than_res_46821, (int64_t) 1}, (int64_t []) {num_blocks_47033, greatest_divisor_leq_than_res_46821});
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
                    if (memblock_alloc(ctx, &mem_50532, bytes_50466, "mem_50532")) {
                        err = 1;
                        goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
                    lmad_copy_8b(ctx, 2, (uint64_t *) mem_50532.mem, (int64_t) 0, (int64_t []) {greatest_divisor_leq_than_res_46821, (int64_t) 1}, (uint64_t *) mem_50467, (int64_t) 0, (int64_t []) {greatest_divisor_leq_than_res_46821, (int64_t) 1}, (int64_t []) {num_blocks_47033, greatest_divisor_leq_than_res_46821});
                    if (memblock_set(ctx, &ext_mem_50566, &mem_50524, "mem_50524") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_50563, &mem_50528, "mem_50528") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_50560, &mem_50532, "mem_50532") != 0)
                        return 1;
                }
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_50430, i_50036 * next_stride_47014, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_50560.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {next_stride_47014});
                if (memblock_unref(ctx, &ext_mem_50560, "ext_mem_50560") != 0)
                    return 1;
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_50433, i_50036 * next_stride_47014, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_50563.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {next_stride_47014});
                if (memblock_unref(ctx, &ext_mem_50563, "ext_mem_50563") != 0)
                    return 1;
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_50436, i_50036 * next_stride_47014, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_50566.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {next_stride_47014});
                if (memblock_unref(ctx, &ext_mem_50566, "ext_mem_50566") != 0)
                    return 1;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            
            int64_t flat_dim_47446 = next_stride_47014 * num_merges_47018;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            if (memblock_alloc(ctx, &mem_50581, bytes_50429, "mem_50581")) {
                err = 1;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            lmad_copy_8b(ctx, 2, (uint64_t *) mem_50581.mem, (int64_t) 0, (int64_t []) {next_stride_47014, (int64_t) 1}, (uint64_t *) mem_50436, (int64_t) 0, (int64_t []) {next_stride_47014, (int64_t) 1}, (int64_t []) {num_merges_47018, next_stride_47014});
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            if (memblock_alloc(ctx, &mem_50585, bytes_50429, "mem_50585")) {
                err = 1;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            lmad_copy_8b(ctx, 2, (uint64_t *) mem_50585.mem, (int64_t) 0, (int64_t []) {next_stride_47014, (int64_t) 1}, (uint64_t *) mem_50433, (int64_t) 0, (int64_t []) {next_stride_47014, (int64_t) 1}, (int64_t []) {num_merges_47018, next_stride_47014});
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            if (memblock_alloc(ctx, &mem_50589, bytes_50429, "mem_50589")) {
                err = 1;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            lmad_copy_8b(ctx, 2, (uint64_t *) mem_50589.mem, (int64_t) 0, (int64_t []) {next_stride_47014, (int64_t) 1}, (uint64_t *) mem_50430, (int64_t) 0, (int64_t []) {next_stride_47014, (int64_t) 1}, (int64_t []) {num_merges_47018, next_stride_47014});
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:252:18-28
            
            bool loop_cond_47450 = slt64(next_stride_47014, flat_dim_46798);
            
            if (memblock_set(ctx, &mem_param_tmp_50871, &mem_50581, "mem_50581") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_50872, &mem_50585, "mem_50585") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_50873, &mem_50589, "mem_50589") != 0)
                return 1;
            
            int64_t loop_dz2084Uz2082U_tmp_50874 = flat_dim_47446;
            bool loop_while_tmp_50875 = loop_cond_47450;
            int64_t stride_tmp_50879 = next_stride_47014;
            
            if (memblock_set(ctx, &mem_param_50421, &mem_param_tmp_50871, "mem_param_tmp_50871") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_50424, &mem_param_tmp_50872, "mem_param_tmp_50872") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_50427, &mem_param_tmp_50873, "mem_param_tmp_50873") != 0)
                return 1;
            loop_dz2084Uz2082U_47008 = loop_dz2084Uz2082U_tmp_50874;
            loop_while_47009 = loop_while_tmp_50875;
            stride_47013 = stride_tmp_50879;
        }
        if (memblock_set(ctx, &ext_mem_50599, &mem_param_50421, "mem_param_50421") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_50598, &mem_param_50424, "mem_param_50424") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_50597, &mem_param_50427, "mem_param_50427") != 0)
            return 1;
        data_47002 = loop_dz2084Uz2082U_47008;
        data_47003 = loop_while_47009;
        data_47007 = stride_47013;
        if (memblock_unref(ctx, &mem_50409, "mem_50409") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50413, "mem_50413") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50417, "mem_50417") != 0)
            return 1;
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:265:3-14
        
        bool i_p_m_t_s_leq_w_47451 = slt64(zp_lhs_48712, data_47002);
        
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:265:3-14
        
        bool ok_or_empty_47453 = empty_slice_46886 || i_p_m_t_s_leq_w_47451;
        
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:265:3-14
        
        bool index_certs_47454;
        
        if (!ok_or_empty_47453) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) replicate_arg0_48713, "] out of bounds for array of shape [", (long long) data_47002, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:265:3-14\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:289:8-56\n   #6  trmodel_test.fut:111:16-112:29\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        if (memblock_set(ctx, &ext_mem_50608, &ext_mem_50599, "ext_mem_50599") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_50605, &ext_mem_50598, "ext_mem_50598") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_50602, &ext_mem_50597, "ext_mem_50597") != 0)
            return 1;
    }
    if (memblock_unref(ctx, &mem_50295, "mem_50295") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50302, "mem_50302") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50304, "mem_50304") != 0)
        return 1;
    // ../lib/github.com/diku-dk/sparse/mono.fut:79:17-81:38
    if (mem_50609_cached_sizze_50979 < replicate_arg0_48713) {
        err = lexical_realloc(ctx, &mem_50609, &mem_50609_cached_sizze_50979, replicate_arg0_48713);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // ../lib/github.com/diku-dk/sparse/mono.fut:79:17-81:38
    for (int64_t i_50042 = 0; i_50042 < replicate_arg0_48713; i_50042++) {
        int64_t eta_p_49141 = ((int64_t *) ext_mem_50608.mem)[i_50042];
        int64_t eta_p_49142 = ((int64_t *) ext_mem_50605.mem)[i_50042];
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:81:23-38
        
        int64_t zv_lhs_49143 = add64((int64_t) -1, i_50042);
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:81:23-38
        
        int64_t tmp_49144 = smod64(zv_lhs_49143, replicate_arg0_48713);
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:81:23-38
        
        int64_t lifted_lambda_res_49145 = ((int64_t *) ext_mem_50608.mem)[tmp_49144];
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:81:23-38
        
        int64_t lifted_lambda_res_49146 = ((int64_t *) ext_mem_50605.mem)[tmp_49144];
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:79:47-63
        
        bool cond_49149 = eta_p_49141 == lifted_lambda_res_49145;
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:79:47-63
        
        bool cond_49150 = !cond_49149;
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:79:59-63
        
        bool lifted_lambda_res_f_res_49151 = eta_p_49142 == lifted_lambda_res_49146;
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:79:59-63
        
        bool lifted_lambda_res_f_res_49152 = !lifted_lambda_res_f_res_49151;
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:79:17-81:38
        
        bool y_49153 = cond_49149 && lifted_lambda_res_f_res_49152;
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:79:17-81:38
        
        bool lifted_lambda_res_49154 = cond_49150 || y_49153;
        
        ((bool *) mem_50609)[i_50042] = lifted_lambda_res_49154;
    }
    // ../lib/github.com/diku-dk/sparse/mono.fut:82:17-83:27
    
    bool cond_47476 = sle64((int64_t) 1, replicate_arg0_48713);
    
    // ../lib/github.com/diku-dk/sparse/mono.fut:89:18-30
    
    bool loop_not_taken_47477 = !cond_47476;
    
    // ../lib/github.com/diku-dk/sparse/mono.fut:89:18-30
    
    bool protect_assert_disj_47478 = y_46822 || loop_not_taken_47477;
    
    // ../lib/github.com/diku-dk/sparse/mono.fut:82:34-55
    
    bool index_certs_47479;
    
    if (!protect_assert_disj_47478) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) replicate_arg0_48713, "].", "-> #0  ../lib/github.com/diku-dk/sparse/mono.fut:82:34-55\n   #1  ../lib/github.com/diku-dk/sparse/mono.fut:89:21-30\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #3  trmodel.fut:289:8-56\n   #4  trmodel_test.fut:111:16-112:29\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // ../lib/github.com/diku-dk/sparse/mono.fut:82:17-83:27
    if (cond_47476) {
        // ../lib/github.com/diku-dk/sparse/mono.fut:82:34-55
        ((bool *) mem_50609)[(int64_t) 0] = 1;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:21:38-28:71
    if (mem_50617_cached_sizze_50980 < bytes_50294) {
        err = lexical_realloc(ctx, &mem_50617, &mem_50617_cached_sizze_50980, bytes_50294);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:21:38-28:71
    if (mem_50618_cached_sizze_50981 < replicate_arg0_48713) {
        err = lexical_realloc(ctx, &mem_50618, &mem_50618_cached_sizze_50981, replicate_arg0_48713);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:21:38-28:71
    
    int64_t discard_50052;
    int64_t scanacc_50046 = (int64_t) 0;
    
    for (int64_t i_50049 = 0; i_50049 < replicate_arg0_48713; i_50049++) {
        // ../lib/github.com/diku-dk/segmented/segmented.fut:26:22-36
        
        int64_t zv_lhs_48814 = add64((int64_t) 1, i_50049);
        
        // ../lib/github.com/diku-dk/segmented/segmented.fut:26:22-36
        
        int64_t tmp_48815 = smod64(zv_lhs_48814, replicate_arg0_48713);
        
        // ../lib/github.com/diku-dk/segmented/segmented.fut:26:22-36
        
        bool lifted_lambda_res_48816 = ((bool *) mem_50609)[tmp_48815];
        
        // ../lib/github.com/diku-dk/segmented/segmented.fut:28:49-57
        
        int64_t bool_res_48818 = btoi_bool_i64(lifted_lambda_res_48816);
        
        // ../lib/github.com/diku-dk/segmented/segmented.fut:28:66-69
        
        int64_t defunc_0_op_res_47515 = add64(bool_res_48818, scanacc_50046);
        
        ((int64_t *) mem_50617)[i_50049] = defunc_0_op_res_47515;
        ((bool *) mem_50618)[i_50049] = lifted_lambda_res_48816;
        
        int64_t scanacc_tmp_50909 = defunc_0_op_res_47515;
        
        scanacc_50046 = scanacc_tmp_50909;
    }
    discard_50052 = scanacc_50046;
    // ../lib/github.com/diku-dk/segmented/segmented.fut:29:36-60
    
    int64_t num_segments_t_res_47516;
    
    if (y_46822) {
        // ../lib/github.com/diku-dk/sparse/mono.fut:85:8-86:49
        
        bool y_49890 = slt64(zp_lhs_48712, replicate_arg0_48713);
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:85:8-86:49
        
        bool index_certs_49891;
        
        if (!y_49890) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) zp_lhs_48712, "] out of bounds for array of shape [", (long long) replicate_arg0_48713, "].", "-> #0  ../lib/github.com/diku-dk/sparse/mono.fut:85:8-86:49\n   #1  ../lib/github.com/diku-dk/sparse/mono.fut:89:21-30\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #3  trmodel.fut:289:8-56\n   #4  trmodel_test.fut:111:16-112:29\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        // ../lib/github.com/diku-dk/sparse/mono.fut:85:8-86:49
        
        int64_t last_res_49892 = ((int64_t *) mem_50617)[zp_lhs_48712];
        
        num_segments_t_res_47516 = last_res_49892;
    } else {
        num_segments_t_res_47516 = (int64_t) 0;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:29:22-67
    
    int64_t num_segments_47521;
    
    if (y_46822) {
        num_segments_47521 = num_segments_t_res_47516;
    } else {
        num_segments_47521 = (int64_t) 0;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:33:17-42
    
    int64_t bytes_50631 = (int64_t) 8 * num_segments_47521;
    
    // ../lib/github.com/diku-dk/sparse/mono.fut:113:15-48
    
    int64_t bytes_50642 = replicate_arg0_48713 * bytes_50294;
    
    // ../lib/github.com/diku-dk/segmented/segmented.fut:33:17-42
    if (mem_50632_cached_sizze_50982 < bytes_50631) {
        err = lexical_realloc(ctx, &mem_50632, &mem_50632_cached_sizze_50982, bytes_50631);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:33:17-42
    for (int64_t nest_i_50912 = 0; nest_i_50912 < num_segments_47521; nest_i_50912++) {
        ((double *) mem_50632)[nest_i_50912] = 0.0;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:33:17-42
    if (mem_50634_cached_sizze_50983 < bytes_50631) {
        err = lexical_realloc(ctx, &mem_50634, &mem_50634_cached_sizze_50983, bytes_50631);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:33:17-42
    for (int64_t nest_i_50913 = 0; nest_i_50913 < num_segments_47521; nest_i_50913++) {
        ((int64_t *) mem_50634)[nest_i_50913] = (int64_t) 0;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:33:17-42
    if (mem_50636_cached_sizze_50984 < bytes_50631) {
        err = lexical_realloc(ctx, &mem_50636, &mem_50636_cached_sizze_50984, bytes_50631);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:33:17-42
    for (int64_t nest_i_50914 = 0; nest_i_50914 < num_segments_47521; nest_i_50914++) {
        ((int64_t *) mem_50636)[nest_i_50914] = (int64_t) 0;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:37:6-71
    
    bool acc_cert_48825;
    bool acc_cert_48826;
    bool acc_cert_48827;
    
    // ../lib/github.com/diku-dk/segmented/segmented.fut:37:6-71
    
    int64_t inpacc_49879;
    int64_t inpacc_49880;
    double inpacc_49881;
    int64_t inpacc_48978;
    int64_t inpacc_48979;
    double inpacc_48980;
    
    inpacc_48978 = (int64_t) 0;
    inpacc_48979 = (int64_t) 0;
    inpacc_48980 = 0.0;
    for (int64_t i_50106 = 0; i_50106 < replicate_arg0_48713; i_50106++) {
        bool x_50163 = ((bool *) mem_50609)[i_50106];
        int64_t x_50164 = ((int64_t *) ext_mem_50608.mem)[i_50106];
        int64_t x_50165 = ((int64_t *) ext_mem_50605.mem)[i_50106];
        double x_50166 = ((double *) ext_mem_50602.mem)[i_50106];
        
        // ../lib/github.com/diku-dk/segmented/segmented.fut:9:11-13:24
        
        int64_t tmp_50176;
        
        if (x_50163) {
            tmp_50176 = x_50164;
        } else {
            tmp_50176 = (int64_t) 0;
        }
        // ../lib/github.com/diku-dk/segmented/segmented.fut:9:11-13:24
        
        int64_t tmp_50177;
        
        if (x_50163) {
            tmp_50177 = x_50165;
        } else {
            tmp_50177 = (int64_t) 0;
        }
        
        int64_t eta_p_50197 = ((int64_t *) mem_50617)[i_50106];
        bool eta_p_50198 = ((bool *) mem_50618)[i_50106];
        
        // ../lib/github.com/diku-dk/segmented/segmented.fut:9:11-13:24
        
        int64_t tmp_50203;
        
        if (x_50163) {
            tmp_50203 = tmp_50176;
        } else {
            tmp_50203 = inpacc_48978;
        }
        // ../lib/github.com/diku-dk/segmented/segmented.fut:9:11-13:24
        
        int64_t tmp_50204;
        
        if (x_50163) {
            tmp_50204 = tmp_50177;
        } else {
            tmp_50204 = inpacc_48979;
        }
        // ../lib/github.com/diku-dk/segmented/segmented.fut:9:11-13:24
        
        double tmp_50205;
        
        if (x_50163) {
            tmp_50205 = x_50166;
        } else {
            // ../lib/github.com/diku-dk/sparse/mono.fut:85:57-66
            
            double zp_res_50206 = inpacc_48980 + x_50166;
            
            tmp_50205 = zp_res_50206;
        }
        // ../lib/github.com/diku-dk/segmented/segmented.fut:36:19-40
        
        int64_t lifted_index_res_50207;
        
        if (eta_p_50198) {
            // ../lib/github.com/diku-dk/segmented/segmented.fut:36:30-32
            
            int64_t lifted_index_res_t_res_50208 = sub64(eta_p_50197, (int64_t) 1);
            
            lifted_index_res_50207 = lifted_index_res_t_res_50208;
        } else {
            lifted_index_res_50207 = (int64_t) -1;
        }
        // ../lib/github.com/diku-dk/segmented/segmented.fut:37:6-71
        // UpdateAcc
        if (sle64((int64_t) 0, lifted_index_res_50207) && slt64(lifted_index_res_50207, num_segments_47521)) {
            ((int64_t *) mem_50636)[lifted_index_res_50207] = tmp_50203;
        }
        // ../lib/github.com/diku-dk/segmented/segmented.fut:37:6-71
        // UpdateAcc
        if (sle64((int64_t) 0, lifted_index_res_50207) && slt64(lifted_index_res_50207, num_segments_47521)) {
            ((int64_t *) mem_50634)[lifted_index_res_50207] = tmp_50204;
        }
        // ../lib/github.com/diku-dk/segmented/segmented.fut:37:6-71
        // UpdateAcc
        if (sle64((int64_t) 0, lifted_index_res_50207) && slt64(lifted_index_res_50207, num_segments_47521)) {
            ((double *) mem_50632)[lifted_index_res_50207] = tmp_50205;
        }
        // ../lib/github.com/diku-dk/segmented/segmented.fut:9:11-13:24
        
        double tmp_49049;
        
        if (x_50163) {
            tmp_49049 = x_50166;
        } else {
            // ../lib/github.com/diku-dk/sparse/mono.fut:85:57-66
            
            double zp_res_49050 = inpacc_48980 + x_50166;
            
            tmp_49049 = zp_res_49050;
        }
        
        int64_t inpacc_tmp_50915 = tmp_50203;
        int64_t inpacc_tmp_50916 = tmp_50204;
        double inpacc_tmp_50917 = tmp_49049;
        
        inpacc_48978 = inpacc_tmp_50915;
        inpacc_48979 = inpacc_tmp_50916;
        inpacc_48980 = inpacc_tmp_50917;
    }
    inpacc_49879 = inpacc_48978;
    inpacc_49880 = inpacc_48979;
    inpacc_49881 = inpacc_48980;
    if (memblock_unref(ctx, &ext_mem_50602, "ext_mem_50602") != 0)
        return 1;
    if (memblock_unref(ctx, &ext_mem_50605, "ext_mem_50605") != 0)
        return 1;
    if (memblock_unref(ctx, &ext_mem_50608, "ext_mem_50608") != 0)
        return 1;
    // ../lib/github.com/diku-dk/sparse/mono.fut:127:27-47
    if (mem_50638_cached_sizze_50985 < bytes_50294) {
        err = lexical_realloc(ctx, &mem_50638, &mem_50638_cached_sizze_50985, bytes_50294);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // ../lib/github.com/diku-dk/sparse/mono.fut:127:27-47
    for (int64_t nest_i_50921 = 0; nest_i_50921 < replicate_arg0_48713; nest_i_50921++) {
        ((double *) mem_50638)[nest_i_50921] = 0.0;
    }
    // ../lib/github.com/diku-dk/sparse/mono.fut:128:30-43
    if (mem_50640_cached_sizze_50986 < bytes_50294) {
        err = lexical_realloc(ctx, &mem_50640, &mem_50640_cached_sizze_50986, bytes_50294);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // ../lib/github.com/diku-dk/sparse/mono.fut:128:30-43
    for (int64_t nest_i_50922 = 0; nest_i_50922 < replicate_arg0_48713; nest_i_50922++) {
        ((int64_t *) mem_50640)[nest_i_50922] = (int64_t) 0;
    }
    // ../lib/github.com/diku-dk/sparse/mono.fut:127:18-128:50
    
    bool acc_cert_47554;
    bool acc_cert_47563;
    
    // ../lib/github.com/diku-dk/sparse/mono.fut:127:18-128:50
    for (int64_t i_50114 = 0; i_50114 < num_segments_47521; i_50114++) {
        int64_t v_49487 = ((int64_t *) mem_50636)[i_50114];
        double v_49488 = ((double *) mem_50632)[i_50114];
        int64_t v_49490 = ((int64_t *) mem_50634)[i_50114];
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:127:18-54
        // UpdateAcc
        if (sle64((int64_t) 0, v_49487) && slt64(v_49487, replicate_arg0_48713)) {
            ((double *) mem_50638)[v_49487] = v_49488;
        }
        // ../lib/github.com/diku-dk/sparse/mono.fut:128:21-50
        // UpdateAcc
        if (sle64((int64_t) 0, v_49487) && slt64(v_49487, replicate_arg0_48713)) {
            ((int64_t *) mem_50640)[v_49487] = v_49490;
        }
    }
    // ../lib/github.com/diku-dk/sparse/mono.fut:113:15-48
    if (memblock_alloc(ctx, &mem_50643, bytes_50642, "mem_50643")) {
        err = 1;
        goto cleanup;
    }
    // ../lib/github.com/diku-dk/sparse/mono.fut:113:15-48
    for (int64_t nest_i_50925 = 0; nest_i_50925 < replicate_arg0_48713; nest_i_50925++) {
        for (int64_t nest_i_50926 = 0; nest_i_50926 < replicate_arg0_48713; nest_i_50926++) {
            ((double *) mem_50643.mem)[nest_i_50925 * replicate_arg0_48713 + nest_i_50926] = 0.0;
        }
    }
    // ../lib/github.com/diku-dk/sparse/mono.fut:114:10-50
    
    bool acc_cert_48729;
    
    // ../lib/github.com/diku-dk/sparse/mono.fut:114:10-50
    for (int64_t i_50116 = 0; i_50116 < replicate_arg0_48713; i_50116++) {
        int64_t v_48734 = ((int64_t *) mem_50640)[i_50116];
        double v_48735 = ((double *) mem_50638)[i_50116];
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:114:10-50
        // UpdateAcc
        if ((sle64((int64_t) 0, i_50116) && slt64(i_50116, replicate_arg0_48713)) && (sle64((int64_t) 0, v_48734) && slt64(v_48734, replicate_arg0_48713))) {
            ((double *) mem_50643.mem)[i_50116 * replicate_arg0_48713 + v_48734] = v_48735;
        }
    }
    if (memblock_set(ctx, &mem_out_50838, &mem_50643, "mem_50643") != 0)
        return 1;
    prim_out_50839 = replicate_arg0_48713;
    if (memblock_set(ctx, &*mem_out_p_50957, &mem_out_50838, "mem_out_50838") != 0)
        return 1;
    *out_prim_out_50958 = prim_out_50839;
    
  cleanup:
    {
        free(mem_50259);
        free(mem_50262);
        free(mem_50291);
        free(mem_50293);
        free(mem_50298);
        free(mem_50300);
        free(mem_50307);
        free(mem_50310);
        free(mem_50313);
        free(mem_50327);
        free(mem_50329);
        free(mem_50331);
        free(mem_50430);
        free(mem_50433);
        free(mem_50436);
        free(mem_50450);
        free(mem_50452);
        free(mem_50467);
        free(mem_50470);
        free(mem_50473);
        free(mem_50609);
        free(mem_50617);
        free(mem_50618);
        free(mem_50632);
        free(mem_50634);
        free(mem_50636);
        free(mem_50638);
        free(mem_50640);
        if (memblock_unref(ctx, &mem_50643, "mem_50643") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_50873, "mem_param_tmp_50873") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_50872, "mem_param_tmp_50872") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_50871, "mem_param_tmp_50871") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50589, "mem_50589") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50585, "mem_50585") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50581, "mem_50581") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50532, "mem_50532") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50528, "mem_50528") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50524, "mem_50524") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50539, "mem_50539") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50537, "mem_50537") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50535, "mem_50535") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50560, "ext_mem_50560") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50563, "ext_mem_50563") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50566, "ext_mem_50566") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_50427, "mem_param_50427") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_50424, "mem_param_50424") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_50421, "mem_param_50421") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50597, "ext_mem_50597") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50598, "ext_mem_50598") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50599, "ext_mem_50599") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50417, "mem_50417") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50413, "mem_50413") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50409, "mem_50409") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50602, "ext_mem_50602") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50605, "ext_mem_50605") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50608, "ext_mem_50608") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50304, "mem_50304") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50302, "mem_50302") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50295, "mem_50295") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_50838, "mem_out_50838") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_test_bellman(struct futhark_context *ctx, struct memblock *mem_out_p_50987, int64_t *out_prim_out_50988, struct memblock newprices_mem_50257, int64_t c_36762, int64_t n_36763, int64_t Ax_36765)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_50283_cached_sizze_50989 = 0;
    unsigned char *mem_50283 = NULL;
    int64_t mem_50292_cached_sizze_50990 = 0;
    unsigned char *mem_50292 = NULL;
    int64_t mem_50316_cached_sizze_50991 = 0;
    unsigned char *mem_50316 = NULL;
    int64_t mem_50335_cached_sizze_50992 = 0;
    unsigned char *mem_50335 = NULL;
    int64_t mem_50337_cached_sizze_50993 = 0;
    unsigned char *mem_50337 = NULL;
    int64_t mem_50346_cached_sizze_50994 = 0;
    unsigned char *mem_50346 = NULL;
    int64_t mem_50349_cached_sizze_50995 = 0;
    unsigned char *mem_50349 = NULL;
    int64_t mem_50352_cached_sizze_50996 = 0;
    unsigned char *mem_50352 = NULL;
    int64_t mem_50366_cached_sizze_50997 = 0;
    unsigned char *mem_50366 = NULL;
    int64_t mem_50368_cached_sizze_50998 = 0;
    unsigned char *mem_50368 = NULL;
    int64_t mem_50370_cached_sizze_50999 = 0;
    unsigned char *mem_50370 = NULL;
    int64_t mem_50469_cached_sizze_51000 = 0;
    unsigned char *mem_50469 = NULL;
    int64_t mem_50472_cached_sizze_51001 = 0;
    unsigned char *mem_50472 = NULL;
    int64_t mem_50475_cached_sizze_51002 = 0;
    unsigned char *mem_50475 = NULL;
    int64_t mem_50489_cached_sizze_51003 = 0;
    unsigned char *mem_50489 = NULL;
    int64_t mem_50491_cached_sizze_51004 = 0;
    unsigned char *mem_50491 = NULL;
    int64_t mem_50506_cached_sizze_51005 = 0;
    unsigned char *mem_50506 = NULL;
    int64_t mem_50509_cached_sizze_51006 = 0;
    unsigned char *mem_50509 = NULL;
    int64_t mem_50512_cached_sizze_51007 = 0;
    unsigned char *mem_50512 = NULL;
    int64_t mem_50648_cached_sizze_51008 = 0;
    unsigned char *mem_50648 = NULL;
    int64_t mem_50656_cached_sizze_51009 = 0;
    unsigned char *mem_50656 = NULL;
    int64_t mem_50657_cached_sizze_51010 = 0;
    unsigned char *mem_50657 = NULL;
    int64_t mem_50671_cached_sizze_51011 = 0;
    unsigned char *mem_50671 = NULL;
    int64_t mem_50673_cached_sizze_51012 = 0;
    unsigned char *mem_50673 = NULL;
    int64_t mem_50675_cached_sizze_51013 = 0;
    unsigned char *mem_50675 = NULL;
    int64_t mem_50677_cached_sizze_51014 = 0;
    unsigned char *mem_50677 = NULL;
    int64_t mem_50679_cached_sizze_51015 = 0;
    unsigned char *mem_50679 = NULL;
    int64_t mem_50681_cached_sizze_51016 = 0;
    unsigned char *mem_50681 = NULL;
    int64_t mem_50690_cached_sizze_51017 = 0;
    unsigned char *mem_50690 = NULL;
    struct memblock mem_50692;
    
    mem_50692.references = NULL;
    
    struct memblock ext_mem_50313;
    
    ext_mem_50313.references = NULL;
    
    struct memblock mem_50311;
    
    mem_50311.references = NULL;
    
    struct memblock mem_50281;
    
    mem_50281.references = NULL;
    
    struct memblock mem_50279;
    
    mem_50279.references = NULL;
    
    struct memblock mem_50277;
    
    mem_50277.references = NULL;
    
    struct memblock mem_50276;
    
    mem_50276.references = NULL;
    
    struct memblock mem_50275;
    
    mem_50275.references = NULL;
    
    struct memblock mem_50274;
    
    mem_50274.references = NULL;
    
    struct memblock mem_50271;
    
    mem_50271.references = NULL;
    
    struct memblock mem_50268;
    
    mem_50268.references = NULL;
    
    struct memblock mem_50265;
    
    mem_50265.references = NULL;
    
    struct memblock mem_50263;
    
    mem_50263.references = NULL;
    
    struct memblock mem_50261;
    
    mem_50261.references = NULL;
    
    struct memblock mem_50259;
    
    mem_50259.references = NULL;
    
    struct memblock mem_param_tmp_50869;
    
    mem_param_tmp_50869.references = NULL;
    
    struct memblock mem_param_tmp_50868;
    
    mem_param_tmp_50868.references = NULL;
    
    struct memblock mem_param_tmp_50867;
    
    mem_param_tmp_50867.references = NULL;
    
    struct memblock mem_50628;
    
    mem_50628.references = NULL;
    
    struct memblock mem_50624;
    
    mem_50624.references = NULL;
    
    struct memblock mem_50620;
    
    mem_50620.references = NULL;
    
    struct memblock mem_50571;
    
    mem_50571.references = NULL;
    
    struct memblock mem_50567;
    
    mem_50567.references = NULL;
    
    struct memblock mem_50563;
    
    mem_50563.references = NULL;
    
    struct memblock mem_50578;
    
    mem_50578.references = NULL;
    
    struct memblock mem_50576;
    
    mem_50576.references = NULL;
    
    struct memblock mem_50574;
    
    mem_50574.references = NULL;
    
    struct memblock ext_mem_50599;
    
    ext_mem_50599.references = NULL;
    
    struct memblock ext_mem_50602;
    
    ext_mem_50602.references = NULL;
    
    struct memblock ext_mem_50605;
    
    ext_mem_50605.references = NULL;
    
    struct memblock mem_param_50466;
    
    mem_param_50466.references = NULL;
    
    struct memblock mem_param_50463;
    
    mem_param_50463.references = NULL;
    
    struct memblock mem_param_50460;
    
    mem_param_50460.references = NULL;
    
    struct memblock ext_mem_50636;
    
    ext_mem_50636.references = NULL;
    
    struct memblock ext_mem_50637;
    
    ext_mem_50637.references = NULL;
    
    struct memblock ext_mem_50638;
    
    ext_mem_50638.references = NULL;
    
    struct memblock mem_50456;
    
    mem_50456.references = NULL;
    
    struct memblock mem_50452;
    
    mem_50452.references = NULL;
    
    struct memblock mem_50448;
    
    mem_50448.references = NULL;
    
    struct memblock ext_mem_50641;
    
    ext_mem_50641.references = NULL;
    
    struct memblock ext_mem_50644;
    
    ext_mem_50644.references = NULL;
    
    struct memblock ext_mem_50647;
    
    ext_mem_50647.references = NULL;
    
    struct memblock mem_50343;
    
    mem_50343.references = NULL;
    
    struct memblock mem_50341;
    
    mem_50341.references = NULL;
    
    struct memblock mem_50339;
    
    mem_50339.references = NULL;
    
    struct memblock mem_out_50838;
    
    mem_out_50838.references = NULL;
    
    int64_t prim_out_50839;
    
    // trmodel.fut:123:24-46
    
    int64_t bytes_50258 = (int64_t) 8 * n_36763;
    
    // trmodel.fut:126:24-44
    
    int64_t bytes_50262 = (int64_t) 8 * c_36762;
    
    // trmodel_test.fut:167:49-62
    
    int64_t bytes_50267 = c_36762 * bytes_50258;
    
    // trmodel.fut:133:36-39
    
    int64_t zp_lhs_48712 = mul64(c_36762, Ax_36765);
    
    // trmodel.fut:133:39-41
    
    int64_t replicate_arg0_48713 = add64((int64_t) 1, zp_lhs_48712);
    
    // trmodel.fut:134:39-41
    
    int64_t replicate_arg0_48715 = add64((int64_t) 2, zp_lhs_48712);
    
    // trmodel.fut:180:61-65
    
    int64_t dzlz7bUZLzmZRz20UAxz20U1z7dUzg_46739 = sub64(Ax_36765, (int64_t) 1);
    
    // trmodel.fut:180:28-68
    
    int64_t bytes_50282 = (int64_t) 8 * dzlz7bUZLzmZRz20UAxz20U1z7dUzg_46739;
    
    // trmodel.fut:180:75-181:53
    
    int64_t bytes_50291 = Ax_36765 * bytes_50262;
    
    // trmodel_test.fut:168:7-171:57
    
    int64_t binop_x_50309 = (int64_t) 8 * Ax_36765;
    
    // trmodel_test.fut:168:7-171:57
    
    int64_t bytes_50310 = c_36762 * binop_x_50309;
    
    // trmodel.fut:367:8-370:41
    if (mem_50316_cached_sizze_50991 < bytes_50291) {
        err = lexical_realloc(ctx, &mem_50316, &mem_50316_cached_sizze_50991, bytes_50291);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:367:8-370:41
    for (int64_t i_49998 = 0; i_49998 < c_36762; i_49998++) {
        // trmodel.fut:367:8-370:41
        for (int64_t i_49994 = 0; i_49994 < Ax_36765; i_49994++) {
            // trmodel.fut:368:28-370:41
            
            bool cond_46763 = i_49994 == dzlz7bUZLzmZRz20UAxz20U1z7dUzg_46739;
            
            // trmodel.fut:368:28-370:41
            
            int64_t lifted_lambda_res_46764;
            
            if (cond_46763) {
                // trmodel.fut:369:34-37
                
                int64_t lifted_lambda_res_t_res_49594 = mul64(Ax_36765, i_49998);
                
                lifted_lambda_res_46764 = lifted_lambda_res_t_res_49594;
            } else {
                // trmodel.fut:370:34-37
                
                int64_t zp_lhs_46766 = mul64(Ax_36765, i_49998);
                
                // trmodel.fut:370:37-39
                
                int64_t zp_lhs_46767 = add64(zp_lhs_46766, i_49994);
                
                // trmodel.fut:370:39-41
                
                int64_t lifted_lambda_res_f_res_46768 = add64((int64_t) 1, zp_lhs_46767);
                
                lifted_lambda_res_46764 = lifted_lambda_res_f_res_46768;
            }
            ((int64_t *) mem_50316)[i_49998 * Ax_36765 + i_49994] = lifted_lambda_res_46764;
        }
    }
    // trmodel_test.fut:168:7-172:30
    if (mem_50335_cached_sizze_50992 < bytes_50291) {
        err = lexical_realloc(ctx, &mem_50335, &mem_50335_cached_sizze_50992, bytes_50291);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel_test.fut:168:7-172:30
    // trmodel_test.fut:168:7-172:30
    lmad_copy_8b(ctx, 2, (uint64_t *) mem_50335, (int64_t) 0, (int64_t []) {Ax_36765, (int64_t) 1}, (uint64_t *) mem_50316, (int64_t) 0, (int64_t []) {Ax_36765, (int64_t) 1}, (int64_t []) {c_36762, Ax_36765});
    // trmodel_test.fut:168:7-172:30
    if (mem_50337_cached_sizze_50993 < (int64_t) 8) {
        err = lexical_realloc(ctx, &mem_50337, &mem_50337_cached_sizze_50993, (int64_t) 8);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel_test.fut:168:7-172:30
    for (int64_t nest_i_50842 = 0; nest_i_50842 < (int64_t) 1; nest_i_50842++) {
        ((int64_t *) mem_50337)[nest_i_50842] = zp_lhs_48712;
    }
    // trmodel_test.fut:168:7-172:30
    
    int64_t bytes_50338 = (int64_t) 8 * replicate_arg0_48713;
    
    // trmodel_test.fut:168:7-172:30
    if (memblock_alloc(ctx, &mem_50339, bytes_50338, "mem_50339")) {
        err = 1;
        goto cleanup;
    }
    // trmodel_test.fut:168:7-172:30
    
    int64_t tmp_offs_50843 = (int64_t) 0;
    
    // trmodel_test.fut:168:7-172:30
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_50339.mem, tmp_offs_50843, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_50335, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {zp_lhs_48712});
    tmp_offs_50843 += zp_lhs_48712;
    // trmodel_test.fut:168:7-172:30
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_50339.mem, tmp_offs_50843, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_50337, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {(int64_t) 1});
    tmp_offs_50843 += (int64_t) 1;
    // trmodel.fut:375:36-84
    if (memblock_alloc(ctx, &mem_50341, bytes_50338, "mem_50341")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:375:36-84
    for (int64_t i_50844 = 0; i_50844 < replicate_arg0_48713; i_50844++) {
        int64_t x_50845 = (int64_t) 0 + i_50844 * (int64_t) 1;
        
        ((int64_t *) mem_50341.mem)[i_50844] = x_50845;
    }
    // trmodel.fut:375:36-84
    if (memblock_alloc(ctx, &mem_50343, bytes_50338, "mem_50343")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:375:36-84
    for (int64_t nest_i_50846 = 0; nest_i_50846 < replicate_arg0_48713; nest_i_50846++) {
        ((double *) mem_50343.mem)[nest_i_50846] = 1.0;
    }
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:226:3-265:14
    
    bool cond_46777 = sle64(replicate_arg0_48713, (int64_t) 1);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:231:34-50
    
    int64_t zp_rhs_46778 = sdiv_safe64(zp_lhs_48712, (int64_t) 20);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:231:26-50
    
    int64_t min_num_blocks_46779 = add64((int64_t) 1, zp_rhs_46778);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:184:3-39
    
    bool loop_cond_46780 = slt64((int64_t) 1, min_num_blocks_46779);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:184:3-39
    
    bool smallest_pow_2_geq_than_res_46781;
    int64_t smallest_pow_2_geq_than_res_46782;
    bool loop_while_46783;
    int64_t x_46784;
    
    loop_while_46783 = loop_cond_46780;
    x_46784 = (int64_t) 1;
    while (loop_while_46783) {
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:184:37-39
        
        int64_t loopres_46785 = mul64((int64_t) 2, x_46784);
        
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:184:29-32
        
        bool loop_cond_46786 = slt64(loopres_46785, min_num_blocks_46779);
        bool loop_while_tmp_50847 = loop_cond_46786;
        int64_t x_tmp_50848 = loopres_46785;
        
        loop_while_46783 = loop_while_tmp_50847;
        x_46784 = x_tmp_50848;
    }
    smallest_pow_2_geq_than_res_46781 = loop_while_46783;
    smallest_pow_2_geq_than_res_46782 = x_46784;
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:234:30-42
    
    bool zzero_46787 = smallest_pow_2_geq_than_res_46782 == (int64_t) 0;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:234:30-42
    
    bool nonzzero_46788 = !zzero_46787;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75
    
    bool protect_assert_disj_46789 = cond_46777 || nonzzero_46788;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:234:30-42
    
    bool nonzzero_cert_46790;
    
    if (!protect_assert_disj_46789) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:234:30-42\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:375:19-85\n   #6  trmodel_test.fut:168:7-172:30\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:234:30-42
    
    int64_t zp_rhs_46791 = sdiv_safe64(zp_lhs_48712, smallest_pow_2_geq_than_res_46782);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:234:22-42
    
    int64_t block_sizze_46792 = add64((int64_t) 1, zp_rhs_46791);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
    
    int64_t flat_dim_46793 = smallest_pow_2_geq_than_res_46782 * block_sizze_46792;
    bool x_46794 = !cond_46777;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:238:54-65
    
    int64_t greatest_divisor_leq_than_arg1_46795 = mul64((int64_t) 2, block_sizze_46792);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:11-71
    
    bool cond_46796 = slt64((int64_t) 8, greatest_divisor_leq_than_arg1_46795);
    int64_t d_46797;
    
    if (x_46794) {
        bool x_49596;
        int64_t x_49597;
        bool loop_while_49598;
        int64_t d_49599;
        
        loop_while_49598 = cond_46796;
        d_49599 = (int64_t) 1;
        while (loop_while_49598) {
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:69-71
            
            int64_t loopres_49600 = add64((int64_t) 1, d_49599);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:36-38
            
            bool zzero_49601 = loopres_49600 == (int64_t) 0;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:36-38
            
            bool nonzzero_49602 = !zzero_49601;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:36-38
            
            bool nonzzero_cert_49603;
            
            if (!nonzzero_49602) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:36-38\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:238:5-65\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:168:7-172:30\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:36-38
            
            int64_t zg_lhs_49604 = sdiv64(greatest_divisor_leq_than_arg1_46795, loopres_49600);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:35-64
            
            bool cond_49605 = slt64((int64_t) 8, zg_lhs_49604);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:35-64
            
            bool loop_cond_49606;
            
            if (cond_49605) {
                loop_cond_49606 = 1;
            } else {
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:57-59
                
                int64_t znze_lhs_49607 = smod64(greatest_divisor_leq_than_arg1_46795, loopres_49600);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:60-64
                
                bool loop_cond_f_res_49608 = znze_lhs_49607 == (int64_t) 0;
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:60-64
                
                bool loop_cond_f_res_49609 = !loop_cond_f_res_49608;
                
                loop_cond_49606 = loop_cond_f_res_49609;
            }
            
            bool loop_while_tmp_50849 = loop_cond_49606;
            int64_t d_tmp_50850 = loopres_49600;
            
            loop_while_49598 = loop_while_tmp_50849;
            d_49599 = d_tmp_50850;
        }
        x_49596 = loop_while_49598;
        x_49597 = d_49599;
        d_46797 = x_49597;
    } else {
        d_46797 = (int64_t) 0;
    }
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:191:7-9
    
    bool zzero_46812 = d_46797 == (int64_t) 0;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:191:7-9
    
    bool nonzzero_46813 = !zzero_46812;
    bool protect_assert_disj_46814 = cond_46777 || nonzzero_46813;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:191:7-9
    
    bool nonzzero_cert_46815;
    
    if (!protect_assert_disj_46814) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:191:7-9\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:238:5-65\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:168:7-172:30\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:191:7-9
    
    int64_t greatest_divisor_leq_than_res_46816 = sdiv_safe64(greatest_divisor_leq_than_arg1_46795, d_46797);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:60-64
    
    bool y_46817 = slt64((int64_t) 0, replicate_arg0_48713);
    bool protect_assert_disj_46818 = cond_46777 || y_46817;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:60-64
    
    bool index_certs_46819;
    
    if (!protect_assert_disj_46818) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) replicate_arg0_48713, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:60-64\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:375:19-85\n   #6  trmodel_test.fut:168:7-172:30\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool index_concat_cmp_46820 = sle64(zp_lhs_48712, (int64_t) 0);
    int64_t index_concat_branch_46821;
    
    if (x_46794) {
        bool x_49611 = !index_concat_cmp_46820;
        int64_t new_index_49612 = squot_safe64((int64_t) 0, Ax_36765);
        int64_t binop_y_49613 = Ax_36765 * new_index_49612;
        int64_t new_index_49614 = (int64_t) 0 - binop_y_49613;
        int64_t index_concat_49615;
        
        if (x_49611) {
            int64_t x_49616 = ((int64_t *) mem_50316)[new_index_49612 * Ax_36765 + new_index_49614];
            
            index_concat_49615 = x_49616;
        } else {
            index_concat_49615 = (int64_t) 0;
        }
        
        int64_t x_49617;
        
        if (index_concat_cmp_46820) {
            x_49617 = zp_lhs_48712;
        } else {
            x_49617 = index_concat_49615;
        }
        index_concat_branch_46821 = x_49617;
    } else {
        index_concat_branch_46821 = (int64_t) 0;
    }
    
    int64_t defunc_0_reduce_res_46829;
    int64_t defunc_0_reduce_res_46830;
    
    if (x_46794) {
        int64_t x_49621;
        int64_t x_49622;
        int64_t redout_50000;
        int64_t redout_50001;
        
        redout_50000 = (int64_t) 0;
        redout_50001 = index_concat_branch_46821;
        for (int64_t i_50003 = 0; i_50003 < replicate_arg0_48713; i_50003++) {
            bool index_concat_cmp_50232 = sle64(zp_lhs_48712, i_50003);
            int64_t index_concat_branch_50236;
            
            if (index_concat_cmp_50232) {
                index_concat_branch_50236 = zp_lhs_48712;
            } else {
                int64_t new_index_50249 = squot64(i_50003, Ax_36765);
                int64_t binop_y_50251 = Ax_36765 * new_index_50249;
                int64_t new_index_50252 = i_50003 - binop_y_50251;
                int64_t index_concat_50235 = ((int64_t *) mem_50316)[new_index_50249 * Ax_36765 + new_index_50252];
                
                index_concat_branch_50236 = index_concat_50235;
            }
            // ../lib/github.com/diku-dk/sparse/mono.fut:75:41-74
            
            bool cond_49633 = slt64(redout_50000, i_50003);
            
            // ../lib/github.com/diku-dk/sparse/mono.fut:75:53-73
            
            bool cond_49634 = redout_50000 == i_50003;
            
            // ../lib/github.com/diku-dk/sparse/mono.fut:75:68-73
            
            bool lifted_lambda_res_f_res_t_res_49635 = sle64(redout_50001, index_concat_branch_50236);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:34-58
            
            bool x_49636 = cond_49634 && lifted_lambda_res_f_res_t_res_49635;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:34-58
            
            bool x_49637 = !cond_49633;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:34-58
            
            bool y_49638 = x_49636 && x_49637;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:34-58
            
            bool lifted_lambda_res_49639 = cond_49633 || y_49638;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:18-66
            
            int64_t defunc_0_op_res_49640;
            
            if (lifted_lambda_res_49639) {
                defunc_0_op_res_49640 = i_50003;
            } else {
                defunc_0_op_res_49640 = redout_50000;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:18-66
            
            int64_t defunc_0_op_res_49641;
            
            if (lifted_lambda_res_49639) {
                defunc_0_op_res_49641 = index_concat_branch_50236;
            } else {
                defunc_0_op_res_49641 = redout_50001;
            }
            
            int64_t redout_tmp_50851 = defunc_0_op_res_49640;
            int64_t redout_tmp_50852 = defunc_0_op_res_49641;
            
            redout_50000 = redout_tmp_50851;
            redout_50001 = redout_tmp_50852;
        }
        x_49621 = redout_50000;
        x_49622 = redout_50001;
        defunc_0_reduce_res_46829 = x_49621;
        defunc_0_reduce_res_46830 = x_49622;
    } else {
        defunc_0_reduce_res_46829 = (int64_t) 0;
        defunc_0_reduce_res_46830 = (int64_t) 0;
    }
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
    
    bool bounds_invalid_upwards_46854 = slt64(smallest_pow_2_geq_than_res_46782, (int64_t) 0);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
    
    bool valid_46855 = !bounds_invalid_upwards_46854;
    bool protect_assert_disj_46856 = cond_46777 || valid_46855;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
    
    bool range_valid_c_46857;
    
    if (!protect_assert_disj_46856) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) smallest_pow_2_geq_than_res_46782, " is invalid.", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:375:19-85\n   #6  trmodel_test.fut:168:7-172:30\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:244:19-246:44
    
    bool bounds_invalid_upwards_46858 = slt64(block_sizze_46792, (int64_t) 0);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:244:19-246:44
    
    bool valid_46859 = !bounds_invalid_upwards_46858;
    bool protect_assert_disj_46860 = cond_46777 || valid_46859;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:244:19-246:44
    
    bool range_valid_c_46861;
    
    if (!protect_assert_disj_46860) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) block_sizze_46792, " is invalid.", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:244:19-246:44\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:375:19-85\n   #6  trmodel_test.fut:168:7-172:30\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:163:3-176:6
    
    bool cond_46862 = sle64(block_sizze_46792, (int64_t) 1);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:166:25-27
    
    int64_t tmp_46863 = sub64(block_sizze_46792, (int64_t) 2);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:166:3-176:6
    
    bool bounds_invalid_upwards_46864 = slt64(tmp_46863, (int64_t) 0);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:166:3-176:6
    
    int64_t distance_46865 = add64((int64_t) 1, tmp_46863);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:166:3-176:6
    
    bool valid_46866 = !bounds_invalid_upwards_46864;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
    
    bool protect_assert_disj_46867 = cond_46862 || valid_46866;
    bool protect_assert_disj_46868 = cond_46777 || protect_assert_disj_46867;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:166:3-176:6
    
    bool range_valid_c_46869;
    
    if (!protect_assert_disj_46868) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "...", (long long) tmp_46863, " is invalid.", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:166:3-176:6\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:248:7-37\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:168:7-172:30\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:251:5-262:26
    
    bool loop_cond_46870 = slt64(block_sizze_46792, flat_dim_46793);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:147:30-42
    
    bool zzero_46871 = greatest_divisor_leq_than_res_46816 == (int64_t) 0;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:147:30-42
    
    bool nonzzero_46872 = !zzero_46871;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:265:3-14
    
    bool empty_slice_46873 = replicate_arg0_48713 == (int64_t) 0;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
    
    int64_t binop_x_50344 = (int64_t) 8 * smallest_pow_2_geq_than_res_46782;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
    
    int64_t bytes_50345 = block_sizze_46792 * binop_x_50344;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:244:19-246:44
    
    int64_t bytes_50365 = (int64_t) 8 * block_sizze_46792;
    
    if (cond_46777) {
        if (memblock_set(ctx, &ext_mem_50647, &mem_50341, "mem_50341") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_50644, &mem_50339, "mem_50339") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_50641, &mem_50343, "mem_50343") != 0)
            return 1;
    } else {
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
        if (mem_50346_cached_sizze_50994 < bytes_50345) {
            err = lexical_realloc(ctx, &mem_50346, &mem_50346_cached_sizze_50994, bytes_50345);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
        if (mem_50349_cached_sizze_50995 < bytes_50345) {
            err = lexical_realloc(ctx, &mem_50349, &mem_50349_cached_sizze_50995, bytes_50345);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
        if (mem_50352_cached_sizze_50996 < bytes_50345) {
            err = lexical_realloc(ctx, &mem_50352, &mem_50352_cached_sizze_50996, bytes_50345);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:244:19-246:44
        if (mem_50366_cached_sizze_50997 < bytes_50365) {
            err = lexical_realloc(ctx, &mem_50366, &mem_50366_cached_sizze_50997, bytes_50365);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:244:19-246:44
        if (mem_50368_cached_sizze_50998 < bytes_50365) {
            err = lexical_realloc(ctx, &mem_50368, &mem_50368_cached_sizze_50998, bytes_50365);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:244:19-246:44
        if (mem_50370_cached_sizze_50999 < bytes_50365) {
            err = lexical_realloc(ctx, &mem_50370, &mem_50370_cached_sizze_50999, bytes_50365);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
        for (int64_t i_50020 = 0; i_50020 < smallest_pow_2_geq_than_res_46782; i_50020++) {
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:245:18-29
            
            int64_t zp_lhs_46884 = mul64(block_sizze_46792, i_50020);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:244:19-246:44
            for (int64_t i_50010 = 0; i_50010 < block_sizze_46792; i_50010++) {
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:245:30-33
                
                int64_t k_46889 = add64(zp_lhs_46884, i_50010);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:246:12-44
                
                bool cond_46890 = slt64(k_46889, replicate_arg0_48713);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:246:12-44
                
                int64_t lifted_lambda_res_46891;
                int64_t lifted_lambda_res_46892;
                double lifted_lambda_res_46893;
                
                if (cond_46890) {
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:246:26-30
                    
                    bool x_49649 = sle64((int64_t) 0, k_46889);
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:246:26-30
                    
                    bool bounds_check_49650 = cond_46890 && x_49649;
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:246:26-30
                    
                    bool index_certs_49651;
                    
                    if (!bounds_check_49650) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) k_46889, "] out of bounds for array of shape [", (long long) replicate_arg0_48713, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:246:26-30\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:375:19-85\n   #6  trmodel_test.fut:168:7-172:30\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    bool index_concat_cmp_49652 = sle64(zp_lhs_48712, k_46889);
                    int64_t index_concat_branch_49653;
                    
                    if (index_concat_cmp_49652) {
                        index_concat_branch_49653 = zp_lhs_48712;
                    } else {
                        int64_t new_index_49654 = squot64(k_46889, Ax_36765);
                        int64_t binop_y_49655 = Ax_36765 * new_index_49654;
                        int64_t new_index_49656 = k_46889 - binop_y_49655;
                        int64_t index_concat_49657 = ((int64_t *) mem_50316)[new_index_49654 * Ax_36765 + new_index_49656];
                        
                        index_concat_branch_49653 = index_concat_49657;
                    }
                    lifted_lambda_res_46891 = k_46889;
                    lifted_lambda_res_46892 = index_concat_branch_49653;
                    lifted_lambda_res_46893 = 1.0;
                } else {
                    lifted_lambda_res_46891 = defunc_0_reduce_res_46829;
                    lifted_lambda_res_46892 = defunc_0_reduce_res_46830;
                    lifted_lambda_res_46893 = 1.0;
                }
                ((int64_t *) mem_50366)[i_50010] = lifted_lambda_res_46891;
                ((int64_t *) mem_50368)[i_50010] = lifted_lambda_res_46892;
                ((double *) mem_50370)[i_50010] = lifted_lambda_res_46893;
            }
            if (!cond_46862) {
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:166:3-176:6
                for (int64_t i_46909 = 0; i_46909 < distance_46865; i_46909++) {
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:34-36
                    
                    int64_t gt_arg1_46913 = add64((int64_t) 1, i_46909);
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37
                    
                    bool x_46914 = sle64((int64_t) 0, gt_arg1_46913);
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37
                    
                    bool y_46915 = slt64(gt_arg1_46913, block_sizze_46792);
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37
                    
                    bool bounds_check_46916 = x_46914 && y_46915;
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37
                    
                    bool index_certs_46917;
                    
                    if (!bounds_check_46916) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) gt_arg1_46913, "] out of bounds for array of shape [", (long long) block_sizze_46792, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:248:7-37\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:168:7-172:30\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30
                    
                    bool y_46920 = slt64(i_46909, block_sizze_46792);
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30
                    
                    bool index_certs_46921;
                    
                    if (!y_46920) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_46909, "] out of bounds for array of shape [", (long long) block_sizze_46792, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:248:7-37\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:168:7-172:30\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37
                    
                    int64_t gt_arg1_46918 = ((int64_t *) mem_50366)[gt_arg1_46913];
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37
                    
                    int64_t gt_arg1_46919 = ((int64_t *) mem_50368)[gt_arg1_46913];
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30
                    
                    int64_t gt_arg0_46922 = ((int64_t *) mem_50366)[i_46909];
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30
                    
                    int64_t gt_arg0_46923 = ((int64_t *) mem_50368)[i_46909];
                    
                    // ../lib/github.com/diku-dk/sparse/mono.fut:75:41-74
                    
                    bool cond_46924 = slt64(gt_arg0_46922, gt_arg1_46918);
                    
                    // ../lib/github.com/diku-dk/sparse/mono.fut:75:53-73
                    
                    bool cond_46925 = gt_arg0_46922 == gt_arg1_46918;
                    
                    // ../lib/github.com/diku-dk/sparse/mono.fut:75:68-73
                    
                    bool lifted_lambda_res_f_res_t_res_46926 = sle64(gt_arg0_46923, gt_arg1_46919);
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:18-25
                    
                    bool x_46927 = cond_46925 && lifted_lambda_res_f_res_t_res_46926;
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:18-25
                    
                    bool x_46928 = !cond_46924;
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:18-25
                    
                    bool y_46929 = x_46927 && x_46928;
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:18-25
                    
                    bool lifted_lambda_res_46930 = cond_46924 || y_46929;
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:16-26
                    
                    bool defunc_0_lifted_gt_res_46931 = !lifted_lambda_res_46930;
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:168:7-174:17
                    
                    bool s_46932;
                    int64_t s_46936;
                    bool loop_while_46937;
                    int64_t j_46941;
                    
                    loop_while_46937 = defunc_0_lifted_gt_res_46931;
                    j_46941 = i_46909;
                    while (loop_while_46937) {
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28
                        
                        bool x_46942 = sle64((int64_t) 0, j_46941);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28
                        
                        bool y_46943 = slt64(j_46941, block_sizze_46792);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28
                        
                        bool bounds_check_46944 = x_46942 && y_46943;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28
                        
                        bool index_certs_46945;
                        
                        if (!bounds_check_46944) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_46941, "] out of bounds for array of shape [", (long long) block_sizze_46792, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:248:7-37\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:168:7-172:30\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:38-40
                        
                        int64_t copy_arg0_46949 = add64((int64_t) 1, j_46941);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41
                        
                        bool x_46950 = sle64((int64_t) 0, copy_arg0_46949);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41
                        
                        bool y_46951 = slt64(copy_arg0_46949, block_sizze_46792);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41
                        
                        bool bounds_check_46952 = x_46950 && y_46951;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41
                        
                        bool index_certs_46953;
                        
                        if (!bounds_check_46952) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) copy_arg0_46949, "] out of bounds for array of shape [", (long long) block_sizze_46792, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:248:7-37\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:168:7-172:30\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28
                        
                        int64_t copy_arg0_46946 = ((int64_t *) mem_50366)[j_46941];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28
                        
                        int64_t copy_arg0_46947 = ((int64_t *) mem_50368)[j_46941];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28
                        
                        double copy_arg0_46948 = ((double *) mem_50370)[j_46941];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41
                        
                        int64_t copy_arg0_46954 = ((int64_t *) mem_50366)[copy_arg0_46949];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41
                        
                        int64_t copy_arg0_46955 = ((int64_t *) mem_50368)[copy_arg0_46949];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41
                        
                        double copy_arg0_46956 = ((double *) mem_50370)[copy_arg0_46949];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:17-41
                        ((int64_t *) mem_50366)[j_46941] = copy_arg0_46954;
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:17-41
                        ((int64_t *) mem_50368)[j_46941] = copy_arg0_46955;
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:17-41
                        ((double *) mem_50370)[j_46941] = copy_arg0_46956;
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:172:17-35
                        ((int64_t *) mem_50366)[copy_arg0_46949] = copy_arg0_46946;
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:172:17-35
                        ((int64_t *) mem_50368)[copy_arg0_46949] = copy_arg0_46947;
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:172:17-35
                        ((double *) mem_50370)[copy_arg0_46949] = copy_arg0_46948;
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:174:14-16
                        
                        int64_t tmp_46963 = sub64(j_46941, (int64_t) 1);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:13-37
                        
                        bool cond_46964 = sle64((int64_t) 0, tmp_46963);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:13-37
                        
                        bool loop_cond_46965;
                        
                        if (cond_46964) {
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30
                            
                            bool y_49660 = slt64(tmp_46963, block_sizze_46792);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30
                            
                            bool bounds_check_49661 = cond_46964 && y_49660;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30
                            
                            bool index_certs_49662;
                            
                            if (!bounds_check_49661) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_46963, "] out of bounds for array of shape [", (long long) block_sizze_46792, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:248:7-37\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:168:7-172:30\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37
                            
                            int64_t gt_arg1_49658 = ((int64_t *) mem_50366)[j_46941];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37
                            
                            int64_t gt_arg1_49659 = ((int64_t *) mem_50368)[j_46941];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30
                            
                            int64_t gt_arg0_49663 = ((int64_t *) mem_50366)[tmp_46963];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30
                            
                            int64_t gt_arg0_49664 = ((int64_t *) mem_50368)[tmp_46963];
                            
                            // ../lib/github.com/diku-dk/sparse/mono.fut:75:41-74
                            
                            bool cond_49665 = slt64(gt_arg0_49663, gt_arg1_49658);
                            
                            // ../lib/github.com/diku-dk/sparse/mono.fut:75:53-73
                            
                            bool cond_49666 = gt_arg0_49663 == gt_arg1_49658;
                            
                            // ../lib/github.com/diku-dk/sparse/mono.fut:75:68-73
                            
                            bool lifted_lambda_res_f_res_t_res_49667 = sle64(gt_arg0_49664, gt_arg1_49659);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:18-25
                            
                            bool x_49668 = cond_49666 && lifted_lambda_res_f_res_t_res_49667;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:18-25
                            
                            bool x_49669 = !cond_49665;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:18-25
                            
                            bool y_49670 = x_49668 && x_49669;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:18-25
                            
                            bool lifted_lambda_res_49671 = cond_49665 || y_49670;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:16-26
                            
                            bool defunc_0_lifted_gt_res_49672 = !lifted_lambda_res_49671;
                            
                            loop_cond_46965 = defunc_0_lifted_gt_res_49672;
                        } else {
                            loop_cond_46965 = 0;
                        }
                        
                        bool loop_while_tmp_50862 = loop_cond_46965;
                        int64_t j_tmp_50866 = tmp_46963;
                        
                        loop_while_46937 = loop_while_tmp_50862;
                        j_46941 = j_tmp_50866;
                    }
                    s_46932 = loop_while_46937;
                    s_46936 = j_46941;
                }
            }
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_50346, i_50020 * block_sizze_46792, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_50370, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {block_sizze_46792});
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_50349, i_50020 * block_sizze_46792, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_50368, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {block_sizze_46792});
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_50352, i_50020 * block_sizze_46792, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_50366, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {block_sizze_46792});
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
        if (memblock_alloc(ctx, &mem_50448, bytes_50345, "mem_50448")) {
            err = 1;
            goto cleanup;
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
        lmad_copy_8b(ctx, 2, (uint64_t *) mem_50448.mem, (int64_t) 0, (int64_t []) {block_sizze_46792, (int64_t) 1}, (uint64_t *) mem_50352, (int64_t) 0, (int64_t []) {block_sizze_46792, (int64_t) 1}, (int64_t []) {smallest_pow_2_geq_than_res_46782, block_sizze_46792});
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
        if (memblock_alloc(ctx, &mem_50452, bytes_50345, "mem_50452")) {
            err = 1;
            goto cleanup;
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
        lmad_copy_8b(ctx, 2, (uint64_t *) mem_50452.mem, (int64_t) 0, (int64_t []) {block_sizze_46792, (int64_t) 1}, (uint64_t *) mem_50349, (int64_t) 0, (int64_t []) {block_sizze_46792, (int64_t) 1}, (int64_t []) {smallest_pow_2_geq_than_res_46782, block_sizze_46792});
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
        if (memblock_alloc(ctx, &mem_50456, bytes_50345, "mem_50456")) {
            err = 1;
            goto cleanup;
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
        lmad_copy_8b(ctx, 2, (uint64_t *) mem_50456.mem, (int64_t) 0, (int64_t []) {block_sizze_46792, (int64_t) 1}, (uint64_t *) mem_50346, (int64_t) 0, (int64_t []) {block_sizze_46792, (int64_t) 1}, (int64_t []) {smallest_pow_2_geq_than_res_46782, block_sizze_46792});
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:251:5-262:26
        
        int64_t data_46984;
        bool data_46985;
        int64_t data_46989;
        int64_t loop_dz2084Uz2082U_46990;
        bool loop_while_46991;
        int64_t stride_46995;
        
        if (memblock_set(ctx, &mem_param_50460, &mem_50448, "mem_50448") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_50463, &mem_50452, "mem_50452") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_50466, &mem_50456, "mem_50456") != 0)
            return 1;
        loop_dz2084Uz2082U_46990 = flat_dim_46793;
        loop_while_46991 = loop_cond_46870;
        stride_46995 = block_sizze_46792;
        while (loop_while_46991) {
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:253:27-35
            
            int64_t next_stride_46996 = mul64((int64_t) 2, stride_46995);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:254:33-46
            
            bool zzero_46997 = next_stride_46996 == (int64_t) 0;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:254:33-46
            
            bool nonzzero_46998 = !zzero_46997;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:254:33-46
            
            bool nonzzero_cert_46999;
            
            if (!nonzzero_46998) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:254:33-46\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:375:19-85\n   #6  trmodel_test.fut:168:7-172:30\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:254:33-46
            
            int64_t num_merges_47000 = sdiv64(flat_dim_46793, next_stride_46996);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool bounds_invalid_upwards_47001 = slt64(num_merges_47000, (int64_t) 0);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool valid_47002 = !bounds_invalid_upwards_47001;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool range_valid_c_47003;
            
            if (!valid_47002) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) num_merges_47000, " is invalid.", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:375:19-85\n   #6  trmodel_test.fut:168:7-172:30\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56
            
            int64_t m_47005 = sub64(next_stride_46996, (int64_t) 1);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56
            
            bool zzero_leq_i_p_m_t_s_47006 = sle64((int64_t) 0, m_47005);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:144:3-155:47
            
            bool cond_47008 = slt64(next_stride_46996, (int64_t) 10);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59
            
            bool protect_assert_disj_47009 = nonzzero_46872 || cond_47008;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:147:30-42
            
            bool nonzzero_cert_47010;
            
            if (!protect_assert_disj_47009) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:147:30-42\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:168:7-172:30\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:147:30-42
            
            int64_t zeze_lhs_47011 = smod_safe64(next_stride_46996, greatest_divisor_leq_than_res_46816);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:147:43-47
            
            bool num_blocks_47012 = zeze_lhs_47011 == (int64_t) 0;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59
            
            bool protect_assert_disj_47013 = cond_47008 || num_blocks_47012;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:147:20-65
            
            bool assert_c_47014;
            
            if (!protect_assert_disj_47013) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "Assertion is false: (n % block_size == 0)", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:147:20-65\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:168:7-172:30\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:147:20-65
            
            int64_t num_blocks_47015 = sdiv_safe64(next_stride_46996, greatest_divisor_leq_than_res_46816);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:15-27
            
            int64_t dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_47016 = add64((int64_t) 1, num_blocks_47015);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:34-41
            
            int64_t j_m_i_47017 = sub64(next_stride_46996, stride_46995);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
            
            int64_t flat_dim_47018 = greatest_divisor_leq_than_res_46816 * num_blocks_47015;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84
            
            bool bounds_invalid_upwards_47019 = slt64(dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_47016, (int64_t) 0);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool empty_slice_47020 = j_m_i_47017 == (int64_t) 0;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            int64_t m_47021 = sub64(j_m_i_47017, (int64_t) 1);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool zzero_lte_i_47022 = sle64((int64_t) 0, stride_46995);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool i_lte_j_47023 = sle64(stride_46995, next_stride_46996);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59
            
            bool empty_slice_47024 = stride_46995 == (int64_t) 0;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59
            
            int64_t m_47025 = sub64(stride_46995, (int64_t) 1);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
            
            bool bounds_invalid_upwards_47026 = slt64(num_blocks_47015, (int64_t) 0);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:15-54
            
            bool cond_47027 = slt64((int64_t) 0, stride_46995);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84
            
            bool valid_47028 = !bounds_invalid_upwards_47019;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            int64_t i_p_m_t_s_47029 = add64(stride_46995, m_47021);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59
            
            bool zzero_leq_i_p_m_t_s_47030 = sle64((int64_t) 0, m_47025);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59
            
            bool i_p_m_t_s_leq_w_47031 = slt64(m_47025, next_stride_46996);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
            
            bool valid_47032 = !bounds_invalid_upwards_47026;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:3-46
            
            bool i_p_m_t_s_leq_w_47033 = slt64(m_47005, flat_dim_47018);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54
            
            bool y_47034 = slt64((int64_t) 0, j_m_i_47017);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool protect_assert_disj_47035 = cond_47008 || valid_47028;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84
            
            bool range_valid_c_47036;
            
            if (!protect_assert_disj_47035) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_47016, " is invalid.", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:168:7-172:30\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool zzero_leq_i_p_m_t_s_47037 = sle64((int64_t) 0, i_p_m_t_s_47029);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool i_p_m_t_s_leq_w_47038 = slt64(i_p_m_t_s_47029, next_stride_46996);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59
            
            bool y_47039 = zzero_leq_i_p_m_t_s_47030 && i_p_m_t_s_leq_w_47031;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool protect_assert_disj_47040 = cond_47008 || valid_47032;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
            
            bool range_valid_c_47041;
            
            if (!protect_assert_disj_47040) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) num_blocks_47015, " is invalid.", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:168:7-172:30\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:3-46
            
            bool y_47042 = zzero_leq_i_p_m_t_s_47006 && i_p_m_t_s_leq_w_47033;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool y_47043 = zzero_lte_i_47022 && i_p_m_t_s_leq_w_47038;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59
            
            bool forwards_ok_47044 = zzero_lte_i_47022 && y_47039;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:3-46
            
            bool ok_or_empty_47045 = zzero_46997 || y_47042;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool protect_assert_disj_47046 = cond_47027 || y_47034;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool y_47047 = zzero_leq_i_p_m_t_s_47037 && y_47043;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59
            
            bool ok_or_empty_47048 = empty_slice_47024 || forwards_ok_47044;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool protect_assert_disj_47049 = cond_47008 || ok_or_empty_47045;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:3-46
            
            bool index_certs_47050;
            
            if (!protect_assert_disj_47049) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) next_stride_46996, "] out of bounds for array of shape [", (long long) flat_dim_47018, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:3-46\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:168:7-172:30\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool loop_not_taken_47051 = !cond_47008;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool protect_assert_disj_47052 = protect_assert_disj_47046 || loop_not_taken_47051;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54
            
            bool index_certs_47053;
            
            if (!protect_assert_disj_47052) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_47017, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:5-43\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:375:19-85\n   #8  trmodel_test.fut:168:7-172:30\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool forwards_ok_47054 = i_lte_j_47023 && y_47047;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool protect_assert_disj_47055 = cond_47008 || ok_or_empty_47048;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59
            
            bool index_certs_47056;
            
            if (!protect_assert_disj_47055) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) stride_46995, "] out of bounds for array of shape [", (long long) next_stride_46996, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:168:7-172:30\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool protect_assert_disj_47057 = ok_or_empty_47048 || loop_not_taken_47051;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:26-33
            
            bool index_certs_47058;
            
            if (!protect_assert_disj_47057) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) stride_46995, "] out of bounds for array of shape [", (long long) next_stride_46996, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:26-33\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:168:7-172:30\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool ok_or_empty_47059 = empty_slice_47020 || forwards_ok_47054;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool protect_assert_disj_47060 = cond_47008 || ok_or_empty_47059;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool index_certs_47061;
            
            if (!protect_assert_disj_47060) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) stride_46995, ":] out of bounds for array of shape [", (long long) next_stride_46996, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:168:7-172:30\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool protect_assert_disj_47062 = loop_not_taken_47051 || ok_or_empty_47059;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:34-41
            
            bool index_certs_47063;
            
            if (!protect_assert_disj_47062) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) stride_46995, ":] out of bounds for array of shape [", (long long) next_stride_46996, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:34-41\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:168:7-172:30\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            int64_t binop_x_50467 = (int64_t) 8 * num_merges_47000;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            int64_t bytes_50468 = next_stride_46996 * binop_x_50467;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56
            
            bool i_lte_j_47007 = sle64((int64_t) 0, next_stride_46996);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            if (mem_50469_cached_sizze_51000 < bytes_50468) {
                err = lexical_realloc(ctx, &mem_50469, &mem_50469_cached_sizze_51000, bytes_50468);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            if (mem_50472_cached_sizze_51001 < bytes_50468) {
                err = lexical_realloc(ctx, &mem_50472, &mem_50472_cached_sizze_51001, bytes_50468);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            if (mem_50475_cached_sizze_51002 < bytes_50468) {
                err = lexical_realloc(ctx, &mem_50475, &mem_50475_cached_sizze_51002, bytes_50468);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84
            
            int64_t bytes_50488 = (int64_t) 8 * dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_47016;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
            
            int64_t binop_x_50504 = (int64_t) 8 * num_blocks_47015;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
            
            int64_t bytes_50505 = greatest_divisor_leq_than_res_46816 * binop_x_50504;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
            
            int64_t bytes_50573 = (int64_t) 16 * stride_46995;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            for (int64_t i_50047 = 0; i_50047 < num_merges_47000; i_50047++) {
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:257:26-39
                
                int64_t start_47068 = mul64(next_stride_46996, i_50047);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                int64_t j_m_i_47069 = sub64(loop_dz2084Uz2082U_46990, start_47068);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool empty_slice_47070 = j_m_i_47069 == (int64_t) 0;
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                int64_t m_47071 = sub64(j_m_i_47069, (int64_t) 1);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                int64_t i_p_m_t_s_47072 = add64(start_47068, m_47071);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool zzero_leq_i_p_m_t_s_47073 = sle64((int64_t) 0, i_p_m_t_s_47072);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool i_p_m_t_s_leq_w_47074 = slt64(i_p_m_t_s_47072, loop_dz2084Uz2082U_46990);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool zzero_lte_i_47075 = sle64((int64_t) 0, start_47068);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool i_lte_j_47076 = sle64(start_47068, loop_dz2084Uz2082U_46990);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool y_47077 = i_p_m_t_s_leq_w_47074 && zzero_lte_i_47075;
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool y_47078 = zzero_leq_i_p_m_t_s_47073 && y_47077;
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool forwards_ok_47079 = i_lte_j_47076 && y_47078;
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool ok_or_empty_47080 = empty_slice_47070 || forwards_ok_47079;
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool index_certs_47081;
                
                if (!ok_or_empty_47080) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) start_47068, ":] out of bounds for array of shape [", (long long) loop_dz2084Uz2082U_46990, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:375:19-85\n   #6  trmodel_test.fut:168:7-172:30\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56
                
                bool i_p_m_t_s_leq_w_47082 = slt64(m_47005, j_m_i_47069);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56
                
                bool y_47083 = zzero_leq_i_p_m_t_s_47006 && i_p_m_t_s_leq_w_47082;
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56
                
                bool forwards_ok_47084 = i_lte_j_47007 && y_47083;
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56
                
                bool ok_or_empty_47085 = zzero_46997 || forwards_ok_47084;
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56
                
                bool index_certs_47086;
                
                if (!ok_or_empty_47085) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) next_stride_46996, "] out of bounds for array of shape [", (long long) j_m_i_47069, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:375:19-85\n   #6  trmodel_test.fut:168:7-172:30\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                if (cond_47008) {
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:15-54
                    
                    int64_t dummy_49709;
                    int64_t dummy_49710;
                    double dummy_49711;
                    
                    if (cond_47027) {
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                        
                        int64_t head_res_49712 = ((int64_t *) mem_param_50460.mem)[start_47068];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                        
                        int64_t head_res_49713 = ((int64_t *) mem_param_50463.mem)[start_47068];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                        
                        double head_res_49714 = ((double *) mem_param_50466.mem)[start_47068];
                        
                        dummy_49709 = head_res_49712;
                        dummy_49710 = head_res_49713;
                        dummy_49711 = head_res_49714;
                    } else {
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                        
                        int64_t index_primexp_49715 = stride_46995 + start_47068;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                        
                        int64_t head_res_49716 = ((int64_t *) mem_param_50460.mem)[index_primexp_49715];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                        
                        int64_t head_res_49717 = ((int64_t *) mem_param_50463.mem)[index_primexp_49715];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                        
                        double head_res_49718 = ((double *) mem_param_50466.mem)[index_primexp_49715];
                        
                        dummy_49709 = head_res_49716;
                        dummy_49710 = head_res_49717;
                        dummy_49711 = head_res_49718;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
                    if (memblock_alloc(ctx, &mem_50574, bytes_50573, "mem_50574")) {
                        err = 1;
                        goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
                    for (int64_t nest_i_50879 = 0; nest_i_50879 < next_stride_46996; nest_i_50879++) {
                        ((int64_t *) mem_50574.mem)[nest_i_50879] = dummy_49709;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
                    if (memblock_alloc(ctx, &mem_50576, bytes_50573, "mem_50576")) {
                        err = 1;
                        goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
                    for (int64_t nest_i_50880 = 0; nest_i_50880 < next_stride_46996; nest_i_50880++) {
                        ((int64_t *) mem_50576.mem)[nest_i_50880] = dummy_49710;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
                    if (memblock_alloc(ctx, &mem_50578, bytes_50573, "mem_50578")) {
                        err = 1;
                        goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
                    for (int64_t nest_i_50881 = 0; nest_i_50881 < next_stride_46996; nest_i_50881++) {
                        ((double *) mem_50578.mem)[nest_i_50881] = dummy_49711;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:5-110:29
                    
                    int64_t data_49722;
                    int64_t i_49727 = (int64_t) 0;
                    
                    for (int64_t k_49726 = 0; k_49726 < next_stride_46996; k_49726++) {
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:103:16-18
                        
                        int64_t j_49731 = sub64(k_49726, i_49727);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:9-108:20
                        
                        bool cond_49732 = j_49731 == j_m_i_47017;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:9-108:20
                        
                        bool cond_49733;
                        
                        if (cond_49732) {
                            cond_49733 = 1;
                        } else {
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:30-59
                            
                            bool cond_49734 = slt64(i_49727, stride_46995);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:30-59
                            
                            bool cond_f_res_49735;
                            
                            if (cond_49734) {
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59
                                
                                bool x_49736 = sle64((int64_t) 0, j_49731);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59
                                
                                bool y_49737 = slt64(j_49731, j_m_i_47017);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59
                                
                                bool bounds_check_49738 = x_49736 && y_49737;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59
                                
                                bool index_certs_49739;
                                
                                if (!bounds_check_49738) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_49731, "] out of bounds for array of shape [", (long long) j_m_i_47017, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:5-43\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:375:19-85\n   #8  trmodel_test.fut:168:7-172:30\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54
                                
                                bool x_49744 = sle64((int64_t) 0, i_49727);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54
                                
                                bool bounds_check_49745 = cond_49734 && x_49744;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54
                                
                                bool index_certs_49746;
                                
                                if (!bounds_check_49745) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_49727, "] out of bounds for array of shape [", (long long) stride_46995, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:5-43\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:375:19-85\n   #8  trmodel_test.fut:168:7-172:30\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59
                                
                                int64_t index_primexp_49740 = stride_46995 + j_49731;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t index_primexp_49741 = start_47068 + index_primexp_49740;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t leq_arg1_49742 = ((int64_t *) mem_param_50460.mem)[index_primexp_49741];
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t leq_arg1_49743 = ((int64_t *) mem_param_50463.mem)[index_primexp_49741];
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t index_primexp_49747 = start_47068 + i_49727;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t leq_arg0_49748 = ((int64_t *) mem_param_50460.mem)[index_primexp_49747];
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t leq_arg0_49749 = ((int64_t *) mem_param_50463.mem)[index_primexp_49747];
                                
                                // ../lib/github.com/diku-dk/sparse/mono.fut:75:41-74
                                
                                bool cond_49750 = slt64(leq_arg0_49748, leq_arg1_49742);
                                
                                // ../lib/github.com/diku-dk/sparse/mono.fut:75:53-73
                                
                                bool cond_49751 = leq_arg0_49748 == leq_arg1_49742;
                                
                                // ../lib/github.com/diku-dk/sparse/mono.fut:75:68-73
                                
                                bool lifted_lambda_res_f_res_t_res_49752 = sle64(leq_arg0_49749, leq_arg1_49743);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:46-59
                                
                                bool x_49753 = cond_49751 && lifted_lambda_res_f_res_t_res_49752;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:46-59
                                
                                bool x_49754 = !cond_49750;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:46-59
                                
                                bool y_49755 = x_49753 && x_49754;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:46-59
                                
                                bool lifted_lambda_res_49756 = cond_49750 || y_49755;
                                
                                cond_f_res_49735 = lifted_lambda_res_49756;
                            } else {
                                cond_f_res_49735 = 0;
                            }
                            cond_49733 = cond_f_res_49735;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:9-108:20
                        
                        int64_t loopres_49757;
                        int64_t loopres_49758;
                        int64_t loopres_49759;
                        double loopres_49760;
                        
                        if (cond_49733) {
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21
                            
                            bool x_49762 = sle64((int64_t) 0, i_49727);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21
                            
                            bool y_49763 = slt64(i_49727, stride_46995);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21
                            
                            bool bounds_check_49764 = x_49762 && y_49763;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21
                            
                            bool index_certs_49765;
                            
                            if (!bounds_check_49764) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_49727, "] out of bounds for array of shape [", (long long) stride_46995, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:5-43\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:375:19-85\n   #8  trmodel_test.fut:168:7-172:30\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:13-15
                            
                            int64_t tmp_49761 = add64((int64_t) 1, i_49727);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t index_primexp_49766 = start_47068 + i_49727;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t tmp_49767 = ((int64_t *) mem_param_50460.mem)[index_primexp_49766];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t tmp_49768 = ((int64_t *) mem_param_50463.mem)[index_primexp_49766];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            double tmp_49769 = ((double *) mem_param_50466.mem)[index_primexp_49766];
                            
                            loopres_49757 = tmp_49761;
                            loopres_49758 = tmp_49767;
                            loopres_49759 = tmp_49768;
                            loopres_49760 = tmp_49769;
                        } else {
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19
                            
                            bool x_49770 = sle64((int64_t) 0, j_49731);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19
                            
                            bool y_49771 = slt64(j_49731, j_m_i_47017);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19
                            
                            bool bounds_check_49772 = x_49770 && y_49771;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19
                            
                            bool index_certs_49773;
                            
                            if (!bounds_check_49772) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_49731, "] out of bounds for array of shape [", (long long) j_m_i_47017, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:5-43\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:375:19-85\n   #8  trmodel_test.fut:168:7-172:30\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59
                            
                            int64_t index_primexp_49774 = stride_46995 + j_49731;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t index_primexp_49775 = start_47068 + index_primexp_49774;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t tmp_49776 = ((int64_t *) mem_param_50460.mem)[index_primexp_49775];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t tmp_49777 = ((int64_t *) mem_param_50463.mem)[index_primexp_49775];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            double tmp_49778 = ((double *) mem_param_50466.mem)[index_primexp_49775];
                            
                            loopres_49757 = i_49727;
                            loopres_49758 = tmp_49776;
                            loopres_49759 = tmp_49777;
                            loopres_49760 = tmp_49778;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:110:11-28
                        ((int64_t *) mem_50574.mem)[k_49726] = loopres_49758;
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:110:11-28
                        ((int64_t *) mem_50576.mem)[k_49726] = loopres_49759;
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:110:11-28
                        ((double *) mem_50578.mem)[k_49726] = loopres_49760;
                        
                        int64_t i_tmp_50882 = loopres_49757;
                        
                        i_49727 = i_tmp_50882;
                    }
                    data_49722 = i_49727;
                    if (memblock_set(ctx, &ext_mem_50605, &mem_50574, "mem_50574") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_50602, &mem_50576, "mem_50576") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_50599, &mem_50578, "mem_50578") != 0)
                        return 1;
                } else {
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84
                    if (mem_50489_cached_sizze_51003 < bytes_50488) {
                        err = lexical_realloc(ctx, &mem_50489, &mem_50489_cached_sizze_51003, bytes_50488);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84
                    if (mem_50491_cached_sizze_51004 < bytes_50488) {
                        err = lexical_realloc(ctx, &mem_50491, &mem_50491_cached_sizze_51004, bytes_50488);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84
                    for (int64_t i_50028 = 0; i_50028 < dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_47016; i_50028++) {
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83
                        
                        int64_t split_count_arg3_47167 = mul64(greatest_divisor_leq_than_res_46816, i_50028);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:32:15-39
                        
                        int64_t min_res_47168 = smin64(stride_46995, split_count_arg3_47167);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:33:15-39
                        
                        int64_t min_res_47169 = smin64(j_m_i_47017, split_count_arg3_47167);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:36:27-37
                        
                        int64_t zm_lhs_47170 = add64(min_res_47168, min_res_47169);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:36:39-46
                        
                        int64_t slack_47171 = sub64(zm_lhs_47170, split_count_arg3_47167);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:37:17-39
                        
                        int64_t min_res_47172 = smin64(min_res_47168, slack_47171);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:38:17-39
                        
                        int64_t min_res_47173 = smin64(min_res_47169, min_res_47172);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:40:32-39
                        
                        int64_t max_arg1_47174 = sub64(min_res_47168, min_res_47173);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:40:15-39
                        
                        int64_t max_res_47175 = smax64((int64_t) 0, max_arg1_47174);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:41:32-39
                        
                        int64_t max_arg1_47176 = sub64(min_res_47169, min_res_47173);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:41:15-39
                        
                        int64_t max_res_47177 = smax64((int64_t) 0, max_arg1_47176);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:43:23-40
                        
                        int64_t zm_lhs_47178 = sub64(split_count_arg3_47167, max_res_47175);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:43:42-59
                        
                        int64_t count_47179 = sub64(zm_lhs_47178, max_res_47177);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:81:5-83:39
                        
                        bool loop_cond_47180 = slt64((int64_t) 0, count_47179);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:81:5-83:39
                        
                        bool defunc_0_split_count_res_47181;
                        int64_t defunc_0_split_count_res_47182;
                        int64_t defunc_0_split_count_res_47183;
                        int64_t defunc_0_split_count_res_47184;
                        int64_t defunc_0_split_count_res_47185;
                        int64_t defunc_0_split_count_res_47186;
                        bool loop_while_47187;
                        int64_t ss_47188;
                        int64_t ss_47189;
                        int64_t tt_47190;
                        int64_t tt_47191;
                        int64_t count_47192;
                        
                        loop_while_47187 = loop_cond_47180;
                        ss_47188 = max_res_47175;
                        ss_47189 = min_res_47168;
                        tt_47190 = max_res_47177;
                        tt_47191 = min_res_47169;
                        count_47192 = count_47179;
                        while (loop_while_47187) {
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:48:11-15
                            
                            int64_t zlze_lhs_47193 = sub64(ss_47189, ss_47188);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:48:5-78:40
                            
                            bool cond_47194 = sle64(zlze_lhs_47193, (int64_t) 0);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38
                            
                            int64_t defunc_0_lifted_step_res_47195;
                            int64_t defunc_0_lifted_step_res_47196;
                            int64_t defunc_0_lifted_step_res_47197;
                            int64_t defunc_0_lifted_step_res_47198;
                            
                            if (cond_47194) {
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:49:24-30
                                
                                int64_t tmp_49782 = add64(tt_47190, count_47192);
                                
                                defunc_0_lifted_step_res_47195 = ss_47188;
                                defunc_0_lifted_step_res_47196 = tmp_49782;
                                defunc_0_lifted_step_res_47197 = tt_47191;
                                defunc_0_lifted_step_res_47198 = (int64_t) 0;
                            } else {
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:50:16-20
                                
                                int64_t zlze_lhs_47200 = sub64(tt_47191, tt_47190);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:50:10-78:40
                                
                                bool cond_47201 = sle64(zlze_lhs_47200, (int64_t) 0);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38
                                
                                int64_t defunc_0_lifted_step_res_f_res_47202;
                                int64_t defunc_0_lifted_step_res_f_res_47203;
                                int64_t defunc_0_lifted_step_res_f_res_47204;
                                int64_t defunc_0_lifted_step_res_f_res_47205;
                                
                                if (cond_47201) {
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:51:12-18
                                    
                                    int64_t tmp_49783 = add64(ss_47188, count_47192);
                                    
                                    defunc_0_lifted_step_res_f_res_47202 = tmp_49783;
                                    defunc_0_lifted_step_res_f_res_47203 = tt_47190;
                                    defunc_0_lifted_step_res_f_res_47204 = tt_47191;
                                    defunc_0_lifted_step_res_f_res_47205 = (int64_t) 0;
                                } else {
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:52:10-78:40
                                    
                                    bool cond_47207 = count_47192 == (int64_t) 1;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38
                                    
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_47208;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_47209;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_47210;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_47211;
                                    
                                    if (cond_47207) {
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:21-27
                                        
                                        bool x_49785 = sle64((int64_t) 0, ss_47188);
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:21-27
                                        
                                        bool y_49786 = slt64(ss_47188, stride_46995);
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:21-27
                                        
                                        bool bounds_check_49787 = x_49785 && y_49786;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:21-27
                                        
                                        bool index_certs_49788;
                                        
                                        if (!bounds_check_49787) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) ss_47188, "] out of bounds for array of shape [", (long long) stride_46995, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:21-27\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:36-83\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #4  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #7  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #8  trmodel.fut:375:19-85\n   #9  trmodel_test.fut:168:7-172:30\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:14-20
                                        
                                        bool x_49792 = sle64((int64_t) 0, tt_47190);
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:14-20
                                        
                                        bool y_49793 = slt64(tt_47190, j_m_i_47017);
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:14-20
                                        
                                        bool bounds_check_49794 = x_49792 && y_49793;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:14-20
                                        
                                        bool index_certs_49795;
                                        
                                        if (!bounds_check_49794) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tt_47190, "] out of bounds for array of shape [", (long long) j_m_i_47017, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:14-20\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:36-83\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #4  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #7  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #8  trmodel.fut:375:19-85\n   #9  trmodel_test.fut:168:7-172:30\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                        
                                        int64_t index_primexp_49789 = start_47068 + ss_47188;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                        
                                        int64_t leq_arg1_49790 = ((int64_t *) mem_param_50460.mem)[index_primexp_49789];
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                        
                                        int64_t leq_arg1_49791 = ((int64_t *) mem_param_50463.mem)[index_primexp_49789];
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84
                                        
                                        int64_t index_primexp_49796 = stride_46995 + tt_47190;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                        
                                        int64_t index_primexp_49797 = start_47068 + index_primexp_49796;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                        
                                        int64_t leq_arg0_49798 = ((int64_t *) mem_param_50460.mem)[index_primexp_49797];
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                        
                                        int64_t leq_arg0_49799 = ((int64_t *) mem_param_50463.mem)[index_primexp_49797];
                                        
                                        // ../lib/github.com/diku-dk/sparse/mono.fut:75:41-74
                                        
                                        bool cond_49800 = slt64(leq_arg0_49798, leq_arg1_49790);
                                        
                                        // ../lib/github.com/diku-dk/sparse/mono.fut:75:53-73
                                        
                                        bool cond_49801 = leq_arg0_49798 == leq_arg1_49790;
                                        
                                        // ../lib/github.com/diku-dk/sparse/mono.fut:75:68-73
                                        
                                        bool lifted_lambda_res_f_res_t_res_49802 = sle64(leq_arg0_49799, leq_arg1_49791);
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:7-56:38
                                        
                                        bool x_49803 = cond_49801 && lifted_lambda_res_f_res_t_res_49802;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:7-56:38
                                        
                                        bool x_49804 = !cond_49800;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:7-56:38
                                        
                                        bool y_49805 = x_49803 && x_49804;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:7-56:38
                                        
                                        bool lifted_lambda_res_49806 = cond_49800 || y_49805;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38
                                        
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_t_res_49807;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_t_res_49808;
                                        
                                        if (lifted_lambda_res_49806) {
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:54:26-28
                                            
                                            int64_t tmp_49809 = add64((int64_t) 1, tt_47190);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_49807 = ss_47188;
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_49808 = tmp_49809;
                                        } else {
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:56:14-16
                                            
                                            int64_t tmp_49810 = add64((int64_t) 1, ss_47188);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_49807 = tmp_49810;
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_49808 = tt_47190;
                                        }
                                        defunc_0_lifted_step_res_f_res_f_res_47208 = defunc_0_lifted_step_res_f_res_f_res_t_res_49807;
                                        defunc_0_lifted_step_res_f_res_f_res_47209 = defunc_0_lifted_step_res_f_res_f_res_t_res_49808;
                                        defunc_0_lifted_step_res_f_res_f_res_47210 = tt_47191;
                                        defunc_0_lifted_step_res_f_res_f_res_47211 = (int64_t) 0;
                                    } else {
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:58:19-22
                                        
                                        int64_t m_47238 = sdiv64(count_47192, (int64_t) 2);
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:59:19-22
                                        
                                        int64_t n_47239 = sub64(count_47192, m_47238);
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:71:7-73:30
                                        
                                        bool cond_47240 = n_47239 == (int64_t) 0;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:72:10-12
                                        
                                        int64_t zgze_lhs_47241 = add64(ss_47188, m_47238);
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:72:13-19
                                        
                                        bool cond_f_res_47242 = sle64(ss_47189, zgze_lhs_47241);
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38
                                        
                                        bool x_47243 = !cond_47240;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38
                                        
                                        bool y_47244 = cond_f_res_47242 && x_47243;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38
                                        
                                        bool cond_47245 = cond_47240 || y_47244;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:71:7-73:30
                                        
                                        bool leq_y_x_47246;
                                        
                                        if (cond_47245) {
                                            leq_y_x_47246 = 1;
                                        } else {
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:22-30
                                            
                                            bool x_47247 = sle64((int64_t) 0, zgze_lhs_47241);
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:22-30
                                            
                                            bool y_47248 = slt64(zgze_lhs_47241, stride_46995);
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:22-30
                                            
                                            bool bounds_check_47249 = x_47247 && y_47248;
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:22-30
                                            
                                            bool index_certs_47250;
                                            
                                            if (!bounds_check_47249) {
                                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) zgze_lhs_47241, "] out of bounds for array of shape [", (long long) stride_46995, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:22-30\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:36-83\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #4  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #7  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #8  trmodel.fut:375:19-85\n   #9  trmodel_test.fut:168:7-172:30\n"));
                                                err = FUTHARK_PROGRAM_ERROR;
                                                goto cleanup;
                                            }
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:16-18
                                            
                                            int64_t zm_lhs_47254 = add64(tt_47190, n_47239);
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:18-20
                                            
                                            int64_t leq_arg0_47255 = sub64(zm_lhs_47254, (int64_t) 1);
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:11-21
                                            
                                            bool x_47256 = sle64((int64_t) 0, leq_arg0_47255);
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:11-21
                                            
                                            bool y_47257 = slt64(leq_arg0_47255, j_m_i_47017);
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:11-21
                                            
                                            bool bounds_check_47258 = x_47256 && y_47257;
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:11-21
                                            
                                            bool index_certs_47259;
                                            
                                            if (!bounds_check_47258) {
                                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) leq_arg0_47255, "] out of bounds for array of shape [", (long long) j_m_i_47017, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:11-21\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:36-83\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #4  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #7  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #8  trmodel.fut:375:19-85\n   #9  trmodel_test.fut:168:7-172:30\n"));
                                                err = FUTHARK_PROGRAM_ERROR;
                                                goto cleanup;
                                            }
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                            
                                            int64_t index_primexp_47251 = start_47068 + zgze_lhs_47241;
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                            
                                            int64_t leq_arg1_47252 = ((int64_t *) mem_param_50460.mem)[index_primexp_47251];
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                            
                                            int64_t leq_arg1_47253 = ((int64_t *) mem_param_50463.mem)[index_primexp_47251];
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84
                                            
                                            int64_t index_primexp_47260 = stride_46995 + leq_arg0_47255;
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                            
                                            int64_t index_primexp_47261 = start_47068 + index_primexp_47260;
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                            
                                            int64_t leq_arg0_47262 = ((int64_t *) mem_param_50460.mem)[index_primexp_47261];
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                            
                                            int64_t leq_arg0_47263 = ((int64_t *) mem_param_50463.mem)[index_primexp_47261];
                                            
                                            // ../lib/github.com/diku-dk/sparse/mono.fut:75:41-74
                                            
                                            bool cond_47264 = slt64(leq_arg0_47262, leq_arg1_47252);
                                            
                                            // ../lib/github.com/diku-dk/sparse/mono.fut:75:53-73
                                            
                                            bool cond_47265 = leq_arg0_47262 == leq_arg1_47252;
                                            
                                            // ../lib/github.com/diku-dk/sparse/mono.fut:75:68-73
                                            
                                            bool lifted_lambda_res_f_res_t_res_47266 = sle64(leq_arg0_47263, leq_arg1_47253);
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:7-30
                                            
                                            bool x_47267 = cond_47265 && lifted_lambda_res_f_res_t_res_47266;
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:7-30
                                            
                                            bool x_47268 = !cond_47264;
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:7-30
                                            
                                            bool y_47269 = x_47267 && x_47268;
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:7-30
                                            
                                            bool lifted_lambda_res_47270 = cond_47264 || y_47269;
                                            
                                            leq_y_x_47246 = lifted_lambda_res_47270;
                                        }
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38
                                        
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_47271;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_47272;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_47273;
                                        
                                        if (leq_y_x_47246) {
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:76:24-26
                                            
                                            int64_t tmp_49811 = add64(tt_47190, n_47239);
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:76:39-41
                                            
                                            int64_t tmp_49812 = sub64(count_47192, n_47239);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_47271 = tmp_49811;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_47272 = tt_47191;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_47273 = tmp_49812;
                                        } else {
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:78:29-31
                                            
                                            int64_t tmp_47276 = add64(tt_47190, n_47239);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_47271 = tt_47190;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_47272 = tmp_47276;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_47273 = count_47192;
                                        }
                                        defunc_0_lifted_step_res_f_res_f_res_47208 = ss_47188;
                                        defunc_0_lifted_step_res_f_res_f_res_47209 = defunc_0_lifted_step_res_f_res_f_res_f_res_47271;
                                        defunc_0_lifted_step_res_f_res_f_res_47210 = defunc_0_lifted_step_res_f_res_f_res_f_res_47272;
                                        defunc_0_lifted_step_res_f_res_f_res_47211 = defunc_0_lifted_step_res_f_res_f_res_f_res_47273;
                                    }
                                    defunc_0_lifted_step_res_f_res_47202 = defunc_0_lifted_step_res_f_res_f_res_47208;
                                    defunc_0_lifted_step_res_f_res_47203 = defunc_0_lifted_step_res_f_res_f_res_47209;
                                    defunc_0_lifted_step_res_f_res_47204 = defunc_0_lifted_step_res_f_res_f_res_47210;
                                    defunc_0_lifted_step_res_f_res_47205 = defunc_0_lifted_step_res_f_res_f_res_47211;
                                }
                                defunc_0_lifted_step_res_47195 = defunc_0_lifted_step_res_f_res_47202;
                                defunc_0_lifted_step_res_47196 = defunc_0_lifted_step_res_f_res_47203;
                                defunc_0_lifted_step_res_47197 = defunc_0_lifted_step_res_f_res_47204;
                                defunc_0_lifted_step_res_47198 = defunc_0_lifted_step_res_f_res_47205;
                            }
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:32:32-39
                            
                            int64_t min_arg1_47277 = add64(defunc_0_lifted_step_res_47195, defunc_0_lifted_step_res_47198);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:32:15-39
                            
                            int64_t min_res_47278 = smin64(ss_47189, min_arg1_47277);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:33:32-39
                            
                            int64_t min_arg1_47279 = add64(defunc_0_lifted_step_res_47196, defunc_0_lifted_step_res_47198);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:33:15-39
                            
                            int64_t min_res_47280 = smin64(defunc_0_lifted_step_res_47197, min_arg1_47279);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:36:21-25
                            
                            int64_t zp_lhs_47281 = sub64(min_res_47278, defunc_0_lifted_step_res_47195);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:36:33-37
                            
                            int64_t zp_rhs_47282 = sub64(min_res_47280, defunc_0_lifted_step_res_47196);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:36:27-37
                            
                            int64_t zm_lhs_47283 = add64(zp_lhs_47281, zp_rhs_47282);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:36:39-46
                            
                            int64_t slack_47284 = sub64(zm_lhs_47283, defunc_0_lifted_step_res_47198);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:37:17-39
                            
                            int64_t min_res_47285 = smin64(zp_lhs_47281, slack_47284);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:38:17-39
                            
                            int64_t min_res_47286 = smin64(zp_rhs_47282, min_res_47285);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:40:32-39
                            
                            int64_t max_arg1_47287 = sub64(min_res_47278, min_res_47286);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:40:15-39
                            
                            int64_t max_res_47288 = smax64(defunc_0_lifted_step_res_47195, max_arg1_47287);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:41:32-39
                            
                            int64_t max_arg1_47289 = sub64(min_res_47280, min_res_47286);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:41:15-39
                            
                            int64_t max_res_47290 = smax64(defunc_0_lifted_step_res_47196, max_arg1_47289);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:43:30-40
                            
                            int64_t zm_rhs_47291 = sub64(max_res_47288, defunc_0_lifted_step_res_47195);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:43:23-40
                            
                            int64_t zm_lhs_47292 = sub64(defunc_0_lifted_step_res_47198, zm_rhs_47291);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:43:49-59
                            
                            int64_t zm_rhs_47293 = sub64(max_res_47290, defunc_0_lifted_step_res_47196);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:43:42-59
                            
                            int64_t count_47294 = sub64(zm_lhs_47292, zm_rhs_47293);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:82:17-20
                            
                            bool loop_cond_47295 = slt64((int64_t) 0, count_47294);
                            bool loop_while_tmp_50888 = loop_cond_47295;
                            int64_t ss_tmp_50889 = max_res_47288;
                            int64_t ss_tmp_50890 = min_res_47278;
                            int64_t tt_tmp_50891 = max_res_47290;
                            int64_t tt_tmp_50892 = min_res_47280;
                            int64_t count_tmp_50893 = count_47294;
                            
                            loop_while_47187 = loop_while_tmp_50888;
                            ss_47188 = ss_tmp_50889;
                            ss_47189 = ss_tmp_50890;
                            tt_47190 = tt_tmp_50891;
                            tt_47191 = tt_tmp_50892;
                            count_47192 = count_tmp_50893;
                        }
                        defunc_0_split_count_res_47181 = loop_while_47187;
                        defunc_0_split_count_res_47182 = ss_47188;
                        defunc_0_split_count_res_47183 = ss_47189;
                        defunc_0_split_count_res_47184 = tt_47190;
                        defunc_0_split_count_res_47185 = tt_47191;
                        defunc_0_split_count_res_47186 = count_47192;
                        ((int64_t *) mem_50489)[i_50028] = defunc_0_split_count_res_47182;
                        ((int64_t *) mem_50491)[i_50028] = defunc_0_split_count_res_47184;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
                    if (mem_50506_cached_sizze_51005 < bytes_50505) {
                        err = lexical_realloc(ctx, &mem_50506, &mem_50506_cached_sizze_51005, bytes_50505);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
                    if (mem_50509_cached_sizze_51006 < bytes_50505) {
                        err = lexical_realloc(ctx, &mem_50509, &mem_50509_cached_sizze_51006, bytes_50505);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
                    if (mem_50512_cached_sizze_51007 < bytes_50505) {
                        err = lexical_realloc(ctx, &mem_50512, &mem_50512_cached_sizze_51007, bytes_50505);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
                    for (int64_t i_50037 = 0; i_50037 < num_blocks_47015; i_50037++) {
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:151:22-34
                        
                        bool y_47302 = slt64(i_50037, dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_47016);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:151:22-34
                        
                        bool index_certs_47304;
                        
                        if (!y_47302) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_50037, "] out of bounds for array of shape [", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_47016, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:151:22-34\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:168:7-172:30\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:151:22-34
                        
                        int64_t defunc_0_f_res_47305 = ((int64_t *) mem_50489)[i_50037];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:151:22-34
                        
                        int64_t defunc_0_f_res_47306 = ((int64_t *) mem_50491)[i_50037];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:152:33-35
                        
                        int64_t tmp_47307 = add64((int64_t) 1, i_50037);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36
                        
                        bool x_47308 = sle64((int64_t) 0, tmp_47307);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36
                        
                        bool y_47309 = slt64(tmp_47307, dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_47016);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36
                        
                        bool bounds_check_47310 = x_47308 && y_47309;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36
                        
                        bool index_certs_47311;
                        
                        if (!bounds_check_47310) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_47307, "] out of bounds for array of shape [", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_47016, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:168:7-172:30\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36
                        
                        int64_t defunc_0_f_res_47312 = ((int64_t *) mem_50489)[tmp_47307];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36
                        
                        int64_t defunc_0_f_res_47313 = ((int64_t *) mem_50491)[tmp_47307];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:45-49
                        
                        int64_t merge_sequential_arg2_47314 = add64(stride_46995, defunc_0_f_res_47306);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:53-57
                        
                        int64_t merge_sequential_arg2_47315 = add64(stride_46995, defunc_0_f_res_47313);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        int64_t j_m_i_47316 = sub64(merge_sequential_arg2_47315, merge_sequential_arg2_47314);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool empty_slice_47317 = j_m_i_47316 == (int64_t) 0;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        int64_t m_47318 = sub64(j_m_i_47316, (int64_t) 1);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        int64_t i_p_m_t_s_47319 = add64(merge_sequential_arg2_47314, m_47318);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool zzero_leq_i_p_m_t_s_47320 = sle64((int64_t) 0, i_p_m_t_s_47319);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool i_p_m_t_s_leq_w_47321 = slt64(i_p_m_t_s_47319, next_stride_46996);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool zzero_lte_i_47322 = sle64((int64_t) 0, merge_sequential_arg2_47314);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool i_lte_j_47323 = sle64(merge_sequential_arg2_47314, merge_sequential_arg2_47315);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool y_47324 = i_p_m_t_s_leq_w_47321 && zzero_lte_i_47322;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool y_47325 = zzero_leq_i_p_m_t_s_47320 && y_47324;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool forwards_ok_47326 = i_lte_j_47323 && y_47325;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool ok_or_empty_47327 = empty_slice_47317 || forwards_ok_47326;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool index_certs_47328;
                        
                        if (!ok_or_empty_47327) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) merge_sequential_arg2_47314, ":", (long long) merge_sequential_arg2_47315, "] out of bounds for array of shape [", (long long) next_stride_46996, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:168:7-172:30\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        int64_t j_m_i_47329 = sub64(defunc_0_f_res_47312, defunc_0_f_res_47305);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool empty_slice_47330 = j_m_i_47329 == (int64_t) 0;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        int64_t m_47331 = sub64(j_m_i_47329, (int64_t) 1);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        int64_t i_p_m_t_s_47332 = add64(defunc_0_f_res_47305, m_47331);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool zzero_leq_i_p_m_t_s_47333 = sle64((int64_t) 0, i_p_m_t_s_47332);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool i_p_m_t_s_leq_w_47334 = slt64(i_p_m_t_s_47332, next_stride_46996);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool zzero_lte_i_47335 = sle64((int64_t) 0, defunc_0_f_res_47305);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool i_lte_j_47336 = sle64(defunc_0_f_res_47305, defunc_0_f_res_47312);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool y_47337 = i_p_m_t_s_leq_w_47334 && zzero_lte_i_47335;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool y_47338 = zzero_leq_i_p_m_t_s_47333 && y_47337;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool forwards_ok_47339 = i_lte_j_47336 && y_47338;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool ok_or_empty_47340 = empty_slice_47330 || forwards_ok_47339;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool index_certs_47341;
                        
                        if (!ok_or_empty_47340) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) defunc_0_f_res_47305, ":", (long long) defunc_0_f_res_47312, "] out of bounds for array of shape [", (long long) next_stride_46996, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:168:7-172:30\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:15-54
                        
                        bool cond_47342 = slt64((int64_t) 0, j_m_i_47329);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:15-54
                        
                        int64_t dummy_47343;
                        int64_t dummy_47344;
                        double dummy_47345;
                        
                        if (cond_47342) {
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:36-42
                            
                            bool index_certs_49813;
                            
                            if (!cond_47342) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_47329, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:36-42\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:8-69\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:375:19-85\n   #8  trmodel_test.fut:168:7-172:30\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t index_primexp_49814 = start_47068 + defunc_0_f_res_47305;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t head_res_49815 = ((int64_t *) mem_param_50460.mem)[index_primexp_49814];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t head_res_49816 = ((int64_t *) mem_param_50463.mem)[index_primexp_49814];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            double head_res_49817 = ((double *) mem_param_50466.mem)[index_primexp_49814];
                            
                            dummy_47343 = head_res_49815;
                            dummy_47344 = head_res_49816;
                            dummy_47345 = head_res_49817;
                        } else {
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54
                            
                            bool y_47351 = slt64((int64_t) 0, j_m_i_47316);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54
                            
                            bool index_certs_47352;
                            
                            if (!y_47351) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_47316, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:8-69\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:375:19-85\n   #8  trmodel_test.fut:168:7-172:30\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t index_primexp_47353 = start_47068 + merge_sequential_arg2_47314;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t head_res_47354 = ((int64_t *) mem_param_50460.mem)[index_primexp_47353];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t head_res_47355 = ((int64_t *) mem_param_50463.mem)[index_primexp_47353];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            double head_res_47356 = ((double *) mem_param_50466.mem)[index_primexp_47353];
                            
                            dummy_47343 = head_res_47354;
                            dummy_47344 = head_res_47355;
                            dummy_47345 = head_res_47356;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
                        for (int64_t nest_i_50897 = 0; nest_i_50897 < greatest_divisor_leq_than_res_46816; nest_i_50897++) {
                            ((int64_t *) mem_50512)[i_50037 * greatest_divisor_leq_than_res_46816 + nest_i_50897] = dummy_47343;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
                        for (int64_t nest_i_50898 = 0; nest_i_50898 < greatest_divisor_leq_than_res_46816; nest_i_50898++) {
                            ((int64_t *) mem_50509)[i_50037 * greatest_divisor_leq_than_res_46816 + nest_i_50898] = dummy_47344;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
                        for (int64_t nest_i_50899 = 0; nest_i_50899 < greatest_divisor_leq_than_res_46816; nest_i_50899++) {
                            ((double *) mem_50506)[i_50037 * greatest_divisor_leq_than_res_46816 + nest_i_50899] = dummy_47345;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:5-110:29
                        
                        int64_t data_47360;
                        int64_t i_47365 = (int64_t) 0;
                        
                        for (int64_t k_47364 = 0; k_47364 < greatest_divisor_leq_than_res_46816; k_47364++) {
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:103:16-18
                            
                            int64_t j_47369 = sub64(k_47364, i_47365);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:9-108:20
                            
                            bool cond_47370 = j_47369 == j_m_i_47316;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:9-108:20
                            
                            bool cond_47371;
                            
                            if (cond_47370) {
                                cond_47371 = 1;
                            } else {
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:30-59
                                
                                bool cond_47372 = slt64(i_47365, j_m_i_47329);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:30-59
                                
                                bool cond_f_res_47373;
                                
                                if (cond_47372) {
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59
                                    
                                    bool x_49818 = sle64((int64_t) 0, j_47369);
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59
                                    
                                    bool y_49819 = slt64(j_47369, j_m_i_47316);
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59
                                    
                                    bool bounds_check_49820 = x_49818 && y_49819;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59
                                    
                                    bool index_certs_49821;
                                    
                                    if (!bounds_check_49820) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_47369, "] out of bounds for array of shape [", (long long) j_m_i_47316, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:8-69\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:375:19-85\n   #8  trmodel_test.fut:168:7-172:30\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54
                                    
                                    bool x_49826 = sle64((int64_t) 0, i_47365);
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54
                                    
                                    bool bounds_check_49827 = cond_47372 && x_49826;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54
                                    
                                    bool index_certs_49828;
                                    
                                    if (!bounds_check_49827) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_47365, "] out of bounds for array of shape [", (long long) j_m_i_47329, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:8-69\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:375:19-85\n   #8  trmodel_test.fut:168:7-172:30\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
                                    
                                    int64_t index_primexp_49822 = merge_sequential_arg2_47314 + j_47369;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                    
                                    int64_t index_primexp_49823 = start_47068 + index_primexp_49822;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                    
                                    int64_t leq_arg1_49824 = ((int64_t *) mem_param_50460.mem)[index_primexp_49823];
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                    
                                    int64_t leq_arg1_49825 = ((int64_t *) mem_param_50463.mem)[index_primexp_49823];
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
                                    
                                    int64_t index_primexp_49829 = defunc_0_f_res_47305 + i_47365;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                    
                                    int64_t index_primexp_49830 = start_47068 + index_primexp_49829;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                    
                                    int64_t leq_arg0_49831 = ((int64_t *) mem_param_50460.mem)[index_primexp_49830];
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                    
                                    int64_t leq_arg0_49832 = ((int64_t *) mem_param_50463.mem)[index_primexp_49830];
                                    
                                    // ../lib/github.com/diku-dk/sparse/mono.fut:75:41-74
                                    
                                    bool cond_49833 = slt64(leq_arg0_49831, leq_arg1_49824);
                                    
                                    // ../lib/github.com/diku-dk/sparse/mono.fut:75:53-73
                                    
                                    bool cond_49834 = leq_arg0_49831 == leq_arg1_49824;
                                    
                                    // ../lib/github.com/diku-dk/sparse/mono.fut:75:68-73
                                    
                                    bool lifted_lambda_res_f_res_t_res_49835 = sle64(leq_arg0_49832, leq_arg1_49825);
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:46-59
                                    
                                    bool x_49836 = cond_49834 && lifted_lambda_res_f_res_t_res_49835;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:46-59
                                    
                                    bool x_49837 = !cond_49833;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:46-59
                                    
                                    bool y_49838 = x_49836 && x_49837;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:46-59
                                    
                                    bool lifted_lambda_res_49839 = cond_49833 || y_49838;
                                    
                                    cond_f_res_47373 = lifted_lambda_res_49839;
                                } else {
                                    cond_f_res_47373 = 0;
                                }
                                cond_47371 = cond_f_res_47373;
                            }
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:9-108:20
                            
                            int64_t loopres_47396;
                            int64_t loopres_47397;
                            int64_t loopres_47398;
                            double loopres_47399;
                            
                            if (cond_47371) {
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21
                                
                                bool x_49841 = sle64((int64_t) 0, i_47365);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21
                                
                                bool y_49842 = slt64(i_47365, j_m_i_47329);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21
                                
                                bool bounds_check_49843 = x_49841 && y_49842;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21
                                
                                bool index_certs_49844;
                                
                                if (!bounds_check_49843) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_47365, "] out of bounds for array of shape [", (long long) j_m_i_47329, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:8-69\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:375:19-85\n   #8  trmodel_test.fut:168:7-172:30\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:13-15
                                
                                int64_t tmp_49840 = add64((int64_t) 1, i_47365);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
                                
                                int64_t index_primexp_49845 = defunc_0_f_res_47305 + i_47365;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t index_primexp_49846 = start_47068 + index_primexp_49845;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t tmp_49847 = ((int64_t *) mem_param_50460.mem)[index_primexp_49846];
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t tmp_49848 = ((int64_t *) mem_param_50463.mem)[index_primexp_49846];
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                double tmp_49849 = ((double *) mem_param_50466.mem)[index_primexp_49846];
                                
                                loopres_47396 = tmp_49840;
                                loopres_47397 = tmp_49847;
                                loopres_47398 = tmp_49848;
                                loopres_47399 = tmp_49849;
                            } else {
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19
                                
                                bool x_47410 = sle64((int64_t) 0, j_47369);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19
                                
                                bool y_47411 = slt64(j_47369, j_m_i_47316);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19
                                
                                bool bounds_check_47412 = x_47410 && y_47411;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19
                                
                                bool index_certs_47413;
                                
                                if (!bounds_check_47412) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_47369, "] out of bounds for array of shape [", (long long) j_m_i_47316, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:8-69\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:375:19-85\n   #8  trmodel_test.fut:168:7-172:30\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
                                
                                int64_t index_primexp_47414 = merge_sequential_arg2_47314 + j_47369;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t index_primexp_47415 = start_47068 + index_primexp_47414;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t tmp_47416 = ((int64_t *) mem_param_50460.mem)[index_primexp_47415];
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t tmp_47417 = ((int64_t *) mem_param_50463.mem)[index_primexp_47415];
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                double tmp_47418 = ((double *) mem_param_50466.mem)[index_primexp_47415];
                                
                                loopres_47396 = i_47365;
                                loopres_47397 = tmp_47416;
                                loopres_47398 = tmp_47417;
                                loopres_47399 = tmp_47418;
                            }
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:110:11-28
                            ((int64_t *) mem_50512)[i_50037 * greatest_divisor_leq_than_res_46816 + k_47364] = loopres_47397;
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:110:11-28
                            ((int64_t *) mem_50509)[i_50037 * greatest_divisor_leq_than_res_46816 + k_47364] = loopres_47398;
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:110:11-28
                            ((double *) mem_50506)[i_50037 * greatest_divisor_leq_than_res_46816 + k_47364] = loopres_47399;
                            
                            int64_t i_tmp_50900 = loopres_47396;
                            
                            i_47365 = i_tmp_50900;
                        }
                        data_47360 = i_47365;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
                    if (memblock_alloc(ctx, &mem_50563, bytes_50505, "mem_50563")) {
                        err = 1;
                        goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
                    lmad_copy_8b(ctx, 2, (uint64_t *) mem_50563.mem, (int64_t) 0, (int64_t []) {greatest_divisor_leq_than_res_46816, (int64_t) 1}, (uint64_t *) mem_50512, (int64_t) 0, (int64_t []) {greatest_divisor_leq_than_res_46816, (int64_t) 1}, (int64_t []) {num_blocks_47015, greatest_divisor_leq_than_res_46816});
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
                    if (memblock_alloc(ctx, &mem_50567, bytes_50505, "mem_50567")) {
                        err = 1;
                        goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
                    lmad_copy_8b(ctx, 2, (uint64_t *) mem_50567.mem, (int64_t) 0, (int64_t []) {greatest_divisor_leq_than_res_46816, (int64_t) 1}, (uint64_t *) mem_50509, (int64_t) 0, (int64_t []) {greatest_divisor_leq_than_res_46816, (int64_t) 1}, (int64_t []) {num_blocks_47015, greatest_divisor_leq_than_res_46816});
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
                    if (memblock_alloc(ctx, &mem_50571, bytes_50505, "mem_50571")) {
                        err = 1;
                        goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
                    lmad_copy_8b(ctx, 2, (uint64_t *) mem_50571.mem, (int64_t) 0, (int64_t []) {greatest_divisor_leq_than_res_46816, (int64_t) 1}, (uint64_t *) mem_50506, (int64_t) 0, (int64_t []) {greatest_divisor_leq_than_res_46816, (int64_t) 1}, (int64_t []) {num_blocks_47015, greatest_divisor_leq_than_res_46816});
                    if (memblock_set(ctx, &ext_mem_50605, &mem_50563, "mem_50563") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_50602, &mem_50567, "mem_50567") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_50599, &mem_50571, "mem_50571") != 0)
                        return 1;
                }
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_50469, i_50047 * next_stride_46996, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_50599.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {next_stride_46996});
                if (memblock_unref(ctx, &ext_mem_50599, "ext_mem_50599") != 0)
                    return 1;
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_50472, i_50047 * next_stride_46996, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_50602.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {next_stride_46996});
                if (memblock_unref(ctx, &ext_mem_50602, "ext_mem_50602") != 0)
                    return 1;
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_50475, i_50047 * next_stride_46996, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_50605.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {next_stride_46996});
                if (memblock_unref(ctx, &ext_mem_50605, "ext_mem_50605") != 0)
                    return 1;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            
            int64_t flat_dim_47428 = next_stride_46996 * num_merges_47000;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            if (memblock_alloc(ctx, &mem_50620, bytes_50468, "mem_50620")) {
                err = 1;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            lmad_copy_8b(ctx, 2, (uint64_t *) mem_50620.mem, (int64_t) 0, (int64_t []) {next_stride_46996, (int64_t) 1}, (uint64_t *) mem_50475, (int64_t) 0, (int64_t []) {next_stride_46996, (int64_t) 1}, (int64_t []) {num_merges_47000, next_stride_46996});
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            if (memblock_alloc(ctx, &mem_50624, bytes_50468, "mem_50624")) {
                err = 1;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            lmad_copy_8b(ctx, 2, (uint64_t *) mem_50624.mem, (int64_t) 0, (int64_t []) {next_stride_46996, (int64_t) 1}, (uint64_t *) mem_50472, (int64_t) 0, (int64_t []) {next_stride_46996, (int64_t) 1}, (int64_t []) {num_merges_47000, next_stride_46996});
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            if (memblock_alloc(ctx, &mem_50628, bytes_50468, "mem_50628")) {
                err = 1;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            lmad_copy_8b(ctx, 2, (uint64_t *) mem_50628.mem, (int64_t) 0, (int64_t []) {next_stride_46996, (int64_t) 1}, (uint64_t *) mem_50469, (int64_t) 0, (int64_t []) {next_stride_46996, (int64_t) 1}, (int64_t []) {num_merges_47000, next_stride_46996});
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:252:18-28
            
            bool loop_cond_47432 = slt64(next_stride_46996, flat_dim_46793);
            
            if (memblock_set(ctx, &mem_param_tmp_50867, &mem_50620, "mem_50620") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_50868, &mem_50624, "mem_50624") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_50869, &mem_50628, "mem_50628") != 0)
                return 1;
            
            int64_t loop_dz2084Uz2082U_tmp_50870 = flat_dim_47428;
            bool loop_while_tmp_50871 = loop_cond_47432;
            int64_t stride_tmp_50875 = next_stride_46996;
            
            if (memblock_set(ctx, &mem_param_50460, &mem_param_tmp_50867, "mem_param_tmp_50867") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_50463, &mem_param_tmp_50868, "mem_param_tmp_50868") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_50466, &mem_param_tmp_50869, "mem_param_tmp_50869") != 0)
                return 1;
            loop_dz2084Uz2082U_46990 = loop_dz2084Uz2082U_tmp_50870;
            loop_while_46991 = loop_while_tmp_50871;
            stride_46995 = stride_tmp_50875;
        }
        if (memblock_set(ctx, &ext_mem_50638, &mem_param_50460, "mem_param_50460") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_50637, &mem_param_50463, "mem_param_50463") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_50636, &mem_param_50466, "mem_param_50466") != 0)
            return 1;
        data_46984 = loop_dz2084Uz2082U_46990;
        data_46985 = loop_while_46991;
        data_46989 = stride_46995;
        if (memblock_unref(ctx, &mem_50448, "mem_50448") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50452, "mem_50452") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50456, "mem_50456") != 0)
            return 1;
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:265:3-14
        
        bool i_p_m_t_s_leq_w_47433 = slt64(zp_lhs_48712, data_46984);
        
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:265:3-14
        
        bool ok_or_empty_47435 = empty_slice_46873 || i_p_m_t_s_leq_w_47433;
        
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:265:3-14
        
        bool index_certs_47436;
        
        if (!ok_or_empty_47435) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) replicate_arg0_48713, "] out of bounds for array of shape [", (long long) data_46984, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:265:3-14\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:375:19-85\n   #6  trmodel_test.fut:168:7-172:30\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        if (memblock_set(ctx, &ext_mem_50647, &ext_mem_50638, "ext_mem_50638") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_50644, &ext_mem_50637, "ext_mem_50637") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_50641, &ext_mem_50636, "ext_mem_50636") != 0)
            return 1;
    }
    if (memblock_unref(ctx, &mem_50339, "mem_50339") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50341, "mem_50341") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50343, "mem_50343") != 0)
        return 1;
    // ../lib/github.com/diku-dk/sparse/mono.fut:79:17-81:38
    if (mem_50648_cached_sizze_51008 < replicate_arg0_48713) {
        err = lexical_realloc(ctx, &mem_50648, &mem_50648_cached_sizze_51008, replicate_arg0_48713);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // ../lib/github.com/diku-dk/sparse/mono.fut:79:17-81:38
    for (int64_t i_50053 = 0; i_50053 < replicate_arg0_48713; i_50053++) {
        int64_t eta_p_49172 = ((int64_t *) ext_mem_50647.mem)[i_50053];
        int64_t eta_p_49173 = ((int64_t *) ext_mem_50644.mem)[i_50053];
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:81:23-38
        
        int64_t zv_lhs_49174 = add64((int64_t) -1, i_50053);
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:81:23-38
        
        int64_t tmp_49175 = smod64(zv_lhs_49174, replicate_arg0_48713);
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:81:23-38
        
        int64_t lifted_lambda_res_49176 = ((int64_t *) ext_mem_50647.mem)[tmp_49175];
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:81:23-38
        
        int64_t lifted_lambda_res_49177 = ((int64_t *) ext_mem_50644.mem)[tmp_49175];
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:79:47-63
        
        bool cond_49180 = eta_p_49172 == lifted_lambda_res_49176;
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:79:47-63
        
        bool cond_49181 = !cond_49180;
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:79:59-63
        
        bool lifted_lambda_res_f_res_49182 = eta_p_49173 == lifted_lambda_res_49177;
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:79:59-63
        
        bool lifted_lambda_res_f_res_49183 = !lifted_lambda_res_f_res_49182;
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:79:17-81:38
        
        bool y_49184 = cond_49180 && lifted_lambda_res_f_res_49183;
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:79:17-81:38
        
        bool lifted_lambda_res_49185 = cond_49181 || y_49184;
        
        ((bool *) mem_50648)[i_50053] = lifted_lambda_res_49185;
    }
    // ../lib/github.com/diku-dk/sparse/mono.fut:82:17-83:27
    
    bool cond_47458 = sle64((int64_t) 1, replicate_arg0_48713);
    
    // ../lib/github.com/diku-dk/sparse/mono.fut:89:18-30
    
    bool loop_not_taken_47459 = !cond_47458;
    
    // ../lib/github.com/diku-dk/sparse/mono.fut:89:18-30
    
    bool protect_assert_disj_47460 = y_46817 || loop_not_taken_47459;
    
    // ../lib/github.com/diku-dk/sparse/mono.fut:82:34-55
    
    bool index_certs_47461;
    
    if (!protect_assert_disj_47460) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) replicate_arg0_48713, "].", "-> #0  ../lib/github.com/diku-dk/sparse/mono.fut:82:34-55\n   #1  ../lib/github.com/diku-dk/sparse/mono.fut:89:21-30\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #3  trmodel.fut:375:19-85\n   #4  trmodel_test.fut:168:7-172:30\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // ../lib/github.com/diku-dk/sparse/mono.fut:82:17-83:27
    if (cond_47458) {
        // ../lib/github.com/diku-dk/sparse/mono.fut:82:34-55
        ((bool *) mem_50648)[(int64_t) 0] = 1;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:21:38-28:71
    if (mem_50656_cached_sizze_51009 < bytes_50338) {
        err = lexical_realloc(ctx, &mem_50656, &mem_50656_cached_sizze_51009, bytes_50338);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:21:38-28:71
    if (mem_50657_cached_sizze_51010 < replicate_arg0_48713) {
        err = lexical_realloc(ctx, &mem_50657, &mem_50657_cached_sizze_51010, replicate_arg0_48713);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:21:38-28:71
    
    int64_t discard_50063;
    int64_t scanacc_50057 = (int64_t) 0;
    
    for (int64_t i_50060 = 0; i_50060 < replicate_arg0_48713; i_50060++) {
        // ../lib/github.com/diku-dk/segmented/segmented.fut:26:22-36
        
        int64_t zv_lhs_48845 = add64((int64_t) 1, i_50060);
        
        // ../lib/github.com/diku-dk/segmented/segmented.fut:26:22-36
        
        int64_t tmp_48846 = smod64(zv_lhs_48845, replicate_arg0_48713);
        
        // ../lib/github.com/diku-dk/segmented/segmented.fut:26:22-36
        
        bool lifted_lambda_res_48847 = ((bool *) mem_50648)[tmp_48846];
        
        // ../lib/github.com/diku-dk/segmented/segmented.fut:28:49-57
        
        int64_t bool_res_48849 = btoi_bool_i64(lifted_lambda_res_48847);
        
        // ../lib/github.com/diku-dk/segmented/segmented.fut:28:66-69
        
        int64_t defunc_0_op_res_47497 = add64(bool_res_48849, scanacc_50057);
        
        ((int64_t *) mem_50656)[i_50060] = defunc_0_op_res_47497;
        ((bool *) mem_50657)[i_50060] = lifted_lambda_res_48847;
        
        int64_t scanacc_tmp_50905 = defunc_0_op_res_47497;
        
        scanacc_50057 = scanacc_tmp_50905;
    }
    discard_50063 = scanacc_50057;
    // ../lib/github.com/diku-dk/segmented/segmented.fut:29:36-60
    
    int64_t num_segments_t_res_47498;
    
    if (y_46817) {
        // ../lib/github.com/diku-dk/sparse/mono.fut:85:8-86:49
        
        bool y_49887 = slt64(zp_lhs_48712, replicate_arg0_48713);
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:85:8-86:49
        
        bool index_certs_49888;
        
        if (!y_49887) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) zp_lhs_48712, "] out of bounds for array of shape [", (long long) replicate_arg0_48713, "].", "-> #0  ../lib/github.com/diku-dk/sparse/mono.fut:85:8-86:49\n   #1  ../lib/github.com/diku-dk/sparse/mono.fut:89:21-30\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #3  trmodel.fut:375:19-85\n   #4  trmodel_test.fut:168:7-172:30\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        // ../lib/github.com/diku-dk/sparse/mono.fut:85:8-86:49
        
        int64_t last_res_49889 = ((int64_t *) mem_50656)[zp_lhs_48712];
        
        num_segments_t_res_47498 = last_res_49889;
    } else {
        num_segments_t_res_47498 = (int64_t) 0;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:29:22-67
    
    int64_t num_segments_47503;
    
    if (y_46817) {
        num_segments_47503 = num_segments_t_res_47498;
    } else {
        num_segments_47503 = (int64_t) 0;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:33:17-42
    
    int64_t bytes_50670 = (int64_t) 8 * num_segments_47503;
    
    // trmodel.fut:395:24-34
    
    bool y_47566 = slt64((int64_t) 0, replicate_arg0_48715);
    
    // trmodel.fut:395:24-34
    
    bool i_p_m_t_s_leq_w_47563 = slt64(zp_lhs_48712, replicate_arg0_48713);
    
    // trmodel.fut:395:24-34
    
    bool ok_or_empty_47565 = empty_slice_46873 || i_p_m_t_s_leq_w_47563;
    
    // trmodel.fut:395:24-34
    
    bool index_ok_47567 = ok_or_empty_47565 && y_47566;
    
    // trmodel.fut:395:24-34
    
    bool index_certs_47568;
    
    if (!index_ok_47567) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":, ", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) replicate_arg0_48713, "][", (long long) replicate_arg0_48715, "].", "-> #0  trmodel.fut:395:24-34\n   #1  trmodel.fut:428:15-429:27\n   #2  trmodel_test.fut:168:7-174:31\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // trmodel.fut:404:11-27
    
    bool empty_slice_47581 = zp_lhs_48712 == (int64_t) 0;
    
    // trmodel.fut:406:24-26
    
    int64_t utils_trade_47590 = sub64(replicate_arg0_48715, (int64_t) 1);
    
    // trmodel.fut:406:12-27
    
    int64_t j_m_i_47591 = sub64(utils_trade_47590, (int64_t) 1);
    
    // trmodel.fut:406:12-27
    
    bool empty_slice_47592 = j_m_i_47591 == (int64_t) 0;
    
    // trmodel.fut:406:12-27
    
    bool zzero_leq_i_p_m_t_s_47593 = sle64((int64_t) 0, j_m_i_47591);
    
    // trmodel.fut:406:12-27
    
    bool i_p_m_t_s_leq_w_47594 = slt64(j_m_i_47591, replicate_arg0_48715);
    
    // trmodel.fut:406:12-27
    
    bool i_lte_j_47595 = sle64((int64_t) 1, utils_trade_47590);
    
    // trmodel.fut:406:12-27
    
    bool y_47596 = zzero_leq_i_p_m_t_s_47593 && i_p_m_t_s_leq_w_47594;
    
    // trmodel.fut:406:12-27
    
    bool forwards_ok_47597 = i_lte_j_47595 && y_47596;
    
    // trmodel.fut:406:12-27
    
    bool ok_or_empty_47598 = empty_slice_47592 || forwards_ok_47597;
    
    // trmodel.fut:406:12-27
    
    bool index_ok_47599 = ok_or_empty_47565 && ok_or_empty_47598;
    
    // trmodel.fut:406:12-27
    
    bool index_certs_47600;
    
    if (!index_ok_47599) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":, ", (long long) (int64_t) 1, ":", (long long) utils_trade_47590, "] out of bounds for array of shape [", (long long) replicate_arg0_48713, "][", (long long) replicate_arg0_48715, "].", "-> #0  trmodel.fut:406:12-27\n   #1  trmodel.fut:428:15-429:27\n   #2  trmodel_test.fut:168:7-174:31\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // trmodel.fut:428:15-429:27
    
    bool dim_match_47601 = zp_lhs_48712 == j_m_i_47591;
    
    // trmodel.fut:428:15-429:27
    
    bool empty_or_match_cert_47602;
    
    if (!dim_match_47601) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Value of (desugared) shape [", (long long) replicate_arg0_48713, "][", (long long) j_m_i_47591, "] cannot match shape of type \"[", (long long) replicate_arg0_48713, "][", (long long) zp_lhs_48712, "]f64\".", "-> #0  trmodel.fut:428:15-429:27\n   #1  trmodel_test.fut:168:7-174:31\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // trmodel.fut:411:25-38
    
    bool x_47610 = sle64((int64_t) 0, utils_trade_47590);
    
    // trmodel.fut:411:25-38
    
    bool y_47611 = slt64(utils_trade_47590, replicate_arg0_48715);
    
    // trmodel.fut:411:25-38
    
    bool bounds_check_47612 = x_47610 && y_47611;
    
    // trmodel.fut:411:25-38
    
    bool index_ok_47613 = ok_or_empty_47565 && bounds_check_47612;
    
    // trmodel.fut:411:25-38
    
    bool index_certs_47614;
    
    if (!index_ok_47613) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":, ", (long long) utils_trade_47590, "] out of bounds for array of shape [", (long long) replicate_arg0_48713, "][", (long long) replicate_arg0_48715, "].", "-> #0  trmodel.fut:411:25-38\n   #1  trmodel.fut:428:15-429:27\n   #2  trmodel_test.fut:168:7-174:31\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // trmodel.fut:417:28-63
    
    int64_t bytes_50689 = replicate_arg0_48715 * bytes_50338;
    
    // trmodel.fut:420:11-39
    
    bool i_p_m_t_s_leq_w_47622 = slt64(zp_lhs_48712, replicate_arg0_48715);
    
    // trmodel.fut:420:11-39
    
    bool forwards_ok_47624 = cond_47458 && i_p_m_t_s_leq_w_47622;
    
    // trmodel.fut:420:11-39
    
    bool ok_or_empty_47625 = empty_slice_47581 || forwards_ok_47624;
    
    // trmodel.fut:420:11-39
    
    bool index_ok_47626 = ok_or_empty_47565 && ok_or_empty_47625;
    
    // trmodel.fut:420:11-39
    
    bool index_certs_47627;
    
    if (!index_ok_47626) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":, ", (long long) (int64_t) 1, ":", (long long) replicate_arg0_48713, "] out of bounds for array of shape [", (long long) replicate_arg0_48713, "][", (long long) replicate_arg0_48715, "].", "-> #0  trmodel.fut:420:11-39\n   #1  trmodel.fut:428:15-429:27\n   #2  trmodel_test.fut:168:7-174:31\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // trmodel.fut:123:24-46
    if (memblock_alloc(ctx, &mem_50259, bytes_50258, "mem_50259")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:123:24-46
    for (int64_t nest_i_50908 = 0; nest_i_50908 < n_36763; nest_i_50908++) {
        ((double *) mem_50259.mem)[nest_i_50908] = 0.10000000149011612;
    }
    // trmodel.fut:124:47-52
    
    double i64_res_48703 = sitofp_i64_f64(n_36763);
    
    // trmodel.fut:124:39-52
    
    double zs_res_48704 = 1.0 / i64_res_48703;
    
    // trmodel.fut:124:24-52
    if (memblock_alloc(ctx, &mem_50261, bytes_50258, "mem_50261")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:124:24-52
    for (int64_t nest_i_50909 = 0; nest_i_50909 < n_36763; nest_i_50909++) {
        ((double *) mem_50261.mem)[nest_i_50909] = zs_res_48704;
    }
    // trmodel.fut:126:24-44
    if (memblock_alloc(ctx, &mem_50263, bytes_50262, "mem_50263")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:126:24-44
    for (int64_t nest_i_50910 = 0; nest_i_50910 < c_36762; nest_i_50910++) {
        ((double *) mem_50263.mem)[nest_i_50910] = 1.0;
    }
    // trmodel.fut:127:24-44
    if (memblock_alloc(ctx, &mem_50265, bytes_50258, "mem_50265")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:127:24-44
    for (int64_t nest_i_50911 = 0; nest_i_50911 < n_36763; nest_i_50911++) {
        ((double *) mem_50265.mem)[nest_i_50911] = 0.0;
    }
    // trmodel_test.fut:167:49-62
    if (memblock_alloc(ctx, &mem_50268, bytes_50267, "mem_50268")) {
        err = 1;
        goto cleanup;
    }
    // trmodel_test.fut:167:49-62
    for (int64_t nest_i_50912 = 0; nest_i_50912 < n_36763; nest_i_50912++) {
        for (int64_t nest_i_50913 = 0; nest_i_50913 < c_36762; nest_i_50913++) {
            ((double *) mem_50268.mem)[nest_i_50912 * c_36762 + nest_i_50913] = 6.0;
        }
    }
    // trmodel_test.fut:167:49-62
    if (memblock_alloc(ctx, &mem_50271, bytes_50267, "mem_50271")) {
        err = 1;
        goto cleanup;
    }
    // trmodel_test.fut:167:49-62
    for (int64_t nest_i_50914 = 0; nest_i_50914 < n_36763; nest_i_50914++) {
        for (int64_t nest_i_50915 = 0; nest_i_50915 < c_36762; nest_i_50915++) {
            ((double *) mem_50271.mem)[nest_i_50914 * c_36762 + nest_i_50915] = -0.5;
        }
    }
    // trmodel_test.fut:167:49-62
    if (memblock_alloc(ctx, &mem_50274, bytes_50267, "mem_50274")) {
        err = 1;
        goto cleanup;
    }
    // trmodel_test.fut:167:49-62
    for (int64_t nest_i_50916 = 0; nest_i_50916 < n_36763; nest_i_50916++) {
        for (int64_t nest_i_50917 = 0; nest_i_50917 < c_36762; nest_i_50917++) {
            ((double *) mem_50274.mem)[nest_i_50916 * c_36762 + nest_i_50917] = 0.0;
        }
    }
    // trmodel.fut:133:24-45
    if (memblock_alloc(ctx, &mem_50275, (int64_t) 0, "mem_50275")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:133:24-45
    for (int64_t nest_i_50918 = 0; nest_i_50918 < replicate_arg0_48713; nest_i_50918++) { }
    // trmodel.fut:134:24-45
    if (memblock_alloc(ctx, &mem_50276, (int64_t) 0, "mem_50276")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:134:24-45
    for (int64_t nest_i_50919 = 0; nest_i_50919 < replicate_arg0_48715; nest_i_50919++) { }
    // trmodel.fut:135:24-39
    if (memblock_alloc(ctx, &mem_50277, (int64_t) 0, "mem_50277")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:135:24-39
    for (int64_t nest_i_50920 = 0; nest_i_50920 < Ax_36765; nest_i_50920++) { }
    // trmodel.fut:136:24-48
    if (memblock_alloc(ctx, &mem_50279, bytes_50262, "mem_50279")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:136:24-48
    for (int64_t nest_i_50921 = 0; nest_i_50921 < c_36762; nest_i_50921++) {
        ((double *) mem_50279.mem)[nest_i_50921] = -10.0;
    }
    // trmodel.fut:137:24-44
    if (memblock_alloc(ctx, &mem_50281, bytes_50262, "mem_50281")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:137:24-44
    for (int64_t nest_i_50922 = 0; nest_i_50922 < c_36762; nest_i_50922++) {
        ((double *) mem_50281.mem)[nest_i_50922] = 0.0;
    }
    // trmodel.fut:180:28-68
    if (mem_50283_cached_sizze_50989 < bytes_50282) {
        err = lexical_realloc(ctx, &mem_50283, &mem_50283_cached_sizze_50989, bytes_50282);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:180:28-68
    
    double discard_49983;
    double scanacc_49979 = 1.0;
    
    for (int64_t i_49981 = 0; i_49981 < dzlz7bUZLzmZRz20UAxz20U1z7dUzg_46739; i_49981++) {
        // trmodel.fut:180:33-38
        
        double zt_res_46745 = 0.85 * scanacc_49979;
        
        ((double *) mem_50283)[i_49981] = zt_res_46745;
        
        double scanacc_tmp_50923 = zt_res_46745;
        
        scanacc_49979 = scanacc_tmp_50923;
    }
    discard_49983 = scanacc_49979;
    // trmodel.fut:180:75-181:53
    if (mem_50292_cached_sizze_50990 < bytes_50291) {
        err = lexical_realloc(ctx, &mem_50292, &mem_50292_cached_sizze_50990, bytes_50291);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:180:75-181:53
    for (int64_t i_49990 = 0; i_49990 < c_36762; i_49990++) {
        double eta_p_46749 = ((double *) newprices_mem_50257.mem)[i_49990];
        
        // trmodel.fut:181:30-44
        for (int64_t i_49986 = 0; i_49986 < Ax_36765; i_49986++) {
            bool index_concat_cmp_50244 = sle64((int64_t) 1, i_49986);
            double index_concat_branch_50248;
            
            if (index_concat_cmp_50244) {
                int64_t index_concat_i_50245 = sub64(i_49986, (int64_t) 1);
                double index_concat_50246 = ((double *) mem_50283)[index_concat_i_50245];
                
                index_concat_branch_50248 = index_concat_50246;
            } else {
                index_concat_branch_50248 = 1.0;
            }
            // trmodel.fut:181:34-41
            
            double zt_res_46752 = eta_p_46749 * index_concat_branch_50248;
            
            ((double *) mem_50292)[i_49990 * Ax_36765 + i_49986] = zt_res_46752;
        }
    }
    // trmodel_test.fut:168:7-171:57
    if (memblock_alloc(ctx, &mem_50311, bytes_50310, "mem_50311")) {
        err = 1;
        goto cleanup;
    }
    // trmodel_test.fut:168:7-171:57
    // trmodel_test.fut:168:7-171:57
    lmad_copy_8b(ctx, 2, (uint64_t *) mem_50311.mem, (int64_t) 0, (int64_t []) {c_36762, (int64_t) 1}, (uint64_t *) mem_50292, (int64_t) 0, (int64_t []) {(int64_t) 1, Ax_36765}, (int64_t []) {Ax_36765, c_36762});
    // trmodel_test.fut:168:7-171:57
    if (futrts_utility_10336(ctx, &ext_mem_50313, mem_50279, mem_50281, mem_50281, mem_50277, mem_50259, mem_50276, mem_50275, newprices_mem_50257, mem_50263, mem_50265, mem_50261, mem_50268, mem_50271, mem_50274, mem_50311, n_36763, c_36762, Ax_36765, replicate_arg0_48713, replicate_arg0_48715, 0.949999988079071, 1.0, 0.5, (int64_t) 1) != 0) {
        err = 1;
        goto cleanup;
    }
    if (memblock_unref(ctx, &mem_50259, "mem_50259") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50261, "mem_50261") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50263, "mem_50263") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50265, "mem_50265") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50268, "mem_50268") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50271, "mem_50271") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50274, "mem_50274") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50275, "mem_50275") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50276, "mem_50276") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50277, "mem_50277") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50279, "mem_50279") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50281, "mem_50281") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50311, "mem_50311") != 0)
        return 1;
    // ../lib/github.com/diku-dk/segmented/segmented.fut:33:17-42
    if (mem_50671_cached_sizze_51011 < bytes_50670) {
        err = lexical_realloc(ctx, &mem_50671, &mem_50671_cached_sizze_51011, bytes_50670);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:33:17-42
    for (int64_t nest_i_50927 = 0; nest_i_50927 < num_segments_47503; nest_i_50927++) {
        ((double *) mem_50671)[nest_i_50927] = 0.0;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:33:17-42
    if (mem_50673_cached_sizze_51012 < bytes_50670) {
        err = lexical_realloc(ctx, &mem_50673, &mem_50673_cached_sizze_51012, bytes_50670);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:33:17-42
    for (int64_t nest_i_50928 = 0; nest_i_50928 < num_segments_47503; nest_i_50928++) {
        ((int64_t *) mem_50673)[nest_i_50928] = (int64_t) 0;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:33:17-42
    if (mem_50675_cached_sizze_51013 < bytes_50670) {
        err = lexical_realloc(ctx, &mem_50675, &mem_50675_cached_sizze_51013, bytes_50670);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:33:17-42
    for (int64_t nest_i_50929 = 0; nest_i_50929 < num_segments_47503; nest_i_50929++) {
        ((int64_t *) mem_50675)[nest_i_50929] = (int64_t) 0;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:37:6-71
    
    bool acc_cert_48856;
    bool acc_cert_48857;
    bool acc_cert_48858;
    
    // ../lib/github.com/diku-dk/segmented/segmented.fut:37:6-71
    
    int64_t inpacc_49876;
    int64_t inpacc_49877;
    double inpacc_49878;
    int64_t inpacc_49009;
    int64_t inpacc_49010;
    double inpacc_49011;
    
    inpacc_49009 = (int64_t) 0;
    inpacc_49010 = (int64_t) 0;
    inpacc_49011 = 0.0;
    for (int64_t i_50117 = 0; i_50117 < replicate_arg0_48713; i_50117++) {
        bool x_50163 = ((bool *) mem_50648)[i_50117];
        int64_t x_50164 = ((int64_t *) ext_mem_50647.mem)[i_50117];
        int64_t x_50165 = ((int64_t *) ext_mem_50644.mem)[i_50117];
        double x_50166 = ((double *) ext_mem_50641.mem)[i_50117];
        
        // ../lib/github.com/diku-dk/segmented/segmented.fut:9:11-13:24
        
        int64_t tmp_50176;
        
        if (x_50163) {
            tmp_50176 = x_50164;
        } else {
            tmp_50176 = (int64_t) 0;
        }
        // ../lib/github.com/diku-dk/segmented/segmented.fut:9:11-13:24
        
        int64_t tmp_50177;
        
        if (x_50163) {
            tmp_50177 = x_50165;
        } else {
            tmp_50177 = (int64_t) 0;
        }
        
        int64_t eta_p_50197 = ((int64_t *) mem_50656)[i_50117];
        bool eta_p_50198 = ((bool *) mem_50657)[i_50117];
        
        // ../lib/github.com/diku-dk/segmented/segmented.fut:9:11-13:24
        
        int64_t tmp_50203;
        
        if (x_50163) {
            tmp_50203 = tmp_50176;
        } else {
            tmp_50203 = inpacc_49009;
        }
        // ../lib/github.com/diku-dk/segmented/segmented.fut:9:11-13:24
        
        int64_t tmp_50204;
        
        if (x_50163) {
            tmp_50204 = tmp_50177;
        } else {
            tmp_50204 = inpacc_49010;
        }
        // ../lib/github.com/diku-dk/segmented/segmented.fut:9:11-13:24
        
        double tmp_50205;
        
        if (x_50163) {
            tmp_50205 = x_50166;
        } else {
            // ../lib/github.com/diku-dk/sparse/mono.fut:85:57-66
            
            double zp_res_50206 = inpacc_49011 + x_50166;
            
            tmp_50205 = zp_res_50206;
        }
        // ../lib/github.com/diku-dk/segmented/segmented.fut:36:19-40
        
        int64_t lifted_index_res_50207;
        
        if (eta_p_50198) {
            // ../lib/github.com/diku-dk/segmented/segmented.fut:36:30-32
            
            int64_t lifted_index_res_t_res_50208 = sub64(eta_p_50197, (int64_t) 1);
            
            lifted_index_res_50207 = lifted_index_res_t_res_50208;
        } else {
            lifted_index_res_50207 = (int64_t) -1;
        }
        // ../lib/github.com/diku-dk/segmented/segmented.fut:37:6-71
        // UpdateAcc
        if (sle64((int64_t) 0, lifted_index_res_50207) && slt64(lifted_index_res_50207, num_segments_47503)) {
            ((int64_t *) mem_50675)[lifted_index_res_50207] = tmp_50203;
        }
        // ../lib/github.com/diku-dk/segmented/segmented.fut:37:6-71
        // UpdateAcc
        if (sle64((int64_t) 0, lifted_index_res_50207) && slt64(lifted_index_res_50207, num_segments_47503)) {
            ((int64_t *) mem_50673)[lifted_index_res_50207] = tmp_50204;
        }
        // ../lib/github.com/diku-dk/segmented/segmented.fut:37:6-71
        // UpdateAcc
        if (sle64((int64_t) 0, lifted_index_res_50207) && slt64(lifted_index_res_50207, num_segments_47503)) {
            ((double *) mem_50671)[lifted_index_res_50207] = tmp_50205;
        }
        // ../lib/github.com/diku-dk/segmented/segmented.fut:9:11-13:24
        
        double tmp_49080;
        
        if (x_50163) {
            tmp_49080 = x_50166;
        } else {
            // ../lib/github.com/diku-dk/sparse/mono.fut:85:57-66
            
            double zp_res_49081 = inpacc_49011 + x_50166;
            
            tmp_49080 = zp_res_49081;
        }
        
        int64_t inpacc_tmp_50930 = tmp_50203;
        int64_t inpacc_tmp_50931 = tmp_50204;
        double inpacc_tmp_50932 = tmp_49080;
        
        inpacc_49009 = inpacc_tmp_50930;
        inpacc_49010 = inpacc_tmp_50931;
        inpacc_49011 = inpacc_tmp_50932;
    }
    inpacc_49876 = inpacc_49009;
    inpacc_49877 = inpacc_49010;
    inpacc_49878 = inpacc_49011;
    if (memblock_unref(ctx, &ext_mem_50641, "ext_mem_50641") != 0)
        return 1;
    if (memblock_unref(ctx, &ext_mem_50644, "ext_mem_50644") != 0)
        return 1;
    if (memblock_unref(ctx, &ext_mem_50647, "ext_mem_50647") != 0)
        return 1;
    // ../lib/github.com/diku-dk/sparse/mono.fut:127:27-47
    if (mem_50677_cached_sizze_51014 < bytes_50338) {
        err = lexical_realloc(ctx, &mem_50677, &mem_50677_cached_sizze_51014, bytes_50338);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // ../lib/github.com/diku-dk/sparse/mono.fut:127:27-47
    for (int64_t nest_i_50936 = 0; nest_i_50936 < replicate_arg0_48713; nest_i_50936++) {
        ((double *) mem_50677)[nest_i_50936] = 0.0;
    }
    // ../lib/github.com/diku-dk/sparse/mono.fut:128:30-43
    if (mem_50679_cached_sizze_51015 < bytes_50338) {
        err = lexical_realloc(ctx, &mem_50679, &mem_50679_cached_sizze_51015, bytes_50338);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // ../lib/github.com/diku-dk/sparse/mono.fut:128:30-43
    for (int64_t nest_i_50937 = 0; nest_i_50937 < replicate_arg0_48713; nest_i_50937++) {
        ((int64_t *) mem_50679)[nest_i_50937] = (int64_t) 0;
    }
    // ../lib/github.com/diku-dk/sparse/mono.fut:127:18-128:50
    
    bool acc_cert_47536;
    bool acc_cert_47545;
    
    // ../lib/github.com/diku-dk/sparse/mono.fut:127:18-128:50
    for (int64_t i_50125 = 0; i_50125 < num_segments_47503; i_50125++) {
        int64_t v_49482 = ((int64_t *) mem_50675)[i_50125];
        double v_49483 = ((double *) mem_50671)[i_50125];
        int64_t v_49485 = ((int64_t *) mem_50673)[i_50125];
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:127:18-54
        // UpdateAcc
        if (sle64((int64_t) 0, v_49482) && slt64(v_49482, replicate_arg0_48713)) {
            ((double *) mem_50677)[v_49482] = v_49483;
        }
        // ../lib/github.com/diku-dk/sparse/mono.fut:128:21-50
        // UpdateAcc
        if (sle64((int64_t) 0, v_49482) && slt64(v_49482, replicate_arg0_48713)) {
            ((int64_t *) mem_50679)[v_49482] = v_49485;
        }
    }
    // trmodel.fut:143:5-23
    if (mem_50681_cached_sizze_51016 < bytes_50338) {
        err = lexical_realloc(ctx, &mem_50681, &mem_50681_cached_sizze_51016, bytes_50338);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:143:5-23
    for (int64_t i_50128 = 0; i_50128 < replicate_arg0_48713; i_50128++) {
        int64_t eta_p_48756 = ((int64_t *) mem_50679)[i_50128];
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:155:27-31
        
        bool x_48760 = sle64((int64_t) 0, eta_p_48756);
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:155:27-31
        
        bool y_48761 = slt64(eta_p_48756, replicate_arg0_48713);
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:155:27-31
        
        bool bounds_check_48762 = x_48760 && y_48761;
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:155:27-31
        
        bool index_certs_48763;
        
        if (!bounds_check_48762) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) eta_p_48756, "] out of bounds for array of shape [", (long long) replicate_arg0_48713, "].", "-> #0  ../lib/github.com/diku-dk/sparse/mono.fut:155:27-31\n   #1  trmodel.fut:394:9-29\n   #2  trmodel.fut:428:15-429:27\n   #3  trmodel_test.fut:168:7-174:31\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        double eta_p_48757 = ((double *) mem_50677)[i_50128];
        double eta_p_48758 = ((double *) ext_mem_50313.mem)[i_50128 * replicate_arg0_48715];
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:155:21-31
        
        double zt_res_48764 = 0.0 * eta_p_48757;
        
        // trmodel.fut:394:37-49
        
        double zt_res_48766 = 0.949999988079071 * zt_res_48764;
        
        // trmodel.fut:395:17-22
        
        double zp_res_48768 = eta_p_48758 + zt_res_48766;
        
        // trmodel.fut:396:26-56
        
        bool cond_48770 = i_50128 == zp_lhs_48712;
        
        // trmodel.fut:396:26-56
        
        double lifted_lambda_res_48771;
        
        if (cond_48770) {
            lifted_lambda_res_48771 = NAN;
        } else {
            lifted_lambda_res_48771 = zp_res_48768;
        }
        ((double *) mem_50681)[i_50128] = lifted_lambda_res_48771;
    }
    // trmodel.fut:417:28-63
    if (mem_50690_cached_sizze_51017 < bytes_50689) {
        err = lexical_realloc(ctx, &mem_50690, &mem_50690_cached_sizze_51017, bytes_50689);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:417:28-63
    for (int64_t nest_i_50941 = 0; nest_i_50941 < replicate_arg0_48713; nest_i_50941++) {
        for (int64_t nest_i_50942 = 0; nest_i_50942 < replicate_arg0_48715; nest_i_50942++) {
            ((double *) mem_50690)[nest_i_50941 * replicate_arg0_48715 + nest_i_50942] = 0.0;
        }
    }
    // trmodel.fut:419:11-24
    // trmodel.fut:419:11-24
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_50690, (int64_t) 0, (int64_t []) {replicate_arg0_48715}, (uint64_t *) mem_50681, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {replicate_arg0_48713});
    // trmodel.fut:420:11-39
    // trmodel.fut:420:11-39
    lmad_copy_8b(ctx, 2, (uint64_t *) mem_50690, (int64_t) 1, (int64_t []) {replicate_arg0_48715, (int64_t) 1}, (uint64_t *) ext_mem_50313.mem, (int64_t) 1, (int64_t []) {replicate_arg0_48715, (int64_t) 1}, (int64_t []) {replicate_arg0_48713, zp_lhs_48712});
    // trmodel.fut:421:11-28
    // trmodel.fut:421:11-28
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_50690, utils_trade_47590, (int64_t []) {replicate_arg0_48715}, (uint64_t *) ext_mem_50313.mem, utils_trade_47590, (int64_t []) {replicate_arg0_48715}, (int64_t []) {replicate_arg0_48713});
    if (memblock_unref(ctx, &ext_mem_50313, "ext_mem_50313") != 0)
        return 1;
    // trmodel.fut:417:21-426:34
    if (memblock_alloc(ctx, &mem_50692, bytes_50338, "mem_50692")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:417:21-426:34
    for (int64_t i_50136 = 0; i_50136 < replicate_arg0_48713; i_50136++) {
        // trmodel.fut:218:5-219:26
        
        double defunc_0_f_res_49892;
        double redout_50130 = -INFINITY;
        
        for (int64_t i_50131 = 0; i_50131 < replicate_arg0_48715; i_50131++) {
            double eta_p_49506 = ((double *) mem_50690)[i_50136 * replicate_arg0_48715 + i_50131];
            
            // trmodel.fut:218:16-49
            
            bool isnan_res_49507 = futrts_isnan64(eta_p_49506);
            
            // trmodel.fut:218:16-49
            
            double lifted_lambda_res_49508;
            
            if (isnan_res_49507) {
                lifted_lambda_res_49508 = -INFINITY;
            } else {
                lifted_lambda_res_49508 = eta_p_49506;
            }
            // trmodel.fut:219:12-17
            
            double max_res_47641 = fmax64(lifted_lambda_res_49508, redout_50130);
            double redout_tmp_50944 = max_res_47641;
            
            redout_50130 = redout_tmp_50944;
        }
        defunc_0_f_res_49892 = redout_50130;
        // trmodel.fut:227:5-228:27
        
        double defunc_0_f_res_49893;
        double redout_50132 = 0.0;
        
        for (int64_t i_50133 = 0; i_50133 < replicate_arg0_48715; i_50133++) {
            double eta_p_49498 = ((double *) mem_50690)[i_50136 * replicate_arg0_48715 + i_50133];
            
            // trmodel.fut:233:28-36
            
            double zm_res_49499 = eta_p_49498 - defunc_0_f_res_49892;
            
            // trmodel.fut:233:55-58
            
            double exp_res_49500 = futrts_exp64(zm_res_49499);
            
            // trmodel.fut:227:16-48
            
            bool isnan_res_49502 = futrts_isnan64(exp_res_49500);
            
            // trmodel.fut:227:16-48
            
            double lifted_lambda_res_49503;
            
            if (isnan_res_49502) {
                lifted_lambda_res_49503 = 0.0;
            } else {
                lifted_lambda_res_49503 = exp_res_49500;
            }
            // trmodel.fut:228:12-17
            
            double zp_res_47656 = lifted_lambda_res_49503 + redout_50132;
            double redout_tmp_50945 = zp_res_47656;
            
            redout_50132 = redout_tmp_50945;
        }
        defunc_0_f_res_49893 = redout_50132;
        // trmodel.fut:234:26-29
        
        double log_res_47657 = futrts_log64(defunc_0_f_res_49893);
        
        // trmodel.fut:234:45-53
        
        double zp_res_47659 = log_res_47657 + defunc_0_f_res_49892;
        
        ((double *) mem_50692.mem)[i_50136] = zp_res_47659;
    }
    if (memblock_set(ctx, &mem_out_50838, &mem_50692, "mem_50692") != 0)
        return 1;
    prim_out_50839 = replicate_arg0_48713;
    if (memblock_set(ctx, &*mem_out_p_50987, &mem_out_50838, "mem_out_50838") != 0)
        return 1;
    *out_prim_out_50988 = prim_out_50839;
    
  cleanup:
    {
        free(mem_50283);
        free(mem_50292);
        free(mem_50316);
        free(mem_50335);
        free(mem_50337);
        free(mem_50346);
        free(mem_50349);
        free(mem_50352);
        free(mem_50366);
        free(mem_50368);
        free(mem_50370);
        free(mem_50469);
        free(mem_50472);
        free(mem_50475);
        free(mem_50489);
        free(mem_50491);
        free(mem_50506);
        free(mem_50509);
        free(mem_50512);
        free(mem_50648);
        free(mem_50656);
        free(mem_50657);
        free(mem_50671);
        free(mem_50673);
        free(mem_50675);
        free(mem_50677);
        free(mem_50679);
        free(mem_50681);
        free(mem_50690);
        if (memblock_unref(ctx, &mem_50692, "mem_50692") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50313, "ext_mem_50313") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50311, "mem_50311") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50281, "mem_50281") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50279, "mem_50279") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50277, "mem_50277") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50276, "mem_50276") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50275, "mem_50275") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50274, "mem_50274") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50271, "mem_50271") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50268, "mem_50268") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50265, "mem_50265") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50263, "mem_50263") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50261, "mem_50261") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50259, "mem_50259") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_50869, "mem_param_tmp_50869") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_50868, "mem_param_tmp_50868") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_50867, "mem_param_tmp_50867") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50628, "mem_50628") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50624, "mem_50624") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50620, "mem_50620") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50571, "mem_50571") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50567, "mem_50567") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50563, "mem_50563") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50578, "mem_50578") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50576, "mem_50576") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50574, "mem_50574") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50599, "ext_mem_50599") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50602, "ext_mem_50602") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50605, "ext_mem_50605") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_50466, "mem_param_50466") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_50463, "mem_param_50463") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_50460, "mem_param_50460") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50636, "ext_mem_50636") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50637, "ext_mem_50637") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50638, "ext_mem_50638") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50456, "mem_50456") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50452, "mem_50452") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50448, "mem_50448") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50641, "ext_mem_50641") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50644, "ext_mem_50644") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50647, "ext_mem_50647") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50343, "mem_50343") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50341, "mem_50341") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50339, "mem_50339") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_50838, "mem_out_50838") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_test_bellmanN(struct futhark_context *ctx, struct memblock *mem_out_p_51018, int64_t *out_prim_out_51019, struct memblock newprices_mem_50257, int64_t c_36886, int64_t n_36887, int64_t Ax_36889, int64_t N_36890)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_50283_cached_sizze_51020 = 0;
    unsigned char *mem_50283 = NULL;
    int64_t mem_50292_cached_sizze_51021 = 0;
    unsigned char *mem_50292 = NULL;
    int64_t mem_50316_cached_sizze_51022 = 0;
    unsigned char *mem_50316 = NULL;
    int64_t mem_50335_cached_sizze_51023 = 0;
    unsigned char *mem_50335 = NULL;
    int64_t mem_50337_cached_sizze_51024 = 0;
    unsigned char *mem_50337 = NULL;
    int64_t mem_50346_cached_sizze_51025 = 0;
    unsigned char *mem_50346 = NULL;
    int64_t mem_50349_cached_sizze_51026 = 0;
    unsigned char *mem_50349 = NULL;
    int64_t mem_50352_cached_sizze_51027 = 0;
    unsigned char *mem_50352 = NULL;
    int64_t mem_50366_cached_sizze_51028 = 0;
    unsigned char *mem_50366 = NULL;
    int64_t mem_50368_cached_sizze_51029 = 0;
    unsigned char *mem_50368 = NULL;
    int64_t mem_50370_cached_sizze_51030 = 0;
    unsigned char *mem_50370 = NULL;
    int64_t mem_50469_cached_sizze_51031 = 0;
    unsigned char *mem_50469 = NULL;
    int64_t mem_50472_cached_sizze_51032 = 0;
    unsigned char *mem_50472 = NULL;
    int64_t mem_50475_cached_sizze_51033 = 0;
    unsigned char *mem_50475 = NULL;
    int64_t mem_50489_cached_sizze_51034 = 0;
    unsigned char *mem_50489 = NULL;
    int64_t mem_50491_cached_sizze_51035 = 0;
    unsigned char *mem_50491 = NULL;
    int64_t mem_50506_cached_sizze_51036 = 0;
    unsigned char *mem_50506 = NULL;
    int64_t mem_50509_cached_sizze_51037 = 0;
    unsigned char *mem_50509 = NULL;
    int64_t mem_50512_cached_sizze_51038 = 0;
    unsigned char *mem_50512 = NULL;
    int64_t mem_50648_cached_sizze_51039 = 0;
    unsigned char *mem_50648 = NULL;
    int64_t mem_50656_cached_sizze_51040 = 0;
    unsigned char *mem_50656 = NULL;
    int64_t mem_50657_cached_sizze_51041 = 0;
    unsigned char *mem_50657 = NULL;
    int64_t mem_50671_cached_sizze_51042 = 0;
    unsigned char *mem_50671 = NULL;
    int64_t mem_50673_cached_sizze_51043 = 0;
    unsigned char *mem_50673 = NULL;
    int64_t mem_50675_cached_sizze_51044 = 0;
    unsigned char *mem_50675 = NULL;
    int64_t mem_50677_cached_sizze_51045 = 0;
    unsigned char *mem_50677 = NULL;
    int64_t mem_50679_cached_sizze_51046 = 0;
    unsigned char *mem_50679 = NULL;
    int64_t mem_50686_cached_sizze_51047 = 0;
    unsigned char *mem_50686 = NULL;
    int64_t mem_50694_cached_sizze_51048 = 0;
    unsigned char *mem_50694 = NULL;
    int64_t mem_50697_cached_sizze_51049 = 0;
    unsigned char *mem_50697 = NULL;
    int64_t mem_50699_cached_sizze_51050 = 0;
    unsigned char *mem_50699 = NULL;
    int64_t mem_50730_cached_sizze_51051 = 0;
    unsigned char *mem_50730 = NULL;
    struct memblock mem_param_tmp_50941;
    
    mem_param_tmp_50941.references = NULL;
    
    struct memblock mem_50732;
    
    mem_50732.references = NULL;
    
    struct memblock mem_param_50684;
    
    mem_param_50684.references = NULL;
    
    struct memblock ext_mem_50741;
    
    ext_mem_50741.references = NULL;
    
    struct memblock mem_50681;
    
    mem_50681.references = NULL;
    
    struct memblock ext_mem_50313;
    
    ext_mem_50313.references = NULL;
    
    struct memblock mem_50311;
    
    mem_50311.references = NULL;
    
    struct memblock mem_50281;
    
    mem_50281.references = NULL;
    
    struct memblock mem_50279;
    
    mem_50279.references = NULL;
    
    struct memblock mem_50277;
    
    mem_50277.references = NULL;
    
    struct memblock mem_50276;
    
    mem_50276.references = NULL;
    
    struct memblock mem_50275;
    
    mem_50275.references = NULL;
    
    struct memblock mem_50274;
    
    mem_50274.references = NULL;
    
    struct memblock mem_50271;
    
    mem_50271.references = NULL;
    
    struct memblock mem_50268;
    
    mem_50268.references = NULL;
    
    struct memblock mem_50265;
    
    mem_50265.references = NULL;
    
    struct memblock mem_50263;
    
    mem_50263.references = NULL;
    
    struct memblock mem_50261;
    
    mem_50261.references = NULL;
    
    struct memblock mem_50259;
    
    mem_50259.references = NULL;
    
    struct memblock mem_param_tmp_50869;
    
    mem_param_tmp_50869.references = NULL;
    
    struct memblock mem_param_tmp_50868;
    
    mem_param_tmp_50868.references = NULL;
    
    struct memblock mem_param_tmp_50867;
    
    mem_param_tmp_50867.references = NULL;
    
    struct memblock mem_50628;
    
    mem_50628.references = NULL;
    
    struct memblock mem_50624;
    
    mem_50624.references = NULL;
    
    struct memblock mem_50620;
    
    mem_50620.references = NULL;
    
    struct memblock mem_50571;
    
    mem_50571.references = NULL;
    
    struct memblock mem_50567;
    
    mem_50567.references = NULL;
    
    struct memblock mem_50563;
    
    mem_50563.references = NULL;
    
    struct memblock mem_50578;
    
    mem_50578.references = NULL;
    
    struct memblock mem_50576;
    
    mem_50576.references = NULL;
    
    struct memblock mem_50574;
    
    mem_50574.references = NULL;
    
    struct memblock ext_mem_50599;
    
    ext_mem_50599.references = NULL;
    
    struct memblock ext_mem_50602;
    
    ext_mem_50602.references = NULL;
    
    struct memblock ext_mem_50605;
    
    ext_mem_50605.references = NULL;
    
    struct memblock mem_param_50466;
    
    mem_param_50466.references = NULL;
    
    struct memblock mem_param_50463;
    
    mem_param_50463.references = NULL;
    
    struct memblock mem_param_50460;
    
    mem_param_50460.references = NULL;
    
    struct memblock ext_mem_50636;
    
    ext_mem_50636.references = NULL;
    
    struct memblock ext_mem_50637;
    
    ext_mem_50637.references = NULL;
    
    struct memblock ext_mem_50638;
    
    ext_mem_50638.references = NULL;
    
    struct memblock mem_50456;
    
    mem_50456.references = NULL;
    
    struct memblock mem_50452;
    
    mem_50452.references = NULL;
    
    struct memblock mem_50448;
    
    mem_50448.references = NULL;
    
    struct memblock ext_mem_50641;
    
    ext_mem_50641.references = NULL;
    
    struct memblock ext_mem_50644;
    
    ext_mem_50644.references = NULL;
    
    struct memblock ext_mem_50647;
    
    ext_mem_50647.references = NULL;
    
    struct memblock mem_50343;
    
    mem_50343.references = NULL;
    
    struct memblock mem_50341;
    
    mem_50341.references = NULL;
    
    struct memblock mem_50339;
    
    mem_50339.references = NULL;
    
    struct memblock mem_out_50838;
    
    mem_out_50838.references = NULL;
    
    int64_t prim_out_50839;
    
    // trmodel.fut:123:24-46
    
    int64_t bytes_50258 = (int64_t) 8 * n_36887;
    
    // trmodel.fut:126:24-44
    
    int64_t bytes_50262 = (int64_t) 8 * c_36886;
    
    // trmodel_test.fut:185:49-62
    
    int64_t bytes_50267 = c_36886 * bytes_50258;
    
    // trmodel.fut:133:36-39
    
    int64_t zp_lhs_48712 = mul64(c_36886, Ax_36889);
    
    // trmodel.fut:133:39-41
    
    int64_t replicate_arg0_48713 = add64((int64_t) 1, zp_lhs_48712);
    
    // trmodel.fut:134:39-41
    
    int64_t replicate_arg0_48715 = add64((int64_t) 2, zp_lhs_48712);
    
    // trmodel.fut:180:61-65
    
    int64_t dzlz7bUZLzmZRz20UAxz20U1z7dUzg_46740 = sub64(Ax_36889, (int64_t) 1);
    
    // trmodel.fut:180:28-68
    
    int64_t bytes_50282 = (int64_t) 8 * dzlz7bUZLzmZRz20UAxz20U1z7dUzg_46740;
    
    // trmodel.fut:180:75-181:53
    
    int64_t bytes_50291 = Ax_36889 * bytes_50262;
    
    // trmodel_test.fut:186:7-189:57
    
    int64_t binop_x_50309 = (int64_t) 8 * Ax_36889;
    
    // trmodel_test.fut:186:7-189:57
    
    int64_t bytes_50310 = c_36886 * binop_x_50309;
    
    // trmodel.fut:367:8-370:41
    if (mem_50316_cached_sizze_51022 < bytes_50291) {
        err = lexical_realloc(ctx, &mem_50316, &mem_50316_cached_sizze_51022, bytes_50291);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:367:8-370:41
    for (int64_t i_49998 = 0; i_49998 < c_36886; i_49998++) {
        // trmodel.fut:367:8-370:41
        for (int64_t i_49994 = 0; i_49994 < Ax_36889; i_49994++) {
            // trmodel.fut:368:28-370:41
            
            bool cond_46764 = i_49994 == dzlz7bUZLzmZRz20UAxz20U1z7dUzg_46740;
            
            // trmodel.fut:368:28-370:41
            
            int64_t lifted_lambda_res_46765;
            
            if (cond_46764) {
                // trmodel.fut:369:34-37
                
                int64_t lifted_lambda_res_t_res_49662 = mul64(Ax_36889, i_49998);
                
                lifted_lambda_res_46765 = lifted_lambda_res_t_res_49662;
            } else {
                // trmodel.fut:370:34-37
                
                int64_t zp_lhs_46767 = mul64(Ax_36889, i_49998);
                
                // trmodel.fut:370:37-39
                
                int64_t zp_lhs_46768 = add64(zp_lhs_46767, i_49994);
                
                // trmodel.fut:370:39-41
                
                int64_t lifted_lambda_res_f_res_46769 = add64((int64_t) 1, zp_lhs_46768);
                
                lifted_lambda_res_46765 = lifted_lambda_res_f_res_46769;
            }
            ((int64_t *) mem_50316)[i_49998 * Ax_36889 + i_49994] = lifted_lambda_res_46765;
        }
    }
    // trmodel_test.fut:186:7-190:30
    if (mem_50335_cached_sizze_51023 < bytes_50291) {
        err = lexical_realloc(ctx, &mem_50335, &mem_50335_cached_sizze_51023, bytes_50291);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel_test.fut:186:7-190:30
    // trmodel_test.fut:186:7-190:30
    lmad_copy_8b(ctx, 2, (uint64_t *) mem_50335, (int64_t) 0, (int64_t []) {Ax_36889, (int64_t) 1}, (uint64_t *) mem_50316, (int64_t) 0, (int64_t []) {Ax_36889, (int64_t) 1}, (int64_t []) {c_36886, Ax_36889});
    // trmodel_test.fut:186:7-190:30
    if (mem_50337_cached_sizze_51024 < (int64_t) 8) {
        err = lexical_realloc(ctx, &mem_50337, &mem_50337_cached_sizze_51024, (int64_t) 8);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel_test.fut:186:7-190:30
    for (int64_t nest_i_50842 = 0; nest_i_50842 < (int64_t) 1; nest_i_50842++) {
        ((int64_t *) mem_50337)[nest_i_50842] = zp_lhs_48712;
    }
    // trmodel_test.fut:186:7-190:30
    
    int64_t bytes_50338 = (int64_t) 8 * replicate_arg0_48713;
    
    // trmodel_test.fut:186:7-190:30
    if (memblock_alloc(ctx, &mem_50339, bytes_50338, "mem_50339")) {
        err = 1;
        goto cleanup;
    }
    // trmodel_test.fut:186:7-190:30
    
    int64_t tmp_offs_50843 = (int64_t) 0;
    
    // trmodel_test.fut:186:7-190:30
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_50339.mem, tmp_offs_50843, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_50335, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {zp_lhs_48712});
    tmp_offs_50843 += zp_lhs_48712;
    // trmodel_test.fut:186:7-190:30
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_50339.mem, tmp_offs_50843, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_50337, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {(int64_t) 1});
    tmp_offs_50843 += (int64_t) 1;
    // trmodel.fut:375:36-84
    if (memblock_alloc(ctx, &mem_50341, bytes_50338, "mem_50341")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:375:36-84
    for (int64_t i_50844 = 0; i_50844 < replicate_arg0_48713; i_50844++) {
        int64_t x_50845 = (int64_t) 0 + i_50844 * (int64_t) 1;
        
        ((int64_t *) mem_50341.mem)[i_50844] = x_50845;
    }
    // trmodel.fut:375:36-84
    if (memblock_alloc(ctx, &mem_50343, bytes_50338, "mem_50343")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:375:36-84
    for (int64_t nest_i_50846 = 0; nest_i_50846 < replicate_arg0_48713; nest_i_50846++) {
        ((double *) mem_50343.mem)[nest_i_50846] = 1.0;
    }
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:226:3-265:14
    
    bool cond_46778 = sle64(replicate_arg0_48713, (int64_t) 1);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:231:34-50
    
    int64_t zp_rhs_46779 = sdiv_safe64(zp_lhs_48712, (int64_t) 20);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:231:26-50
    
    int64_t min_num_blocks_46780 = add64((int64_t) 1, zp_rhs_46779);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:184:3-39
    
    bool loop_cond_46781 = slt64((int64_t) 1, min_num_blocks_46780);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:184:3-39
    
    bool smallest_pow_2_geq_than_res_46782;
    int64_t smallest_pow_2_geq_than_res_46783;
    bool loop_while_46784;
    int64_t x_46785;
    
    loop_while_46784 = loop_cond_46781;
    x_46785 = (int64_t) 1;
    while (loop_while_46784) {
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:184:37-39
        
        int64_t loopres_46786 = mul64((int64_t) 2, x_46785);
        
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:184:29-32
        
        bool loop_cond_46787 = slt64(loopres_46786, min_num_blocks_46780);
        bool loop_while_tmp_50847 = loop_cond_46787;
        int64_t x_tmp_50848 = loopres_46786;
        
        loop_while_46784 = loop_while_tmp_50847;
        x_46785 = x_tmp_50848;
    }
    smallest_pow_2_geq_than_res_46782 = loop_while_46784;
    smallest_pow_2_geq_than_res_46783 = x_46785;
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:234:30-42
    
    bool zzero_46788 = smallest_pow_2_geq_than_res_46783 == (int64_t) 0;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:234:30-42
    
    bool nonzzero_46789 = !zzero_46788;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75
    
    bool protect_assert_disj_46790 = cond_46778 || nonzzero_46789;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:234:30-42
    
    bool nonzzero_cert_46791;
    
    if (!protect_assert_disj_46790) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:234:30-42\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:375:19-85\n   #6  trmodel_test.fut:186:7-190:30\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:234:30-42
    
    int64_t zp_rhs_46792 = sdiv_safe64(zp_lhs_48712, smallest_pow_2_geq_than_res_46783);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:234:22-42
    
    int64_t block_sizze_46793 = add64((int64_t) 1, zp_rhs_46792);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
    
    int64_t flat_dim_46794 = smallest_pow_2_geq_than_res_46783 * block_sizze_46793;
    bool x_46795 = !cond_46778;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:238:54-65
    
    int64_t greatest_divisor_leq_than_arg1_46796 = mul64((int64_t) 2, block_sizze_46793);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:11-71
    
    bool cond_46797 = slt64((int64_t) 8, greatest_divisor_leq_than_arg1_46796);
    int64_t d_46798;
    
    if (x_46795) {
        bool x_49664;
        int64_t x_49665;
        bool loop_while_49666;
        int64_t d_49667;
        
        loop_while_49666 = cond_46797;
        d_49667 = (int64_t) 1;
        while (loop_while_49666) {
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:69-71
            
            int64_t loopres_49668 = add64((int64_t) 1, d_49667);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:36-38
            
            bool zzero_49669 = loopres_49668 == (int64_t) 0;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:36-38
            
            bool nonzzero_49670 = !zzero_49669;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:36-38
            
            bool nonzzero_cert_49671;
            
            if (!nonzzero_49670) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:36-38\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:238:5-65\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:186:7-190:30\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:36-38
            
            int64_t zg_lhs_49672 = sdiv64(greatest_divisor_leq_than_arg1_46796, loopres_49668);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:35-64
            
            bool cond_49673 = slt64((int64_t) 8, zg_lhs_49672);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:35-64
            
            bool loop_cond_49674;
            
            if (cond_49673) {
                loop_cond_49674 = 1;
            } else {
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:57-59
                
                int64_t znze_lhs_49675 = smod64(greatest_divisor_leq_than_arg1_46796, loopres_49668);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:60-64
                
                bool loop_cond_f_res_49676 = znze_lhs_49675 == (int64_t) 0;
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:60-64
                
                bool loop_cond_f_res_49677 = !loop_cond_f_res_49676;
                
                loop_cond_49674 = loop_cond_f_res_49677;
            }
            
            bool loop_while_tmp_50849 = loop_cond_49674;
            int64_t d_tmp_50850 = loopres_49668;
            
            loop_while_49666 = loop_while_tmp_50849;
            d_49667 = d_tmp_50850;
        }
        x_49664 = loop_while_49666;
        x_49665 = d_49667;
        d_46798 = x_49665;
    } else {
        d_46798 = (int64_t) 0;
    }
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:191:7-9
    
    bool zzero_46813 = d_46798 == (int64_t) 0;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:191:7-9
    
    bool nonzzero_46814 = !zzero_46813;
    bool protect_assert_disj_46815 = cond_46778 || nonzzero_46814;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:191:7-9
    
    bool nonzzero_cert_46816;
    
    if (!protect_assert_disj_46815) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:191:7-9\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:238:5-65\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:186:7-190:30\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:191:7-9
    
    int64_t greatest_divisor_leq_than_res_46817 = sdiv_safe64(greatest_divisor_leq_than_arg1_46796, d_46798);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:60-64
    
    bool y_46818 = slt64((int64_t) 0, replicate_arg0_48713);
    bool protect_assert_disj_46819 = cond_46778 || y_46818;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:60-64
    
    bool index_certs_46820;
    
    if (!protect_assert_disj_46819) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) replicate_arg0_48713, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:60-64\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:375:19-85\n   #6  trmodel_test.fut:186:7-190:30\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool index_concat_cmp_46821 = sle64(zp_lhs_48712, (int64_t) 0);
    int64_t index_concat_branch_46822;
    
    if (x_46795) {
        bool x_49679 = !index_concat_cmp_46821;
        int64_t new_index_49680 = squot_safe64((int64_t) 0, Ax_36889);
        int64_t binop_y_49681 = Ax_36889 * new_index_49680;
        int64_t new_index_49682 = (int64_t) 0 - binop_y_49681;
        int64_t index_concat_49683;
        
        if (x_49679) {
            int64_t x_49684 = ((int64_t *) mem_50316)[new_index_49680 * Ax_36889 + new_index_49682];
            
            index_concat_49683 = x_49684;
        } else {
            index_concat_49683 = (int64_t) 0;
        }
        
        int64_t x_49685;
        
        if (index_concat_cmp_46821) {
            x_49685 = zp_lhs_48712;
        } else {
            x_49685 = index_concat_49683;
        }
        index_concat_branch_46822 = x_49685;
    } else {
        index_concat_branch_46822 = (int64_t) 0;
    }
    
    int64_t defunc_0_reduce_res_46830;
    int64_t defunc_0_reduce_res_46831;
    
    if (x_46795) {
        int64_t x_49689;
        int64_t x_49690;
        int64_t redout_50000;
        int64_t redout_50001;
        
        redout_50000 = (int64_t) 0;
        redout_50001 = index_concat_branch_46822;
        for (int64_t i_50003 = 0; i_50003 < replicate_arg0_48713; i_50003++) {
            bool index_concat_cmp_50233 = sle64(zp_lhs_48712, i_50003);
            int64_t index_concat_branch_50237;
            
            if (index_concat_cmp_50233) {
                index_concat_branch_50237 = zp_lhs_48712;
            } else {
                int64_t new_index_50250 = squot64(i_50003, Ax_36889);
                int64_t binop_y_50252 = Ax_36889 * new_index_50250;
                int64_t new_index_50253 = i_50003 - binop_y_50252;
                int64_t index_concat_50236 = ((int64_t *) mem_50316)[new_index_50250 * Ax_36889 + new_index_50253];
                
                index_concat_branch_50237 = index_concat_50236;
            }
            // ../lib/github.com/diku-dk/sparse/mono.fut:75:41-74
            
            bool cond_49701 = slt64(redout_50000, i_50003);
            
            // ../lib/github.com/diku-dk/sparse/mono.fut:75:53-73
            
            bool cond_49702 = redout_50000 == i_50003;
            
            // ../lib/github.com/diku-dk/sparse/mono.fut:75:68-73
            
            bool lifted_lambda_res_f_res_t_res_49703 = sle64(redout_50001, index_concat_branch_50237);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:34-58
            
            bool x_49704 = cond_49702 && lifted_lambda_res_f_res_t_res_49703;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:34-58
            
            bool x_49705 = !cond_49701;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:34-58
            
            bool y_49706 = x_49704 && x_49705;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:34-58
            
            bool lifted_lambda_res_49707 = cond_49701 || y_49706;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:18-66
            
            int64_t defunc_0_op_res_49708;
            
            if (lifted_lambda_res_49707) {
                defunc_0_op_res_49708 = i_50003;
            } else {
                defunc_0_op_res_49708 = redout_50000;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:18-66
            
            int64_t defunc_0_op_res_49709;
            
            if (lifted_lambda_res_49707) {
                defunc_0_op_res_49709 = index_concat_branch_50237;
            } else {
                defunc_0_op_res_49709 = redout_50001;
            }
            
            int64_t redout_tmp_50851 = defunc_0_op_res_49708;
            int64_t redout_tmp_50852 = defunc_0_op_res_49709;
            
            redout_50000 = redout_tmp_50851;
            redout_50001 = redout_tmp_50852;
        }
        x_49689 = redout_50000;
        x_49690 = redout_50001;
        defunc_0_reduce_res_46830 = x_49689;
        defunc_0_reduce_res_46831 = x_49690;
    } else {
        defunc_0_reduce_res_46830 = (int64_t) 0;
        defunc_0_reduce_res_46831 = (int64_t) 0;
    }
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
    
    bool bounds_invalid_upwards_46855 = slt64(smallest_pow_2_geq_than_res_46783, (int64_t) 0);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
    
    bool valid_46856 = !bounds_invalid_upwards_46855;
    bool protect_assert_disj_46857 = cond_46778 || valid_46856;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
    
    bool range_valid_c_46858;
    
    if (!protect_assert_disj_46857) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) smallest_pow_2_geq_than_res_46783, " is invalid.", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:375:19-85\n   #6  trmodel_test.fut:186:7-190:30\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:244:19-246:44
    
    bool bounds_invalid_upwards_46859 = slt64(block_sizze_46793, (int64_t) 0);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:244:19-246:44
    
    bool valid_46860 = !bounds_invalid_upwards_46859;
    bool protect_assert_disj_46861 = cond_46778 || valid_46860;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:244:19-246:44
    
    bool range_valid_c_46862;
    
    if (!protect_assert_disj_46861) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) block_sizze_46793, " is invalid.", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:244:19-246:44\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:375:19-85\n   #6  trmodel_test.fut:186:7-190:30\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:163:3-176:6
    
    bool cond_46863 = sle64(block_sizze_46793, (int64_t) 1);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:166:25-27
    
    int64_t tmp_46864 = sub64(block_sizze_46793, (int64_t) 2);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:166:3-176:6
    
    bool bounds_invalid_upwards_46865 = slt64(tmp_46864, (int64_t) 0);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:166:3-176:6
    
    int64_t distance_46866 = add64((int64_t) 1, tmp_46864);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:166:3-176:6
    
    bool valid_46867 = !bounds_invalid_upwards_46865;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
    
    bool protect_assert_disj_46868 = cond_46863 || valid_46867;
    bool protect_assert_disj_46869 = cond_46778 || protect_assert_disj_46868;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:166:3-176:6
    
    bool range_valid_c_46870;
    
    if (!protect_assert_disj_46869) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "...", (long long) tmp_46864, " is invalid.", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:166:3-176:6\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:248:7-37\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:186:7-190:30\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:251:5-262:26
    
    bool loop_cond_46871 = slt64(block_sizze_46793, flat_dim_46794);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:147:30-42
    
    bool zzero_46872 = greatest_divisor_leq_than_res_46817 == (int64_t) 0;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:147:30-42
    
    bool nonzzero_46873 = !zzero_46872;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:265:3-14
    
    bool empty_slice_46874 = replicate_arg0_48713 == (int64_t) 0;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
    
    int64_t binop_x_50344 = (int64_t) 8 * smallest_pow_2_geq_than_res_46783;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
    
    int64_t bytes_50345 = block_sizze_46793 * binop_x_50344;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:244:19-246:44
    
    int64_t bytes_50365 = (int64_t) 8 * block_sizze_46793;
    
    if (cond_46778) {
        if (memblock_set(ctx, &ext_mem_50647, &mem_50341, "mem_50341") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_50644, &mem_50339, "mem_50339") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_50641, &mem_50343, "mem_50343") != 0)
            return 1;
    } else {
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
        if (mem_50346_cached_sizze_51025 < bytes_50345) {
            err = lexical_realloc(ctx, &mem_50346, &mem_50346_cached_sizze_51025, bytes_50345);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
        if (mem_50349_cached_sizze_51026 < bytes_50345) {
            err = lexical_realloc(ctx, &mem_50349, &mem_50349_cached_sizze_51026, bytes_50345);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
        if (mem_50352_cached_sizze_51027 < bytes_50345) {
            err = lexical_realloc(ctx, &mem_50352, &mem_50352_cached_sizze_51027, bytes_50345);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:244:19-246:44
        if (mem_50366_cached_sizze_51028 < bytes_50365) {
            err = lexical_realloc(ctx, &mem_50366, &mem_50366_cached_sizze_51028, bytes_50365);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:244:19-246:44
        if (mem_50368_cached_sizze_51029 < bytes_50365) {
            err = lexical_realloc(ctx, &mem_50368, &mem_50368_cached_sizze_51029, bytes_50365);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:244:19-246:44
        if (mem_50370_cached_sizze_51030 < bytes_50365) {
            err = lexical_realloc(ctx, &mem_50370, &mem_50370_cached_sizze_51030, bytes_50365);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
        for (int64_t i_50020 = 0; i_50020 < smallest_pow_2_geq_than_res_46783; i_50020++) {
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:245:18-29
            
            int64_t zp_lhs_46885 = mul64(block_sizze_46793, i_50020);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:244:19-246:44
            for (int64_t i_50010 = 0; i_50010 < block_sizze_46793; i_50010++) {
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:245:30-33
                
                int64_t k_46890 = add64(zp_lhs_46885, i_50010);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:246:12-44
                
                bool cond_46891 = slt64(k_46890, replicate_arg0_48713);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:246:12-44
                
                int64_t lifted_lambda_res_46892;
                int64_t lifted_lambda_res_46893;
                double lifted_lambda_res_46894;
                
                if (cond_46891) {
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:246:26-30
                    
                    bool x_49717 = sle64((int64_t) 0, k_46890);
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:246:26-30
                    
                    bool bounds_check_49718 = cond_46891 && x_49717;
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:246:26-30
                    
                    bool index_certs_49719;
                    
                    if (!bounds_check_49718) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) k_46890, "] out of bounds for array of shape [", (long long) replicate_arg0_48713, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:246:26-30\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:375:19-85\n   #6  trmodel_test.fut:186:7-190:30\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    bool index_concat_cmp_49720 = sle64(zp_lhs_48712, k_46890);
                    int64_t index_concat_branch_49721;
                    
                    if (index_concat_cmp_49720) {
                        index_concat_branch_49721 = zp_lhs_48712;
                    } else {
                        int64_t new_index_49722 = squot64(k_46890, Ax_36889);
                        int64_t binop_y_49723 = Ax_36889 * new_index_49722;
                        int64_t new_index_49724 = k_46890 - binop_y_49723;
                        int64_t index_concat_49725 = ((int64_t *) mem_50316)[new_index_49722 * Ax_36889 + new_index_49724];
                        
                        index_concat_branch_49721 = index_concat_49725;
                    }
                    lifted_lambda_res_46892 = k_46890;
                    lifted_lambda_res_46893 = index_concat_branch_49721;
                    lifted_lambda_res_46894 = 1.0;
                } else {
                    lifted_lambda_res_46892 = defunc_0_reduce_res_46830;
                    lifted_lambda_res_46893 = defunc_0_reduce_res_46831;
                    lifted_lambda_res_46894 = 1.0;
                }
                ((int64_t *) mem_50366)[i_50010] = lifted_lambda_res_46892;
                ((int64_t *) mem_50368)[i_50010] = lifted_lambda_res_46893;
                ((double *) mem_50370)[i_50010] = lifted_lambda_res_46894;
            }
            if (!cond_46863) {
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:166:3-176:6
                for (int64_t i_46910 = 0; i_46910 < distance_46866; i_46910++) {
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:34-36
                    
                    int64_t gt_arg1_46914 = add64((int64_t) 1, i_46910);
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37
                    
                    bool x_46915 = sle64((int64_t) 0, gt_arg1_46914);
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37
                    
                    bool y_46916 = slt64(gt_arg1_46914, block_sizze_46793);
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37
                    
                    bool bounds_check_46917 = x_46915 && y_46916;
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37
                    
                    bool index_certs_46918;
                    
                    if (!bounds_check_46917) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) gt_arg1_46914, "] out of bounds for array of shape [", (long long) block_sizze_46793, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:248:7-37\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:186:7-190:30\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30
                    
                    bool y_46921 = slt64(i_46910, block_sizze_46793);
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30
                    
                    bool index_certs_46922;
                    
                    if (!y_46921) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_46910, "] out of bounds for array of shape [", (long long) block_sizze_46793, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:248:7-37\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:186:7-190:30\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37
                    
                    int64_t gt_arg1_46919 = ((int64_t *) mem_50366)[gt_arg1_46914];
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37
                    
                    int64_t gt_arg1_46920 = ((int64_t *) mem_50368)[gt_arg1_46914];
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30
                    
                    int64_t gt_arg0_46923 = ((int64_t *) mem_50366)[i_46910];
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30
                    
                    int64_t gt_arg0_46924 = ((int64_t *) mem_50368)[i_46910];
                    
                    // ../lib/github.com/diku-dk/sparse/mono.fut:75:41-74
                    
                    bool cond_46925 = slt64(gt_arg0_46923, gt_arg1_46919);
                    
                    // ../lib/github.com/diku-dk/sparse/mono.fut:75:53-73
                    
                    bool cond_46926 = gt_arg0_46923 == gt_arg1_46919;
                    
                    // ../lib/github.com/diku-dk/sparse/mono.fut:75:68-73
                    
                    bool lifted_lambda_res_f_res_t_res_46927 = sle64(gt_arg0_46924, gt_arg1_46920);
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:18-25
                    
                    bool x_46928 = cond_46926 && lifted_lambda_res_f_res_t_res_46927;
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:18-25
                    
                    bool x_46929 = !cond_46925;
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:18-25
                    
                    bool y_46930 = x_46928 && x_46929;
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:18-25
                    
                    bool lifted_lambda_res_46931 = cond_46925 || y_46930;
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:16-26
                    
                    bool defunc_0_lifted_gt_res_46932 = !lifted_lambda_res_46931;
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:168:7-174:17
                    
                    bool s_46933;
                    int64_t s_46937;
                    bool loop_while_46938;
                    int64_t j_46942;
                    
                    loop_while_46938 = defunc_0_lifted_gt_res_46932;
                    j_46942 = i_46910;
                    while (loop_while_46938) {
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28
                        
                        bool x_46943 = sle64((int64_t) 0, j_46942);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28
                        
                        bool y_46944 = slt64(j_46942, block_sizze_46793);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28
                        
                        bool bounds_check_46945 = x_46943 && y_46944;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28
                        
                        bool index_certs_46946;
                        
                        if (!bounds_check_46945) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_46942, "] out of bounds for array of shape [", (long long) block_sizze_46793, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:248:7-37\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:186:7-190:30\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:38-40
                        
                        int64_t copy_arg0_46950 = add64((int64_t) 1, j_46942);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41
                        
                        bool x_46951 = sle64((int64_t) 0, copy_arg0_46950);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41
                        
                        bool y_46952 = slt64(copy_arg0_46950, block_sizze_46793);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41
                        
                        bool bounds_check_46953 = x_46951 && y_46952;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41
                        
                        bool index_certs_46954;
                        
                        if (!bounds_check_46953) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) copy_arg0_46950, "] out of bounds for array of shape [", (long long) block_sizze_46793, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:248:7-37\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:186:7-190:30\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28
                        
                        int64_t copy_arg0_46947 = ((int64_t *) mem_50366)[j_46942];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28
                        
                        int64_t copy_arg0_46948 = ((int64_t *) mem_50368)[j_46942];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28
                        
                        double copy_arg0_46949 = ((double *) mem_50370)[j_46942];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41
                        
                        int64_t copy_arg0_46955 = ((int64_t *) mem_50366)[copy_arg0_46950];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41
                        
                        int64_t copy_arg0_46956 = ((int64_t *) mem_50368)[copy_arg0_46950];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41
                        
                        double copy_arg0_46957 = ((double *) mem_50370)[copy_arg0_46950];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:17-41
                        ((int64_t *) mem_50366)[j_46942] = copy_arg0_46955;
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:17-41
                        ((int64_t *) mem_50368)[j_46942] = copy_arg0_46956;
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:17-41
                        ((double *) mem_50370)[j_46942] = copy_arg0_46957;
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:172:17-35
                        ((int64_t *) mem_50366)[copy_arg0_46950] = copy_arg0_46947;
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:172:17-35
                        ((int64_t *) mem_50368)[copy_arg0_46950] = copy_arg0_46948;
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:172:17-35
                        ((double *) mem_50370)[copy_arg0_46950] = copy_arg0_46949;
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:174:14-16
                        
                        int64_t tmp_46964 = sub64(j_46942, (int64_t) 1);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:13-37
                        
                        bool cond_46965 = sle64((int64_t) 0, tmp_46964);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:13-37
                        
                        bool loop_cond_46966;
                        
                        if (cond_46965) {
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30
                            
                            bool y_49728 = slt64(tmp_46964, block_sizze_46793);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30
                            
                            bool bounds_check_49729 = cond_46965 && y_49728;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30
                            
                            bool index_certs_49730;
                            
                            if (!bounds_check_49729) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_46964, "] out of bounds for array of shape [", (long long) block_sizze_46793, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:248:7-37\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:186:7-190:30\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37
                            
                            int64_t gt_arg1_49726 = ((int64_t *) mem_50366)[j_46942];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37
                            
                            int64_t gt_arg1_49727 = ((int64_t *) mem_50368)[j_46942];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30
                            
                            int64_t gt_arg0_49731 = ((int64_t *) mem_50366)[tmp_46964];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30
                            
                            int64_t gt_arg0_49732 = ((int64_t *) mem_50368)[tmp_46964];
                            
                            // ../lib/github.com/diku-dk/sparse/mono.fut:75:41-74
                            
                            bool cond_49733 = slt64(gt_arg0_49731, gt_arg1_49726);
                            
                            // ../lib/github.com/diku-dk/sparse/mono.fut:75:53-73
                            
                            bool cond_49734 = gt_arg0_49731 == gt_arg1_49726;
                            
                            // ../lib/github.com/diku-dk/sparse/mono.fut:75:68-73
                            
                            bool lifted_lambda_res_f_res_t_res_49735 = sle64(gt_arg0_49732, gt_arg1_49727);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:18-25
                            
                            bool x_49736 = cond_49734 && lifted_lambda_res_f_res_t_res_49735;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:18-25
                            
                            bool x_49737 = !cond_49733;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:18-25
                            
                            bool y_49738 = x_49736 && x_49737;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:18-25
                            
                            bool lifted_lambda_res_49739 = cond_49733 || y_49738;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:16-26
                            
                            bool defunc_0_lifted_gt_res_49740 = !lifted_lambda_res_49739;
                            
                            loop_cond_46966 = defunc_0_lifted_gt_res_49740;
                        } else {
                            loop_cond_46966 = 0;
                        }
                        
                        bool loop_while_tmp_50862 = loop_cond_46966;
                        int64_t j_tmp_50866 = tmp_46964;
                        
                        loop_while_46938 = loop_while_tmp_50862;
                        j_46942 = j_tmp_50866;
                    }
                    s_46933 = loop_while_46938;
                    s_46937 = j_46942;
                }
            }
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_50346, i_50020 * block_sizze_46793, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_50370, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {block_sizze_46793});
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_50349, i_50020 * block_sizze_46793, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_50368, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {block_sizze_46793});
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_50352, i_50020 * block_sizze_46793, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_50366, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {block_sizze_46793});
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
        if (memblock_alloc(ctx, &mem_50448, bytes_50345, "mem_50448")) {
            err = 1;
            goto cleanup;
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
        lmad_copy_8b(ctx, 2, (uint64_t *) mem_50448.mem, (int64_t) 0, (int64_t []) {block_sizze_46793, (int64_t) 1}, (uint64_t *) mem_50352, (int64_t) 0, (int64_t []) {block_sizze_46793, (int64_t) 1}, (int64_t []) {smallest_pow_2_geq_than_res_46783, block_sizze_46793});
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
        if (memblock_alloc(ctx, &mem_50452, bytes_50345, "mem_50452")) {
            err = 1;
            goto cleanup;
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
        lmad_copy_8b(ctx, 2, (uint64_t *) mem_50452.mem, (int64_t) 0, (int64_t []) {block_sizze_46793, (int64_t) 1}, (uint64_t *) mem_50349, (int64_t) 0, (int64_t []) {block_sizze_46793, (int64_t) 1}, (int64_t []) {smallest_pow_2_geq_than_res_46783, block_sizze_46793});
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
        if (memblock_alloc(ctx, &mem_50456, bytes_50345, "mem_50456")) {
            err = 1;
            goto cleanup;
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
        lmad_copy_8b(ctx, 2, (uint64_t *) mem_50456.mem, (int64_t) 0, (int64_t []) {block_sizze_46793, (int64_t) 1}, (uint64_t *) mem_50346, (int64_t) 0, (int64_t []) {block_sizze_46793, (int64_t) 1}, (int64_t []) {smallest_pow_2_geq_than_res_46783, block_sizze_46793});
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:251:5-262:26
        
        int64_t data_46985;
        bool data_46986;
        int64_t data_46990;
        int64_t loop_dz2084Uz2082U_46991;
        bool loop_while_46992;
        int64_t stride_46996;
        
        if (memblock_set(ctx, &mem_param_50460, &mem_50448, "mem_50448") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_50463, &mem_50452, "mem_50452") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_50466, &mem_50456, "mem_50456") != 0)
            return 1;
        loop_dz2084Uz2082U_46991 = flat_dim_46794;
        loop_while_46992 = loop_cond_46871;
        stride_46996 = block_sizze_46793;
        while (loop_while_46992) {
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:253:27-35
            
            int64_t next_stride_46997 = mul64((int64_t) 2, stride_46996);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:254:33-46
            
            bool zzero_46998 = next_stride_46997 == (int64_t) 0;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:254:33-46
            
            bool nonzzero_46999 = !zzero_46998;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:254:33-46
            
            bool nonzzero_cert_47000;
            
            if (!nonzzero_46999) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:254:33-46\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:375:19-85\n   #6  trmodel_test.fut:186:7-190:30\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:254:33-46
            
            int64_t num_merges_47001 = sdiv64(flat_dim_46794, next_stride_46997);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool bounds_invalid_upwards_47002 = slt64(num_merges_47001, (int64_t) 0);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool valid_47003 = !bounds_invalid_upwards_47002;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool range_valid_c_47004;
            
            if (!valid_47003) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) num_merges_47001, " is invalid.", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:375:19-85\n   #6  trmodel_test.fut:186:7-190:30\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56
            
            int64_t m_47006 = sub64(next_stride_46997, (int64_t) 1);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56
            
            bool zzero_leq_i_p_m_t_s_47007 = sle64((int64_t) 0, m_47006);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:144:3-155:47
            
            bool cond_47009 = slt64(next_stride_46997, (int64_t) 10);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59
            
            bool protect_assert_disj_47010 = nonzzero_46873 || cond_47009;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:147:30-42
            
            bool nonzzero_cert_47011;
            
            if (!protect_assert_disj_47010) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:147:30-42\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:186:7-190:30\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:147:30-42
            
            int64_t zeze_lhs_47012 = smod_safe64(next_stride_46997, greatest_divisor_leq_than_res_46817);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:147:43-47
            
            bool num_blocks_47013 = zeze_lhs_47012 == (int64_t) 0;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59
            
            bool protect_assert_disj_47014 = cond_47009 || num_blocks_47013;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:147:20-65
            
            bool assert_c_47015;
            
            if (!protect_assert_disj_47014) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "Assertion is false: (n % block_size == 0)", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:147:20-65\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:186:7-190:30\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:147:20-65
            
            int64_t num_blocks_47016 = sdiv_safe64(next_stride_46997, greatest_divisor_leq_than_res_46817);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:15-27
            
            int64_t dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_47017 = add64((int64_t) 1, num_blocks_47016);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:34-41
            
            int64_t j_m_i_47018 = sub64(next_stride_46997, stride_46996);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
            
            int64_t flat_dim_47019 = greatest_divisor_leq_than_res_46817 * num_blocks_47016;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84
            
            bool bounds_invalid_upwards_47020 = slt64(dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_47017, (int64_t) 0);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool empty_slice_47021 = j_m_i_47018 == (int64_t) 0;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            int64_t m_47022 = sub64(j_m_i_47018, (int64_t) 1);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool zzero_lte_i_47023 = sle64((int64_t) 0, stride_46996);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool i_lte_j_47024 = sle64(stride_46996, next_stride_46997);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59
            
            bool empty_slice_47025 = stride_46996 == (int64_t) 0;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59
            
            int64_t m_47026 = sub64(stride_46996, (int64_t) 1);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
            
            bool bounds_invalid_upwards_47027 = slt64(num_blocks_47016, (int64_t) 0);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:15-54
            
            bool cond_47028 = slt64((int64_t) 0, stride_46996);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84
            
            bool valid_47029 = !bounds_invalid_upwards_47020;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            int64_t i_p_m_t_s_47030 = add64(stride_46996, m_47022);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59
            
            bool zzero_leq_i_p_m_t_s_47031 = sle64((int64_t) 0, m_47026);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59
            
            bool i_p_m_t_s_leq_w_47032 = slt64(m_47026, next_stride_46997);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
            
            bool valid_47033 = !bounds_invalid_upwards_47027;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:3-46
            
            bool i_p_m_t_s_leq_w_47034 = slt64(m_47006, flat_dim_47019);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54
            
            bool y_47035 = slt64((int64_t) 0, j_m_i_47018);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool protect_assert_disj_47036 = cond_47009 || valid_47029;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84
            
            bool range_valid_c_47037;
            
            if (!protect_assert_disj_47036) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_47017, " is invalid.", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:186:7-190:30\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool zzero_leq_i_p_m_t_s_47038 = sle64((int64_t) 0, i_p_m_t_s_47030);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool i_p_m_t_s_leq_w_47039 = slt64(i_p_m_t_s_47030, next_stride_46997);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59
            
            bool y_47040 = zzero_leq_i_p_m_t_s_47031 && i_p_m_t_s_leq_w_47032;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool protect_assert_disj_47041 = cond_47009 || valid_47033;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
            
            bool range_valid_c_47042;
            
            if (!protect_assert_disj_47041) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) num_blocks_47016, " is invalid.", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:186:7-190:30\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:3-46
            
            bool y_47043 = zzero_leq_i_p_m_t_s_47007 && i_p_m_t_s_leq_w_47034;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool y_47044 = zzero_lte_i_47023 && i_p_m_t_s_leq_w_47039;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59
            
            bool forwards_ok_47045 = zzero_lte_i_47023 && y_47040;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:3-46
            
            bool ok_or_empty_47046 = zzero_46998 || y_47043;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool protect_assert_disj_47047 = cond_47028 || y_47035;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool y_47048 = zzero_leq_i_p_m_t_s_47038 && y_47044;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59
            
            bool ok_or_empty_47049 = empty_slice_47025 || forwards_ok_47045;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool protect_assert_disj_47050 = cond_47009 || ok_or_empty_47046;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:3-46
            
            bool index_certs_47051;
            
            if (!protect_assert_disj_47050) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) next_stride_46997, "] out of bounds for array of shape [", (long long) flat_dim_47019, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:3-46\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:186:7-190:30\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool loop_not_taken_47052 = !cond_47009;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool protect_assert_disj_47053 = protect_assert_disj_47047 || loop_not_taken_47052;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54
            
            bool index_certs_47054;
            
            if (!protect_assert_disj_47053) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_47018, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:5-43\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:375:19-85\n   #8  trmodel_test.fut:186:7-190:30\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool forwards_ok_47055 = i_lte_j_47024 && y_47048;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool protect_assert_disj_47056 = cond_47009 || ok_or_empty_47049;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59
            
            bool index_certs_47057;
            
            if (!protect_assert_disj_47056) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) stride_46996, "] out of bounds for array of shape [", (long long) next_stride_46997, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:186:7-190:30\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool protect_assert_disj_47058 = ok_or_empty_47049 || loop_not_taken_47052;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:26-33
            
            bool index_certs_47059;
            
            if (!protect_assert_disj_47058) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) stride_46996, "] out of bounds for array of shape [", (long long) next_stride_46997, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:26-33\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:186:7-190:30\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool ok_or_empty_47060 = empty_slice_47021 || forwards_ok_47055;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool protect_assert_disj_47061 = cond_47009 || ok_or_empty_47060;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool index_certs_47062;
            
            if (!protect_assert_disj_47061) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) stride_46996, ":] out of bounds for array of shape [", (long long) next_stride_46997, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:186:7-190:30\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool protect_assert_disj_47063 = loop_not_taken_47052 || ok_or_empty_47060;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:34-41
            
            bool index_certs_47064;
            
            if (!protect_assert_disj_47063) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) stride_46996, ":] out of bounds for array of shape [", (long long) next_stride_46997, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:34-41\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:186:7-190:30\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            int64_t binop_x_50467 = (int64_t) 8 * num_merges_47001;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            int64_t bytes_50468 = next_stride_46997 * binop_x_50467;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56
            
            bool i_lte_j_47008 = sle64((int64_t) 0, next_stride_46997);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            if (mem_50469_cached_sizze_51031 < bytes_50468) {
                err = lexical_realloc(ctx, &mem_50469, &mem_50469_cached_sizze_51031, bytes_50468);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            if (mem_50472_cached_sizze_51032 < bytes_50468) {
                err = lexical_realloc(ctx, &mem_50472, &mem_50472_cached_sizze_51032, bytes_50468);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            if (mem_50475_cached_sizze_51033 < bytes_50468) {
                err = lexical_realloc(ctx, &mem_50475, &mem_50475_cached_sizze_51033, bytes_50468);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84
            
            int64_t bytes_50488 = (int64_t) 8 * dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_47017;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
            
            int64_t binop_x_50504 = (int64_t) 8 * num_blocks_47016;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
            
            int64_t bytes_50505 = greatest_divisor_leq_than_res_46817 * binop_x_50504;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
            
            int64_t bytes_50573 = (int64_t) 16 * stride_46996;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            for (int64_t i_50047 = 0; i_50047 < num_merges_47001; i_50047++) {
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:257:26-39
                
                int64_t start_47069 = mul64(next_stride_46997, i_50047);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                int64_t j_m_i_47070 = sub64(loop_dz2084Uz2082U_46991, start_47069);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool empty_slice_47071 = j_m_i_47070 == (int64_t) 0;
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                int64_t m_47072 = sub64(j_m_i_47070, (int64_t) 1);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                int64_t i_p_m_t_s_47073 = add64(start_47069, m_47072);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool zzero_leq_i_p_m_t_s_47074 = sle64((int64_t) 0, i_p_m_t_s_47073);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool i_p_m_t_s_leq_w_47075 = slt64(i_p_m_t_s_47073, loop_dz2084Uz2082U_46991);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool zzero_lte_i_47076 = sle64((int64_t) 0, start_47069);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool i_lte_j_47077 = sle64(start_47069, loop_dz2084Uz2082U_46991);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool y_47078 = i_p_m_t_s_leq_w_47075 && zzero_lte_i_47076;
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool y_47079 = zzero_leq_i_p_m_t_s_47074 && y_47078;
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool forwards_ok_47080 = i_lte_j_47077 && y_47079;
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool ok_or_empty_47081 = empty_slice_47071 || forwards_ok_47080;
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool index_certs_47082;
                
                if (!ok_or_empty_47081) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) start_47069, ":] out of bounds for array of shape [", (long long) loop_dz2084Uz2082U_46991, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:375:19-85\n   #6  trmodel_test.fut:186:7-190:30\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56
                
                bool i_p_m_t_s_leq_w_47083 = slt64(m_47006, j_m_i_47070);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56
                
                bool y_47084 = zzero_leq_i_p_m_t_s_47007 && i_p_m_t_s_leq_w_47083;
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56
                
                bool forwards_ok_47085 = i_lte_j_47008 && y_47084;
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56
                
                bool ok_or_empty_47086 = zzero_46998 || forwards_ok_47085;
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56
                
                bool index_certs_47087;
                
                if (!ok_or_empty_47086) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) next_stride_46997, "] out of bounds for array of shape [", (long long) j_m_i_47070, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:375:19-85\n   #6  trmodel_test.fut:186:7-190:30\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                if (cond_47009) {
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:15-54
                    
                    int64_t dummy_49777;
                    int64_t dummy_49778;
                    double dummy_49779;
                    
                    if (cond_47028) {
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                        
                        int64_t head_res_49780 = ((int64_t *) mem_param_50460.mem)[start_47069];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                        
                        int64_t head_res_49781 = ((int64_t *) mem_param_50463.mem)[start_47069];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                        
                        double head_res_49782 = ((double *) mem_param_50466.mem)[start_47069];
                        
                        dummy_49777 = head_res_49780;
                        dummy_49778 = head_res_49781;
                        dummy_49779 = head_res_49782;
                    } else {
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                        
                        int64_t index_primexp_49783 = stride_46996 + start_47069;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                        
                        int64_t head_res_49784 = ((int64_t *) mem_param_50460.mem)[index_primexp_49783];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                        
                        int64_t head_res_49785 = ((int64_t *) mem_param_50463.mem)[index_primexp_49783];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                        
                        double head_res_49786 = ((double *) mem_param_50466.mem)[index_primexp_49783];
                        
                        dummy_49777 = head_res_49784;
                        dummy_49778 = head_res_49785;
                        dummy_49779 = head_res_49786;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
                    if (memblock_alloc(ctx, &mem_50574, bytes_50573, "mem_50574")) {
                        err = 1;
                        goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
                    for (int64_t nest_i_50879 = 0; nest_i_50879 < next_stride_46997; nest_i_50879++) {
                        ((int64_t *) mem_50574.mem)[nest_i_50879] = dummy_49777;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
                    if (memblock_alloc(ctx, &mem_50576, bytes_50573, "mem_50576")) {
                        err = 1;
                        goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
                    for (int64_t nest_i_50880 = 0; nest_i_50880 < next_stride_46997; nest_i_50880++) {
                        ((int64_t *) mem_50576.mem)[nest_i_50880] = dummy_49778;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
                    if (memblock_alloc(ctx, &mem_50578, bytes_50573, "mem_50578")) {
                        err = 1;
                        goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
                    for (int64_t nest_i_50881 = 0; nest_i_50881 < next_stride_46997; nest_i_50881++) {
                        ((double *) mem_50578.mem)[nest_i_50881] = dummy_49779;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:5-110:29
                    
                    int64_t data_49790;
                    int64_t i_49795 = (int64_t) 0;
                    
                    for (int64_t k_49794 = 0; k_49794 < next_stride_46997; k_49794++) {
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:103:16-18
                        
                        int64_t j_49799 = sub64(k_49794, i_49795);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:9-108:20
                        
                        bool cond_49800 = j_49799 == j_m_i_47018;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:9-108:20
                        
                        bool cond_49801;
                        
                        if (cond_49800) {
                            cond_49801 = 1;
                        } else {
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:30-59
                            
                            bool cond_49802 = slt64(i_49795, stride_46996);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:30-59
                            
                            bool cond_f_res_49803;
                            
                            if (cond_49802) {
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59
                                
                                bool x_49804 = sle64((int64_t) 0, j_49799);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59
                                
                                bool y_49805 = slt64(j_49799, j_m_i_47018);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59
                                
                                bool bounds_check_49806 = x_49804 && y_49805;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59
                                
                                bool index_certs_49807;
                                
                                if (!bounds_check_49806) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_49799, "] out of bounds for array of shape [", (long long) j_m_i_47018, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:5-43\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:375:19-85\n   #8  trmodel_test.fut:186:7-190:30\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54
                                
                                bool x_49812 = sle64((int64_t) 0, i_49795);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54
                                
                                bool bounds_check_49813 = cond_49802 && x_49812;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54
                                
                                bool index_certs_49814;
                                
                                if (!bounds_check_49813) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_49795, "] out of bounds for array of shape [", (long long) stride_46996, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:5-43\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:375:19-85\n   #8  trmodel_test.fut:186:7-190:30\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59
                                
                                int64_t index_primexp_49808 = stride_46996 + j_49799;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t index_primexp_49809 = start_47069 + index_primexp_49808;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t leq_arg1_49810 = ((int64_t *) mem_param_50460.mem)[index_primexp_49809];
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t leq_arg1_49811 = ((int64_t *) mem_param_50463.mem)[index_primexp_49809];
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t index_primexp_49815 = start_47069 + i_49795;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t leq_arg0_49816 = ((int64_t *) mem_param_50460.mem)[index_primexp_49815];
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t leq_arg0_49817 = ((int64_t *) mem_param_50463.mem)[index_primexp_49815];
                                
                                // ../lib/github.com/diku-dk/sparse/mono.fut:75:41-74
                                
                                bool cond_49818 = slt64(leq_arg0_49816, leq_arg1_49810);
                                
                                // ../lib/github.com/diku-dk/sparse/mono.fut:75:53-73
                                
                                bool cond_49819 = leq_arg0_49816 == leq_arg1_49810;
                                
                                // ../lib/github.com/diku-dk/sparse/mono.fut:75:68-73
                                
                                bool lifted_lambda_res_f_res_t_res_49820 = sle64(leq_arg0_49817, leq_arg1_49811);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:46-59
                                
                                bool x_49821 = cond_49819 && lifted_lambda_res_f_res_t_res_49820;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:46-59
                                
                                bool x_49822 = !cond_49818;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:46-59
                                
                                bool y_49823 = x_49821 && x_49822;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:46-59
                                
                                bool lifted_lambda_res_49824 = cond_49818 || y_49823;
                                
                                cond_f_res_49803 = lifted_lambda_res_49824;
                            } else {
                                cond_f_res_49803 = 0;
                            }
                            cond_49801 = cond_f_res_49803;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:9-108:20
                        
                        int64_t loopres_49825;
                        int64_t loopres_49826;
                        int64_t loopres_49827;
                        double loopres_49828;
                        
                        if (cond_49801) {
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21
                            
                            bool x_49830 = sle64((int64_t) 0, i_49795);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21
                            
                            bool y_49831 = slt64(i_49795, stride_46996);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21
                            
                            bool bounds_check_49832 = x_49830 && y_49831;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21
                            
                            bool index_certs_49833;
                            
                            if (!bounds_check_49832) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_49795, "] out of bounds for array of shape [", (long long) stride_46996, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:5-43\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:375:19-85\n   #8  trmodel_test.fut:186:7-190:30\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:13-15
                            
                            int64_t tmp_49829 = add64((int64_t) 1, i_49795);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t index_primexp_49834 = start_47069 + i_49795;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t tmp_49835 = ((int64_t *) mem_param_50460.mem)[index_primexp_49834];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t tmp_49836 = ((int64_t *) mem_param_50463.mem)[index_primexp_49834];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            double tmp_49837 = ((double *) mem_param_50466.mem)[index_primexp_49834];
                            
                            loopres_49825 = tmp_49829;
                            loopres_49826 = tmp_49835;
                            loopres_49827 = tmp_49836;
                            loopres_49828 = tmp_49837;
                        } else {
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19
                            
                            bool x_49838 = sle64((int64_t) 0, j_49799);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19
                            
                            bool y_49839 = slt64(j_49799, j_m_i_47018);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19
                            
                            bool bounds_check_49840 = x_49838 && y_49839;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19
                            
                            bool index_certs_49841;
                            
                            if (!bounds_check_49840) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_49799, "] out of bounds for array of shape [", (long long) j_m_i_47018, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:5-43\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:375:19-85\n   #8  trmodel_test.fut:186:7-190:30\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59
                            
                            int64_t index_primexp_49842 = stride_46996 + j_49799;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t index_primexp_49843 = start_47069 + index_primexp_49842;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t tmp_49844 = ((int64_t *) mem_param_50460.mem)[index_primexp_49843];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t tmp_49845 = ((int64_t *) mem_param_50463.mem)[index_primexp_49843];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            double tmp_49846 = ((double *) mem_param_50466.mem)[index_primexp_49843];
                            
                            loopres_49825 = i_49795;
                            loopres_49826 = tmp_49844;
                            loopres_49827 = tmp_49845;
                            loopres_49828 = tmp_49846;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:110:11-28
                        ((int64_t *) mem_50574.mem)[k_49794] = loopres_49826;
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:110:11-28
                        ((int64_t *) mem_50576.mem)[k_49794] = loopres_49827;
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:110:11-28
                        ((double *) mem_50578.mem)[k_49794] = loopres_49828;
                        
                        int64_t i_tmp_50882 = loopres_49825;
                        
                        i_49795 = i_tmp_50882;
                    }
                    data_49790 = i_49795;
                    if (memblock_set(ctx, &ext_mem_50605, &mem_50574, "mem_50574") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_50602, &mem_50576, "mem_50576") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_50599, &mem_50578, "mem_50578") != 0)
                        return 1;
                } else {
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84
                    if (mem_50489_cached_sizze_51034 < bytes_50488) {
                        err = lexical_realloc(ctx, &mem_50489, &mem_50489_cached_sizze_51034, bytes_50488);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84
                    if (mem_50491_cached_sizze_51035 < bytes_50488) {
                        err = lexical_realloc(ctx, &mem_50491, &mem_50491_cached_sizze_51035, bytes_50488);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84
                    for (int64_t i_50028 = 0; i_50028 < dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_47017; i_50028++) {
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83
                        
                        int64_t split_count_arg3_47168 = mul64(greatest_divisor_leq_than_res_46817, i_50028);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:32:15-39
                        
                        int64_t min_res_47169 = smin64(stride_46996, split_count_arg3_47168);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:33:15-39
                        
                        int64_t min_res_47170 = smin64(j_m_i_47018, split_count_arg3_47168);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:36:27-37
                        
                        int64_t zm_lhs_47171 = add64(min_res_47169, min_res_47170);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:36:39-46
                        
                        int64_t slack_47172 = sub64(zm_lhs_47171, split_count_arg3_47168);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:37:17-39
                        
                        int64_t min_res_47173 = smin64(min_res_47169, slack_47172);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:38:17-39
                        
                        int64_t min_res_47174 = smin64(min_res_47170, min_res_47173);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:40:32-39
                        
                        int64_t max_arg1_47175 = sub64(min_res_47169, min_res_47174);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:40:15-39
                        
                        int64_t max_res_47176 = smax64((int64_t) 0, max_arg1_47175);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:41:32-39
                        
                        int64_t max_arg1_47177 = sub64(min_res_47170, min_res_47174);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:41:15-39
                        
                        int64_t max_res_47178 = smax64((int64_t) 0, max_arg1_47177);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:43:23-40
                        
                        int64_t zm_lhs_47179 = sub64(split_count_arg3_47168, max_res_47176);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:43:42-59
                        
                        int64_t count_47180 = sub64(zm_lhs_47179, max_res_47178);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:81:5-83:39
                        
                        bool loop_cond_47181 = slt64((int64_t) 0, count_47180);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:81:5-83:39
                        
                        bool defunc_0_split_count_res_47182;
                        int64_t defunc_0_split_count_res_47183;
                        int64_t defunc_0_split_count_res_47184;
                        int64_t defunc_0_split_count_res_47185;
                        int64_t defunc_0_split_count_res_47186;
                        int64_t defunc_0_split_count_res_47187;
                        bool loop_while_47188;
                        int64_t ss_47189;
                        int64_t ss_47190;
                        int64_t tt_47191;
                        int64_t tt_47192;
                        int64_t count_47193;
                        
                        loop_while_47188 = loop_cond_47181;
                        ss_47189 = max_res_47176;
                        ss_47190 = min_res_47169;
                        tt_47191 = max_res_47178;
                        tt_47192 = min_res_47170;
                        count_47193 = count_47180;
                        while (loop_while_47188) {
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:48:11-15
                            
                            int64_t zlze_lhs_47194 = sub64(ss_47190, ss_47189);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:48:5-78:40
                            
                            bool cond_47195 = sle64(zlze_lhs_47194, (int64_t) 0);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38
                            
                            int64_t defunc_0_lifted_step_res_47196;
                            int64_t defunc_0_lifted_step_res_47197;
                            int64_t defunc_0_lifted_step_res_47198;
                            int64_t defunc_0_lifted_step_res_47199;
                            
                            if (cond_47195) {
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:49:24-30
                                
                                int64_t tmp_49850 = add64(tt_47191, count_47193);
                                
                                defunc_0_lifted_step_res_47196 = ss_47189;
                                defunc_0_lifted_step_res_47197 = tmp_49850;
                                defunc_0_lifted_step_res_47198 = tt_47192;
                                defunc_0_lifted_step_res_47199 = (int64_t) 0;
                            } else {
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:50:16-20
                                
                                int64_t zlze_lhs_47201 = sub64(tt_47192, tt_47191);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:50:10-78:40
                                
                                bool cond_47202 = sle64(zlze_lhs_47201, (int64_t) 0);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38
                                
                                int64_t defunc_0_lifted_step_res_f_res_47203;
                                int64_t defunc_0_lifted_step_res_f_res_47204;
                                int64_t defunc_0_lifted_step_res_f_res_47205;
                                int64_t defunc_0_lifted_step_res_f_res_47206;
                                
                                if (cond_47202) {
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:51:12-18
                                    
                                    int64_t tmp_49851 = add64(ss_47189, count_47193);
                                    
                                    defunc_0_lifted_step_res_f_res_47203 = tmp_49851;
                                    defunc_0_lifted_step_res_f_res_47204 = tt_47191;
                                    defunc_0_lifted_step_res_f_res_47205 = tt_47192;
                                    defunc_0_lifted_step_res_f_res_47206 = (int64_t) 0;
                                } else {
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:52:10-78:40
                                    
                                    bool cond_47208 = count_47193 == (int64_t) 1;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38
                                    
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_47209;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_47210;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_47211;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_47212;
                                    
                                    if (cond_47208) {
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:21-27
                                        
                                        bool x_49853 = sle64((int64_t) 0, ss_47189);
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:21-27
                                        
                                        bool y_49854 = slt64(ss_47189, stride_46996);
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:21-27
                                        
                                        bool bounds_check_49855 = x_49853 && y_49854;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:21-27
                                        
                                        bool index_certs_49856;
                                        
                                        if (!bounds_check_49855) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) ss_47189, "] out of bounds for array of shape [", (long long) stride_46996, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:21-27\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:36-83\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #4  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #7  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #8  trmodel.fut:375:19-85\n   #9  trmodel_test.fut:186:7-190:30\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:14-20
                                        
                                        bool x_49860 = sle64((int64_t) 0, tt_47191);
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:14-20
                                        
                                        bool y_49861 = slt64(tt_47191, j_m_i_47018);
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:14-20
                                        
                                        bool bounds_check_49862 = x_49860 && y_49861;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:14-20
                                        
                                        bool index_certs_49863;
                                        
                                        if (!bounds_check_49862) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tt_47191, "] out of bounds for array of shape [", (long long) j_m_i_47018, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:14-20\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:36-83\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #4  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #7  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #8  trmodel.fut:375:19-85\n   #9  trmodel_test.fut:186:7-190:30\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                        
                                        int64_t index_primexp_49857 = start_47069 + ss_47189;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                        
                                        int64_t leq_arg1_49858 = ((int64_t *) mem_param_50460.mem)[index_primexp_49857];
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                        
                                        int64_t leq_arg1_49859 = ((int64_t *) mem_param_50463.mem)[index_primexp_49857];
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84
                                        
                                        int64_t index_primexp_49864 = stride_46996 + tt_47191;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                        
                                        int64_t index_primexp_49865 = start_47069 + index_primexp_49864;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                        
                                        int64_t leq_arg0_49866 = ((int64_t *) mem_param_50460.mem)[index_primexp_49865];
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                        
                                        int64_t leq_arg0_49867 = ((int64_t *) mem_param_50463.mem)[index_primexp_49865];
                                        
                                        // ../lib/github.com/diku-dk/sparse/mono.fut:75:41-74
                                        
                                        bool cond_49868 = slt64(leq_arg0_49866, leq_arg1_49858);
                                        
                                        // ../lib/github.com/diku-dk/sparse/mono.fut:75:53-73
                                        
                                        bool cond_49869 = leq_arg0_49866 == leq_arg1_49858;
                                        
                                        // ../lib/github.com/diku-dk/sparse/mono.fut:75:68-73
                                        
                                        bool lifted_lambda_res_f_res_t_res_49870 = sle64(leq_arg0_49867, leq_arg1_49859);
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:7-56:38
                                        
                                        bool x_49871 = cond_49869 && lifted_lambda_res_f_res_t_res_49870;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:7-56:38
                                        
                                        bool x_49872 = !cond_49868;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:7-56:38
                                        
                                        bool y_49873 = x_49871 && x_49872;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:7-56:38
                                        
                                        bool lifted_lambda_res_49874 = cond_49868 || y_49873;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38
                                        
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_t_res_49875;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_t_res_49876;
                                        
                                        if (lifted_lambda_res_49874) {
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:54:26-28
                                            
                                            int64_t tmp_49877 = add64((int64_t) 1, tt_47191);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_49875 = ss_47189;
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_49876 = tmp_49877;
                                        } else {
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:56:14-16
                                            
                                            int64_t tmp_49878 = add64((int64_t) 1, ss_47189);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_49875 = tmp_49878;
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_49876 = tt_47191;
                                        }
                                        defunc_0_lifted_step_res_f_res_f_res_47209 = defunc_0_lifted_step_res_f_res_f_res_t_res_49875;
                                        defunc_0_lifted_step_res_f_res_f_res_47210 = defunc_0_lifted_step_res_f_res_f_res_t_res_49876;
                                        defunc_0_lifted_step_res_f_res_f_res_47211 = tt_47192;
                                        defunc_0_lifted_step_res_f_res_f_res_47212 = (int64_t) 0;
                                    } else {
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:58:19-22
                                        
                                        int64_t m_47239 = sdiv64(count_47193, (int64_t) 2);
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:59:19-22
                                        
                                        int64_t n_47240 = sub64(count_47193, m_47239);
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:71:7-73:30
                                        
                                        bool cond_47241 = n_47240 == (int64_t) 0;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:72:10-12
                                        
                                        int64_t zgze_lhs_47242 = add64(ss_47189, m_47239);
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:72:13-19
                                        
                                        bool cond_f_res_47243 = sle64(ss_47190, zgze_lhs_47242);
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38
                                        
                                        bool x_47244 = !cond_47241;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38
                                        
                                        bool y_47245 = cond_f_res_47243 && x_47244;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38
                                        
                                        bool cond_47246 = cond_47241 || y_47245;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:71:7-73:30
                                        
                                        bool leq_y_x_47247;
                                        
                                        if (cond_47246) {
                                            leq_y_x_47247 = 1;
                                        } else {
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:22-30
                                            
                                            bool x_47248 = sle64((int64_t) 0, zgze_lhs_47242);
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:22-30
                                            
                                            bool y_47249 = slt64(zgze_lhs_47242, stride_46996);
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:22-30
                                            
                                            bool bounds_check_47250 = x_47248 && y_47249;
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:22-30
                                            
                                            bool index_certs_47251;
                                            
                                            if (!bounds_check_47250) {
                                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) zgze_lhs_47242, "] out of bounds for array of shape [", (long long) stride_46996, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:22-30\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:36-83\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #4  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #7  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #8  trmodel.fut:375:19-85\n   #9  trmodel_test.fut:186:7-190:30\n"));
                                                err = FUTHARK_PROGRAM_ERROR;
                                                goto cleanup;
                                            }
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:16-18
                                            
                                            int64_t zm_lhs_47255 = add64(tt_47191, n_47240);
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:18-20
                                            
                                            int64_t leq_arg0_47256 = sub64(zm_lhs_47255, (int64_t) 1);
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:11-21
                                            
                                            bool x_47257 = sle64((int64_t) 0, leq_arg0_47256);
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:11-21
                                            
                                            bool y_47258 = slt64(leq_arg0_47256, j_m_i_47018);
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:11-21
                                            
                                            bool bounds_check_47259 = x_47257 && y_47258;
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:11-21
                                            
                                            bool index_certs_47260;
                                            
                                            if (!bounds_check_47259) {
                                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) leq_arg0_47256, "] out of bounds for array of shape [", (long long) j_m_i_47018, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:11-21\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:36-83\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #4  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #7  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #8  trmodel.fut:375:19-85\n   #9  trmodel_test.fut:186:7-190:30\n"));
                                                err = FUTHARK_PROGRAM_ERROR;
                                                goto cleanup;
                                            }
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                            
                                            int64_t index_primexp_47252 = start_47069 + zgze_lhs_47242;
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                            
                                            int64_t leq_arg1_47253 = ((int64_t *) mem_param_50460.mem)[index_primexp_47252];
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                            
                                            int64_t leq_arg1_47254 = ((int64_t *) mem_param_50463.mem)[index_primexp_47252];
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84
                                            
                                            int64_t index_primexp_47261 = stride_46996 + leq_arg0_47256;
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                            
                                            int64_t index_primexp_47262 = start_47069 + index_primexp_47261;
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                            
                                            int64_t leq_arg0_47263 = ((int64_t *) mem_param_50460.mem)[index_primexp_47262];
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                            
                                            int64_t leq_arg0_47264 = ((int64_t *) mem_param_50463.mem)[index_primexp_47262];
                                            
                                            // ../lib/github.com/diku-dk/sparse/mono.fut:75:41-74
                                            
                                            bool cond_47265 = slt64(leq_arg0_47263, leq_arg1_47253);
                                            
                                            // ../lib/github.com/diku-dk/sparse/mono.fut:75:53-73
                                            
                                            bool cond_47266 = leq_arg0_47263 == leq_arg1_47253;
                                            
                                            // ../lib/github.com/diku-dk/sparse/mono.fut:75:68-73
                                            
                                            bool lifted_lambda_res_f_res_t_res_47267 = sle64(leq_arg0_47264, leq_arg1_47254);
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:7-30
                                            
                                            bool x_47268 = cond_47266 && lifted_lambda_res_f_res_t_res_47267;
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:7-30
                                            
                                            bool x_47269 = !cond_47265;
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:7-30
                                            
                                            bool y_47270 = x_47268 && x_47269;
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:7-30
                                            
                                            bool lifted_lambda_res_47271 = cond_47265 || y_47270;
                                            
                                            leq_y_x_47247 = lifted_lambda_res_47271;
                                        }
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38
                                        
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_47272;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_47273;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_47274;
                                        
                                        if (leq_y_x_47247) {
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:76:24-26
                                            
                                            int64_t tmp_49879 = add64(tt_47191, n_47240);
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:76:39-41
                                            
                                            int64_t tmp_49880 = sub64(count_47193, n_47240);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_47272 = tmp_49879;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_47273 = tt_47192;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_47274 = tmp_49880;
                                        } else {
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:78:29-31
                                            
                                            int64_t tmp_47277 = add64(tt_47191, n_47240);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_47272 = tt_47191;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_47273 = tmp_47277;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_47274 = count_47193;
                                        }
                                        defunc_0_lifted_step_res_f_res_f_res_47209 = ss_47189;
                                        defunc_0_lifted_step_res_f_res_f_res_47210 = defunc_0_lifted_step_res_f_res_f_res_f_res_47272;
                                        defunc_0_lifted_step_res_f_res_f_res_47211 = defunc_0_lifted_step_res_f_res_f_res_f_res_47273;
                                        defunc_0_lifted_step_res_f_res_f_res_47212 = defunc_0_lifted_step_res_f_res_f_res_f_res_47274;
                                    }
                                    defunc_0_lifted_step_res_f_res_47203 = defunc_0_lifted_step_res_f_res_f_res_47209;
                                    defunc_0_lifted_step_res_f_res_47204 = defunc_0_lifted_step_res_f_res_f_res_47210;
                                    defunc_0_lifted_step_res_f_res_47205 = defunc_0_lifted_step_res_f_res_f_res_47211;
                                    defunc_0_lifted_step_res_f_res_47206 = defunc_0_lifted_step_res_f_res_f_res_47212;
                                }
                                defunc_0_lifted_step_res_47196 = defunc_0_lifted_step_res_f_res_47203;
                                defunc_0_lifted_step_res_47197 = defunc_0_lifted_step_res_f_res_47204;
                                defunc_0_lifted_step_res_47198 = defunc_0_lifted_step_res_f_res_47205;
                                defunc_0_lifted_step_res_47199 = defunc_0_lifted_step_res_f_res_47206;
                            }
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:32:32-39
                            
                            int64_t min_arg1_47278 = add64(defunc_0_lifted_step_res_47196, defunc_0_lifted_step_res_47199);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:32:15-39
                            
                            int64_t min_res_47279 = smin64(ss_47190, min_arg1_47278);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:33:32-39
                            
                            int64_t min_arg1_47280 = add64(defunc_0_lifted_step_res_47197, defunc_0_lifted_step_res_47199);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:33:15-39
                            
                            int64_t min_res_47281 = smin64(defunc_0_lifted_step_res_47198, min_arg1_47280);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:36:21-25
                            
                            int64_t zp_lhs_47282 = sub64(min_res_47279, defunc_0_lifted_step_res_47196);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:36:33-37
                            
                            int64_t zp_rhs_47283 = sub64(min_res_47281, defunc_0_lifted_step_res_47197);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:36:27-37
                            
                            int64_t zm_lhs_47284 = add64(zp_lhs_47282, zp_rhs_47283);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:36:39-46
                            
                            int64_t slack_47285 = sub64(zm_lhs_47284, defunc_0_lifted_step_res_47199);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:37:17-39
                            
                            int64_t min_res_47286 = smin64(zp_lhs_47282, slack_47285);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:38:17-39
                            
                            int64_t min_res_47287 = smin64(zp_rhs_47283, min_res_47286);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:40:32-39
                            
                            int64_t max_arg1_47288 = sub64(min_res_47279, min_res_47287);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:40:15-39
                            
                            int64_t max_res_47289 = smax64(defunc_0_lifted_step_res_47196, max_arg1_47288);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:41:32-39
                            
                            int64_t max_arg1_47290 = sub64(min_res_47281, min_res_47287);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:41:15-39
                            
                            int64_t max_res_47291 = smax64(defunc_0_lifted_step_res_47197, max_arg1_47290);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:43:30-40
                            
                            int64_t zm_rhs_47292 = sub64(max_res_47289, defunc_0_lifted_step_res_47196);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:43:23-40
                            
                            int64_t zm_lhs_47293 = sub64(defunc_0_lifted_step_res_47199, zm_rhs_47292);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:43:49-59
                            
                            int64_t zm_rhs_47294 = sub64(max_res_47291, defunc_0_lifted_step_res_47197);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:43:42-59
                            
                            int64_t count_47295 = sub64(zm_lhs_47293, zm_rhs_47294);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:82:17-20
                            
                            bool loop_cond_47296 = slt64((int64_t) 0, count_47295);
                            bool loop_while_tmp_50888 = loop_cond_47296;
                            int64_t ss_tmp_50889 = max_res_47289;
                            int64_t ss_tmp_50890 = min_res_47279;
                            int64_t tt_tmp_50891 = max_res_47291;
                            int64_t tt_tmp_50892 = min_res_47281;
                            int64_t count_tmp_50893 = count_47295;
                            
                            loop_while_47188 = loop_while_tmp_50888;
                            ss_47189 = ss_tmp_50889;
                            ss_47190 = ss_tmp_50890;
                            tt_47191 = tt_tmp_50891;
                            tt_47192 = tt_tmp_50892;
                            count_47193 = count_tmp_50893;
                        }
                        defunc_0_split_count_res_47182 = loop_while_47188;
                        defunc_0_split_count_res_47183 = ss_47189;
                        defunc_0_split_count_res_47184 = ss_47190;
                        defunc_0_split_count_res_47185 = tt_47191;
                        defunc_0_split_count_res_47186 = tt_47192;
                        defunc_0_split_count_res_47187 = count_47193;
                        ((int64_t *) mem_50489)[i_50028] = defunc_0_split_count_res_47183;
                        ((int64_t *) mem_50491)[i_50028] = defunc_0_split_count_res_47185;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
                    if (mem_50506_cached_sizze_51036 < bytes_50505) {
                        err = lexical_realloc(ctx, &mem_50506, &mem_50506_cached_sizze_51036, bytes_50505);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
                    if (mem_50509_cached_sizze_51037 < bytes_50505) {
                        err = lexical_realloc(ctx, &mem_50509, &mem_50509_cached_sizze_51037, bytes_50505);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
                    if (mem_50512_cached_sizze_51038 < bytes_50505) {
                        err = lexical_realloc(ctx, &mem_50512, &mem_50512_cached_sizze_51038, bytes_50505);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
                    for (int64_t i_50037 = 0; i_50037 < num_blocks_47016; i_50037++) {
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:151:22-34
                        
                        bool y_47303 = slt64(i_50037, dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_47017);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:151:22-34
                        
                        bool index_certs_47305;
                        
                        if (!y_47303) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_50037, "] out of bounds for array of shape [", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_47017, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:151:22-34\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:186:7-190:30\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:151:22-34
                        
                        int64_t defunc_0_f_res_47306 = ((int64_t *) mem_50489)[i_50037];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:151:22-34
                        
                        int64_t defunc_0_f_res_47307 = ((int64_t *) mem_50491)[i_50037];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:152:33-35
                        
                        int64_t tmp_47308 = add64((int64_t) 1, i_50037);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36
                        
                        bool x_47309 = sle64((int64_t) 0, tmp_47308);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36
                        
                        bool y_47310 = slt64(tmp_47308, dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_47017);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36
                        
                        bool bounds_check_47311 = x_47309 && y_47310;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36
                        
                        bool index_certs_47312;
                        
                        if (!bounds_check_47311) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_47308, "] out of bounds for array of shape [", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_47017, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:186:7-190:30\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36
                        
                        int64_t defunc_0_f_res_47313 = ((int64_t *) mem_50489)[tmp_47308];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36
                        
                        int64_t defunc_0_f_res_47314 = ((int64_t *) mem_50491)[tmp_47308];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:45-49
                        
                        int64_t merge_sequential_arg2_47315 = add64(stride_46996, defunc_0_f_res_47307);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:53-57
                        
                        int64_t merge_sequential_arg2_47316 = add64(stride_46996, defunc_0_f_res_47314);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        int64_t j_m_i_47317 = sub64(merge_sequential_arg2_47316, merge_sequential_arg2_47315);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool empty_slice_47318 = j_m_i_47317 == (int64_t) 0;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        int64_t m_47319 = sub64(j_m_i_47317, (int64_t) 1);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        int64_t i_p_m_t_s_47320 = add64(merge_sequential_arg2_47315, m_47319);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool zzero_leq_i_p_m_t_s_47321 = sle64((int64_t) 0, i_p_m_t_s_47320);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool i_p_m_t_s_leq_w_47322 = slt64(i_p_m_t_s_47320, next_stride_46997);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool zzero_lte_i_47323 = sle64((int64_t) 0, merge_sequential_arg2_47315);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool i_lte_j_47324 = sle64(merge_sequential_arg2_47315, merge_sequential_arg2_47316);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool y_47325 = i_p_m_t_s_leq_w_47322 && zzero_lte_i_47323;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool y_47326 = zzero_leq_i_p_m_t_s_47321 && y_47325;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool forwards_ok_47327 = i_lte_j_47324 && y_47326;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool ok_or_empty_47328 = empty_slice_47318 || forwards_ok_47327;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool index_certs_47329;
                        
                        if (!ok_or_empty_47328) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) merge_sequential_arg2_47315, ":", (long long) merge_sequential_arg2_47316, "] out of bounds for array of shape [", (long long) next_stride_46997, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:186:7-190:30\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        int64_t j_m_i_47330 = sub64(defunc_0_f_res_47313, defunc_0_f_res_47306);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool empty_slice_47331 = j_m_i_47330 == (int64_t) 0;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        int64_t m_47332 = sub64(j_m_i_47330, (int64_t) 1);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        int64_t i_p_m_t_s_47333 = add64(defunc_0_f_res_47306, m_47332);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool zzero_leq_i_p_m_t_s_47334 = sle64((int64_t) 0, i_p_m_t_s_47333);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool i_p_m_t_s_leq_w_47335 = slt64(i_p_m_t_s_47333, next_stride_46997);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool zzero_lte_i_47336 = sle64((int64_t) 0, defunc_0_f_res_47306);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool i_lte_j_47337 = sle64(defunc_0_f_res_47306, defunc_0_f_res_47313);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool y_47338 = i_p_m_t_s_leq_w_47335 && zzero_lte_i_47336;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool y_47339 = zzero_leq_i_p_m_t_s_47334 && y_47338;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool forwards_ok_47340 = i_lte_j_47337 && y_47339;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool ok_or_empty_47341 = empty_slice_47331 || forwards_ok_47340;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool index_certs_47342;
                        
                        if (!ok_or_empty_47341) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) defunc_0_f_res_47306, ":", (long long) defunc_0_f_res_47313, "] out of bounds for array of shape [", (long long) next_stride_46997, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:186:7-190:30\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:15-54
                        
                        bool cond_47343 = slt64((int64_t) 0, j_m_i_47330);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:15-54
                        
                        int64_t dummy_47344;
                        int64_t dummy_47345;
                        double dummy_47346;
                        
                        if (cond_47343) {
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:36-42
                            
                            bool index_certs_49881;
                            
                            if (!cond_47343) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_47330, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:36-42\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:8-69\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:375:19-85\n   #8  trmodel_test.fut:186:7-190:30\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t index_primexp_49882 = start_47069 + defunc_0_f_res_47306;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t head_res_49883 = ((int64_t *) mem_param_50460.mem)[index_primexp_49882];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t head_res_49884 = ((int64_t *) mem_param_50463.mem)[index_primexp_49882];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            double head_res_49885 = ((double *) mem_param_50466.mem)[index_primexp_49882];
                            
                            dummy_47344 = head_res_49883;
                            dummy_47345 = head_res_49884;
                            dummy_47346 = head_res_49885;
                        } else {
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54
                            
                            bool y_47352 = slt64((int64_t) 0, j_m_i_47317);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54
                            
                            bool index_certs_47353;
                            
                            if (!y_47352) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_47317, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:8-69\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:375:19-85\n   #8  trmodel_test.fut:186:7-190:30\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t index_primexp_47354 = start_47069 + merge_sequential_arg2_47315;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t head_res_47355 = ((int64_t *) mem_param_50460.mem)[index_primexp_47354];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t head_res_47356 = ((int64_t *) mem_param_50463.mem)[index_primexp_47354];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            double head_res_47357 = ((double *) mem_param_50466.mem)[index_primexp_47354];
                            
                            dummy_47344 = head_res_47355;
                            dummy_47345 = head_res_47356;
                            dummy_47346 = head_res_47357;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
                        for (int64_t nest_i_50897 = 0; nest_i_50897 < greatest_divisor_leq_than_res_46817; nest_i_50897++) {
                            ((int64_t *) mem_50512)[i_50037 * greatest_divisor_leq_than_res_46817 + nest_i_50897] = dummy_47344;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
                        for (int64_t nest_i_50898 = 0; nest_i_50898 < greatest_divisor_leq_than_res_46817; nest_i_50898++) {
                            ((int64_t *) mem_50509)[i_50037 * greatest_divisor_leq_than_res_46817 + nest_i_50898] = dummy_47345;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
                        for (int64_t nest_i_50899 = 0; nest_i_50899 < greatest_divisor_leq_than_res_46817; nest_i_50899++) {
                            ((double *) mem_50506)[i_50037 * greatest_divisor_leq_than_res_46817 + nest_i_50899] = dummy_47346;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:5-110:29
                        
                        int64_t data_47361;
                        int64_t i_47366 = (int64_t) 0;
                        
                        for (int64_t k_47365 = 0; k_47365 < greatest_divisor_leq_than_res_46817; k_47365++) {
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:103:16-18
                            
                            int64_t j_47370 = sub64(k_47365, i_47366);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:9-108:20
                            
                            bool cond_47371 = j_47370 == j_m_i_47317;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:9-108:20
                            
                            bool cond_47372;
                            
                            if (cond_47371) {
                                cond_47372 = 1;
                            } else {
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:30-59
                                
                                bool cond_47373 = slt64(i_47366, j_m_i_47330);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:30-59
                                
                                bool cond_f_res_47374;
                                
                                if (cond_47373) {
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59
                                    
                                    bool x_49886 = sle64((int64_t) 0, j_47370);
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59
                                    
                                    bool y_49887 = slt64(j_47370, j_m_i_47317);
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59
                                    
                                    bool bounds_check_49888 = x_49886 && y_49887;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59
                                    
                                    bool index_certs_49889;
                                    
                                    if (!bounds_check_49888) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_47370, "] out of bounds for array of shape [", (long long) j_m_i_47317, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:8-69\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:375:19-85\n   #8  trmodel_test.fut:186:7-190:30\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54
                                    
                                    bool x_49894 = sle64((int64_t) 0, i_47366);
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54
                                    
                                    bool bounds_check_49895 = cond_47373 && x_49894;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54
                                    
                                    bool index_certs_49896;
                                    
                                    if (!bounds_check_49895) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_47366, "] out of bounds for array of shape [", (long long) j_m_i_47330, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:8-69\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:375:19-85\n   #8  trmodel_test.fut:186:7-190:30\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
                                    
                                    int64_t index_primexp_49890 = merge_sequential_arg2_47315 + j_47370;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                    
                                    int64_t index_primexp_49891 = start_47069 + index_primexp_49890;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                    
                                    int64_t leq_arg1_49892 = ((int64_t *) mem_param_50460.mem)[index_primexp_49891];
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                    
                                    int64_t leq_arg1_49893 = ((int64_t *) mem_param_50463.mem)[index_primexp_49891];
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
                                    
                                    int64_t index_primexp_49897 = defunc_0_f_res_47306 + i_47366;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                    
                                    int64_t index_primexp_49898 = start_47069 + index_primexp_49897;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                    
                                    int64_t leq_arg0_49899 = ((int64_t *) mem_param_50460.mem)[index_primexp_49898];
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                    
                                    int64_t leq_arg0_49900 = ((int64_t *) mem_param_50463.mem)[index_primexp_49898];
                                    
                                    // ../lib/github.com/diku-dk/sparse/mono.fut:75:41-74
                                    
                                    bool cond_49901 = slt64(leq_arg0_49899, leq_arg1_49892);
                                    
                                    // ../lib/github.com/diku-dk/sparse/mono.fut:75:53-73
                                    
                                    bool cond_49902 = leq_arg0_49899 == leq_arg1_49892;
                                    
                                    // ../lib/github.com/diku-dk/sparse/mono.fut:75:68-73
                                    
                                    bool lifted_lambda_res_f_res_t_res_49903 = sle64(leq_arg0_49900, leq_arg1_49893);
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:46-59
                                    
                                    bool x_49904 = cond_49902 && lifted_lambda_res_f_res_t_res_49903;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:46-59
                                    
                                    bool x_49905 = !cond_49901;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:46-59
                                    
                                    bool y_49906 = x_49904 && x_49905;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:46-59
                                    
                                    bool lifted_lambda_res_49907 = cond_49901 || y_49906;
                                    
                                    cond_f_res_47374 = lifted_lambda_res_49907;
                                } else {
                                    cond_f_res_47374 = 0;
                                }
                                cond_47372 = cond_f_res_47374;
                            }
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:9-108:20
                            
                            int64_t loopres_47397;
                            int64_t loopres_47398;
                            int64_t loopres_47399;
                            double loopres_47400;
                            
                            if (cond_47372) {
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21
                                
                                bool x_49909 = sle64((int64_t) 0, i_47366);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21
                                
                                bool y_49910 = slt64(i_47366, j_m_i_47330);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21
                                
                                bool bounds_check_49911 = x_49909 && y_49910;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21
                                
                                bool index_certs_49912;
                                
                                if (!bounds_check_49911) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_47366, "] out of bounds for array of shape [", (long long) j_m_i_47330, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:8-69\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:375:19-85\n   #8  trmodel_test.fut:186:7-190:30\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:13-15
                                
                                int64_t tmp_49908 = add64((int64_t) 1, i_47366);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
                                
                                int64_t index_primexp_49913 = defunc_0_f_res_47306 + i_47366;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t index_primexp_49914 = start_47069 + index_primexp_49913;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t tmp_49915 = ((int64_t *) mem_param_50460.mem)[index_primexp_49914];
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t tmp_49916 = ((int64_t *) mem_param_50463.mem)[index_primexp_49914];
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                double tmp_49917 = ((double *) mem_param_50466.mem)[index_primexp_49914];
                                
                                loopres_47397 = tmp_49908;
                                loopres_47398 = tmp_49915;
                                loopres_47399 = tmp_49916;
                                loopres_47400 = tmp_49917;
                            } else {
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19
                                
                                bool x_47411 = sle64((int64_t) 0, j_47370);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19
                                
                                bool y_47412 = slt64(j_47370, j_m_i_47317);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19
                                
                                bool bounds_check_47413 = x_47411 && y_47412;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19
                                
                                bool index_certs_47414;
                                
                                if (!bounds_check_47413) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_47370, "] out of bounds for array of shape [", (long long) j_m_i_47317, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:8-69\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:375:19-85\n   #8  trmodel_test.fut:186:7-190:30\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
                                
                                int64_t index_primexp_47415 = merge_sequential_arg2_47315 + j_47370;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t index_primexp_47416 = start_47069 + index_primexp_47415;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t tmp_47417 = ((int64_t *) mem_param_50460.mem)[index_primexp_47416];
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t tmp_47418 = ((int64_t *) mem_param_50463.mem)[index_primexp_47416];
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                double tmp_47419 = ((double *) mem_param_50466.mem)[index_primexp_47416];
                                
                                loopres_47397 = i_47366;
                                loopres_47398 = tmp_47417;
                                loopres_47399 = tmp_47418;
                                loopres_47400 = tmp_47419;
                            }
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:110:11-28
                            ((int64_t *) mem_50512)[i_50037 * greatest_divisor_leq_than_res_46817 + k_47365] = loopres_47398;
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:110:11-28
                            ((int64_t *) mem_50509)[i_50037 * greatest_divisor_leq_than_res_46817 + k_47365] = loopres_47399;
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:110:11-28
                            ((double *) mem_50506)[i_50037 * greatest_divisor_leq_than_res_46817 + k_47365] = loopres_47400;
                            
                            int64_t i_tmp_50900 = loopres_47397;
                            
                            i_47366 = i_tmp_50900;
                        }
                        data_47361 = i_47366;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
                    if (memblock_alloc(ctx, &mem_50563, bytes_50505, "mem_50563")) {
                        err = 1;
                        goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
                    lmad_copy_8b(ctx, 2, (uint64_t *) mem_50563.mem, (int64_t) 0, (int64_t []) {greatest_divisor_leq_than_res_46817, (int64_t) 1}, (uint64_t *) mem_50512, (int64_t) 0, (int64_t []) {greatest_divisor_leq_than_res_46817, (int64_t) 1}, (int64_t []) {num_blocks_47016, greatest_divisor_leq_than_res_46817});
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
                    if (memblock_alloc(ctx, &mem_50567, bytes_50505, "mem_50567")) {
                        err = 1;
                        goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
                    lmad_copy_8b(ctx, 2, (uint64_t *) mem_50567.mem, (int64_t) 0, (int64_t []) {greatest_divisor_leq_than_res_46817, (int64_t) 1}, (uint64_t *) mem_50509, (int64_t) 0, (int64_t []) {greatest_divisor_leq_than_res_46817, (int64_t) 1}, (int64_t []) {num_blocks_47016, greatest_divisor_leq_than_res_46817});
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
                    if (memblock_alloc(ctx, &mem_50571, bytes_50505, "mem_50571")) {
                        err = 1;
                        goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
                    lmad_copy_8b(ctx, 2, (uint64_t *) mem_50571.mem, (int64_t) 0, (int64_t []) {greatest_divisor_leq_than_res_46817, (int64_t) 1}, (uint64_t *) mem_50506, (int64_t) 0, (int64_t []) {greatest_divisor_leq_than_res_46817, (int64_t) 1}, (int64_t []) {num_blocks_47016, greatest_divisor_leq_than_res_46817});
                    if (memblock_set(ctx, &ext_mem_50605, &mem_50563, "mem_50563") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_50602, &mem_50567, "mem_50567") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_50599, &mem_50571, "mem_50571") != 0)
                        return 1;
                }
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_50469, i_50047 * next_stride_46997, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_50599.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {next_stride_46997});
                if (memblock_unref(ctx, &ext_mem_50599, "ext_mem_50599") != 0)
                    return 1;
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_50472, i_50047 * next_stride_46997, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_50602.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {next_stride_46997});
                if (memblock_unref(ctx, &ext_mem_50602, "ext_mem_50602") != 0)
                    return 1;
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_50475, i_50047 * next_stride_46997, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_50605.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {next_stride_46997});
                if (memblock_unref(ctx, &ext_mem_50605, "ext_mem_50605") != 0)
                    return 1;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            
            int64_t flat_dim_47429 = next_stride_46997 * num_merges_47001;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            if (memblock_alloc(ctx, &mem_50620, bytes_50468, "mem_50620")) {
                err = 1;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            lmad_copy_8b(ctx, 2, (uint64_t *) mem_50620.mem, (int64_t) 0, (int64_t []) {next_stride_46997, (int64_t) 1}, (uint64_t *) mem_50475, (int64_t) 0, (int64_t []) {next_stride_46997, (int64_t) 1}, (int64_t []) {num_merges_47001, next_stride_46997});
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            if (memblock_alloc(ctx, &mem_50624, bytes_50468, "mem_50624")) {
                err = 1;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            lmad_copy_8b(ctx, 2, (uint64_t *) mem_50624.mem, (int64_t) 0, (int64_t []) {next_stride_46997, (int64_t) 1}, (uint64_t *) mem_50472, (int64_t) 0, (int64_t []) {next_stride_46997, (int64_t) 1}, (int64_t []) {num_merges_47001, next_stride_46997});
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            if (memblock_alloc(ctx, &mem_50628, bytes_50468, "mem_50628")) {
                err = 1;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            lmad_copy_8b(ctx, 2, (uint64_t *) mem_50628.mem, (int64_t) 0, (int64_t []) {next_stride_46997, (int64_t) 1}, (uint64_t *) mem_50469, (int64_t) 0, (int64_t []) {next_stride_46997, (int64_t) 1}, (int64_t []) {num_merges_47001, next_stride_46997});
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:252:18-28
            
            bool loop_cond_47433 = slt64(next_stride_46997, flat_dim_46794);
            
            if (memblock_set(ctx, &mem_param_tmp_50867, &mem_50620, "mem_50620") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_50868, &mem_50624, "mem_50624") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_50869, &mem_50628, "mem_50628") != 0)
                return 1;
            
            int64_t loop_dz2084Uz2082U_tmp_50870 = flat_dim_47429;
            bool loop_while_tmp_50871 = loop_cond_47433;
            int64_t stride_tmp_50875 = next_stride_46997;
            
            if (memblock_set(ctx, &mem_param_50460, &mem_param_tmp_50867, "mem_param_tmp_50867") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_50463, &mem_param_tmp_50868, "mem_param_tmp_50868") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_50466, &mem_param_tmp_50869, "mem_param_tmp_50869") != 0)
                return 1;
            loop_dz2084Uz2082U_46991 = loop_dz2084Uz2082U_tmp_50870;
            loop_while_46992 = loop_while_tmp_50871;
            stride_46996 = stride_tmp_50875;
        }
        if (memblock_set(ctx, &ext_mem_50638, &mem_param_50460, "mem_param_50460") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_50637, &mem_param_50463, "mem_param_50463") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_50636, &mem_param_50466, "mem_param_50466") != 0)
            return 1;
        data_46985 = loop_dz2084Uz2082U_46991;
        data_46986 = loop_while_46992;
        data_46990 = stride_46996;
        if (memblock_unref(ctx, &mem_50448, "mem_50448") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50452, "mem_50452") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50456, "mem_50456") != 0)
            return 1;
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:265:3-14
        
        bool i_p_m_t_s_leq_w_47434 = slt64(zp_lhs_48712, data_46985);
        
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:265:3-14
        
        bool ok_or_empty_47436 = empty_slice_46874 || i_p_m_t_s_leq_w_47434;
        
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:265:3-14
        
        bool index_certs_47437;
        
        if (!ok_or_empty_47436) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) replicate_arg0_48713, "] out of bounds for array of shape [", (long long) data_46985, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:265:3-14\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:375:19-85\n   #6  trmodel_test.fut:186:7-190:30\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        if (memblock_set(ctx, &ext_mem_50647, &ext_mem_50638, "ext_mem_50638") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_50644, &ext_mem_50637, "ext_mem_50637") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_50641, &ext_mem_50636, "ext_mem_50636") != 0)
            return 1;
    }
    if (memblock_unref(ctx, &mem_50339, "mem_50339") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50341, "mem_50341") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50343, "mem_50343") != 0)
        return 1;
    // ../lib/github.com/diku-dk/sparse/mono.fut:79:17-81:38
    if (mem_50648_cached_sizze_51039 < replicate_arg0_48713) {
        err = lexical_realloc(ctx, &mem_50648, &mem_50648_cached_sizze_51039, replicate_arg0_48713);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // ../lib/github.com/diku-dk/sparse/mono.fut:79:17-81:38
    for (int64_t i_50053 = 0; i_50053 < replicate_arg0_48713; i_50053++) {
        int64_t eta_p_49137 = ((int64_t *) ext_mem_50647.mem)[i_50053];
        int64_t eta_p_49138 = ((int64_t *) ext_mem_50644.mem)[i_50053];
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:81:23-38
        
        int64_t zv_lhs_49139 = add64((int64_t) -1, i_50053);
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:81:23-38
        
        int64_t tmp_49140 = smod64(zv_lhs_49139, replicate_arg0_48713);
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:81:23-38
        
        int64_t lifted_lambda_res_49141 = ((int64_t *) ext_mem_50647.mem)[tmp_49140];
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:81:23-38
        
        int64_t lifted_lambda_res_49142 = ((int64_t *) ext_mem_50644.mem)[tmp_49140];
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:79:47-63
        
        bool cond_49145 = eta_p_49137 == lifted_lambda_res_49141;
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:79:47-63
        
        bool cond_49146 = !cond_49145;
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:79:59-63
        
        bool lifted_lambda_res_f_res_49147 = eta_p_49138 == lifted_lambda_res_49142;
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:79:59-63
        
        bool lifted_lambda_res_f_res_49148 = !lifted_lambda_res_f_res_49147;
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:79:17-81:38
        
        bool y_49149 = cond_49145 && lifted_lambda_res_f_res_49148;
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:79:17-81:38
        
        bool lifted_lambda_res_49150 = cond_49146 || y_49149;
        
        ((bool *) mem_50648)[i_50053] = lifted_lambda_res_49150;
    }
    // ../lib/github.com/diku-dk/sparse/mono.fut:82:17-83:27
    
    bool cond_47459 = sle64((int64_t) 1, replicate_arg0_48713);
    
    // ../lib/github.com/diku-dk/sparse/mono.fut:89:18-30
    
    bool loop_not_taken_47460 = !cond_47459;
    
    // ../lib/github.com/diku-dk/sparse/mono.fut:89:18-30
    
    bool protect_assert_disj_47461 = y_46818 || loop_not_taken_47460;
    
    // ../lib/github.com/diku-dk/sparse/mono.fut:82:34-55
    
    bool index_certs_47462;
    
    if (!protect_assert_disj_47461) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) replicate_arg0_48713, "].", "-> #0  ../lib/github.com/diku-dk/sparse/mono.fut:82:34-55\n   #1  ../lib/github.com/diku-dk/sparse/mono.fut:89:21-30\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #3  trmodel.fut:375:19-85\n   #4  trmodel_test.fut:186:7-190:30\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // ../lib/github.com/diku-dk/sparse/mono.fut:82:17-83:27
    if (cond_47459) {
        // ../lib/github.com/diku-dk/sparse/mono.fut:82:34-55
        ((bool *) mem_50648)[(int64_t) 0] = 1;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:21:38-28:71
    if (mem_50656_cached_sizze_51040 < bytes_50338) {
        err = lexical_realloc(ctx, &mem_50656, &mem_50656_cached_sizze_51040, bytes_50338);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:21:38-28:71
    if (mem_50657_cached_sizze_51041 < replicate_arg0_48713) {
        err = lexical_realloc(ctx, &mem_50657, &mem_50657_cached_sizze_51041, replicate_arg0_48713);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:21:38-28:71
    
    int64_t discard_50063;
    int64_t scanacc_50057 = (int64_t) 0;
    
    for (int64_t i_50060 = 0; i_50060 < replicate_arg0_48713; i_50060++) {
        // ../lib/github.com/diku-dk/segmented/segmented.fut:26:22-36
        
        int64_t zv_lhs_48810 = add64((int64_t) 1, i_50060);
        
        // ../lib/github.com/diku-dk/segmented/segmented.fut:26:22-36
        
        int64_t tmp_48811 = smod64(zv_lhs_48810, replicate_arg0_48713);
        
        // ../lib/github.com/diku-dk/segmented/segmented.fut:26:22-36
        
        bool lifted_lambda_res_48812 = ((bool *) mem_50648)[tmp_48811];
        
        // ../lib/github.com/diku-dk/segmented/segmented.fut:28:49-57
        
        int64_t bool_res_48814 = btoi_bool_i64(lifted_lambda_res_48812);
        
        // ../lib/github.com/diku-dk/segmented/segmented.fut:28:66-69
        
        int64_t defunc_0_op_res_47498 = add64(bool_res_48814, scanacc_50057);
        
        ((int64_t *) mem_50656)[i_50060] = defunc_0_op_res_47498;
        ((bool *) mem_50657)[i_50060] = lifted_lambda_res_48812;
        
        int64_t scanacc_tmp_50905 = defunc_0_op_res_47498;
        
        scanacc_50057 = scanacc_tmp_50905;
    }
    discard_50063 = scanacc_50057;
    // ../lib/github.com/diku-dk/segmented/segmented.fut:29:36-60
    
    int64_t num_segments_t_res_47499;
    
    if (y_46818) {
        // ../lib/github.com/diku-dk/sparse/mono.fut:85:8-86:49
        
        bool y_49955 = slt64(zp_lhs_48712, replicate_arg0_48713);
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:85:8-86:49
        
        bool index_certs_49956;
        
        if (!y_49955) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) zp_lhs_48712, "] out of bounds for array of shape [", (long long) replicate_arg0_48713, "].", "-> #0  ../lib/github.com/diku-dk/sparse/mono.fut:85:8-86:49\n   #1  ../lib/github.com/diku-dk/sparse/mono.fut:89:21-30\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #3  trmodel.fut:375:19-85\n   #4  trmodel_test.fut:186:7-190:30\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        // ../lib/github.com/diku-dk/sparse/mono.fut:85:8-86:49
        
        int64_t last_res_49957 = ((int64_t *) mem_50656)[zp_lhs_48712];
        
        num_segments_t_res_47499 = last_res_49957;
    } else {
        num_segments_t_res_47499 = (int64_t) 0;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:29:22-67
    
    int64_t num_segments_47504;
    
    if (y_46818) {
        num_segments_47504 = num_segments_t_res_47499;
    } else {
        num_segments_47504 = (int64_t) 0;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:33:17-42
    
    int64_t bytes_50670 = (int64_t) 8 * num_segments_47504;
    bool loop_nonempty_47554 = slt64((int64_t) 0, N_36890);
    
    // trmodel.fut:395:24-34
    
    bool i_p_m_t_s_leq_w_47555 = slt64(zp_lhs_48712, replicate_arg0_48713);
    
    // trmodel.fut:395:24-34
    
    bool ok_or_empty_47557 = empty_slice_46874 || i_p_m_t_s_leq_w_47555;
    
    // trmodel.fut:395:24-34
    
    bool y_47558 = slt64((int64_t) 0, replicate_arg0_48715);
    
    // trmodel.fut:395:24-34
    
    bool index_ok_47559 = ok_or_empty_47557 && y_47558;
    bool loop_not_taken_47560 = !loop_nonempty_47554;
    bool protect_assert_disj_47561 = index_ok_47559 || loop_not_taken_47560;
    
    // trmodel.fut:395:24-34
    
    bool index_certs_47562;
    
    if (!protect_assert_disj_47561) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":, ", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) replicate_arg0_48713, "][", (long long) replicate_arg0_48715, "].", "-> #0  trmodel.fut:395:24-34\n   #1  trmodel.fut:428:15-429:27\n   #2  trmodel_test.fut:186:7-191:66\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // trmodel.fut:404:11-27
    
    bool empty_slice_47564 = zp_lhs_48712 == (int64_t) 0;
    
    // trmodel.fut:404:11-27
    
    int64_t m_47565 = sub64(zp_lhs_48712, (int64_t) 1);
    
    // trmodel.fut:404:11-27
    
    bool zzero_leq_i_p_m_t_s_47566 = sle64((int64_t) 0, m_47565);
    
    // trmodel.fut:404:11-27
    
    bool i_p_m_t_s_leq_w_47567 = slt64(m_47565, replicate_arg0_48713);
    
    // trmodel.fut:404:11-27
    
    bool y_47569 = zzero_leq_i_p_m_t_s_47566 && i_p_m_t_s_leq_w_47567;
    
    // trmodel.fut:404:11-27
    
    bool ok_or_empty_47571 = empty_slice_47564 || y_47569;
    bool protect_assert_disj_47572 = loop_not_taken_47560 || ok_or_empty_47571;
    
    // trmodel.fut:404:11-27
    
    bool index_certs_47573;
    
    if (!protect_assert_disj_47572) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) zp_lhs_48712, "] out of bounds for array of shape [", (long long) replicate_arg0_48713, "].", "-> #0  trmodel.fut:404:11-27\n   #1  trmodel.fut:428:15-429:27\n   #2  trmodel_test.fut:186:7-191:66\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // trmodel.fut:406:24-26
    
    int64_t utils_trade_47574 = sub64(replicate_arg0_48715, (int64_t) 1);
    
    // trmodel.fut:406:12-27
    
    int64_t j_m_i_47575 = sub64(utils_trade_47574, (int64_t) 1);
    
    // trmodel.fut:406:12-27
    
    bool empty_slice_47576 = j_m_i_47575 == (int64_t) 0;
    
    // trmodel.fut:406:12-27
    
    bool zzero_leq_i_p_m_t_s_47577 = sle64((int64_t) 0, j_m_i_47575);
    
    // trmodel.fut:406:12-27
    
    bool i_p_m_t_s_leq_w_47578 = slt64(j_m_i_47575, replicate_arg0_48715);
    
    // trmodel.fut:406:12-27
    
    bool i_lte_j_47579 = sle64((int64_t) 1, utils_trade_47574);
    
    // trmodel.fut:406:12-27
    
    bool y_47580 = zzero_leq_i_p_m_t_s_47577 && i_p_m_t_s_leq_w_47578;
    
    // trmodel.fut:406:12-27
    
    bool forwards_ok_47581 = i_lte_j_47579 && y_47580;
    
    // trmodel.fut:406:12-27
    
    bool ok_or_empty_47582 = empty_slice_47576 || forwards_ok_47581;
    
    // trmodel.fut:406:12-27
    
    bool index_ok_47583 = ok_or_empty_47557 && ok_or_empty_47582;
    bool protect_assert_disj_47584 = loop_not_taken_47560 || index_ok_47583;
    
    // trmodel.fut:406:12-27
    
    bool index_certs_47585;
    
    if (!protect_assert_disj_47584) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":, ", (long long) (int64_t) 1, ":", (long long) utils_trade_47574, "] out of bounds for array of shape [", (long long) replicate_arg0_48713, "][", (long long) replicate_arg0_48715, "].", "-> #0  trmodel.fut:406:12-27\n   #1  trmodel.fut:428:15-429:27\n   #2  trmodel_test.fut:186:7-191:66\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // trmodel.fut:428:15-429:27
    
    bool dim_match_47586 = zp_lhs_48712 == j_m_i_47575;
    bool protect_assert_disj_47587 = loop_not_taken_47560 || dim_match_47586;
    
    // trmodel.fut:428:15-429:27
    
    bool empty_or_match_cert_47588;
    
    if (!protect_assert_disj_47587) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Value of (desugared) shape [", (long long) replicate_arg0_48713, "][", (long long) j_m_i_47575, "] cannot match shape of type \"[", (long long) replicate_arg0_48713, "][", (long long) zp_lhs_48712, "]f64\".", "-> #0  trmodel.fut:428:15-429:27\n   #1  trmodel_test.fut:186:7-191:66\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool protect_assert_disj_47589 = i_p_m_t_s_leq_w_47555 || loop_not_taken_47560;
    
    // trmodel.fut:410:28-36
    
    bool index_certs_47590;
    
    if (!protect_assert_disj_47589) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) zp_lhs_48712, "] out of bounds for array of shape [", (long long) replicate_arg0_48713, "].", "-> #0  trmodel.fut:410:28-36\n   #1  trmodel.fut:428:15-429:27\n   #2  trmodel_test.fut:186:7-191:66\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // trmodel.fut:411:25-38
    
    bool x_47591 = sle64((int64_t) 0, utils_trade_47574);
    
    // trmodel.fut:411:25-38
    
    bool y_47592 = slt64(utils_trade_47574, replicate_arg0_48715);
    
    // trmodel.fut:411:25-38
    
    bool bounds_check_47593 = x_47591 && y_47592;
    
    // trmodel.fut:411:25-38
    
    bool index_ok_47594 = ok_or_empty_47557 && bounds_check_47593;
    bool protect_assert_disj_47595 = loop_not_taken_47560 || index_ok_47594;
    
    // trmodel.fut:411:25-38
    
    bool index_certs_47596;
    
    if (!protect_assert_disj_47595) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":, ", (long long) utils_trade_47574, "] out of bounds for array of shape [", (long long) replicate_arg0_48713, "][", (long long) replicate_arg0_48715, "].", "-> #0  trmodel.fut:411:25-38\n   #1  trmodel.fut:428:15-429:27\n   #2  trmodel_test.fut:186:7-191:66\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // trmodel.fut:420:11-39
    
    bool i_p_m_t_s_leq_w_47598 = slt64(zp_lhs_48712, replicate_arg0_48715);
    
    // trmodel.fut:420:11-39
    
    bool forwards_ok_47600 = cond_47459 && i_p_m_t_s_leq_w_47598;
    
    // trmodel.fut:420:11-39
    
    bool ok_or_empty_47601 = empty_slice_47564 || forwards_ok_47600;
    
    // trmodel.fut:420:11-39
    
    bool index_ok_47602 = ok_or_empty_47557 && ok_or_empty_47601;
    bool protect_assert_disj_47603 = loop_not_taken_47560 || index_ok_47602;
    
    // trmodel.fut:420:11-39
    
    bool index_certs_47604;
    
    if (!protect_assert_disj_47603) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":, ", (long long) (int64_t) 1, ":", (long long) replicate_arg0_48713, "] out of bounds for array of shape [", (long long) replicate_arg0_48713, "][", (long long) replicate_arg0_48715, "].", "-> #0  trmodel.fut:420:11-39\n   #1  trmodel.fut:428:15-429:27\n   #2  trmodel_test.fut:186:7-191:66\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // trmodel.fut:390:30-402:30
    
    int64_t bytes_50685 = (int64_t) 8 * zp_lhs_48712;
    
    // trmodel.fut:403:23-411:38
    
    int64_t bytes_50696 = zp_lhs_48712 * bytes_50338;
    
    // trmodel.fut:417:28-63
    
    int64_t bytes_50729 = replicate_arg0_48715 * bytes_50338;
    
    // trmodel.fut:123:24-46
    if (memblock_alloc(ctx, &mem_50259, bytes_50258, "mem_50259")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:123:24-46
    for (int64_t nest_i_50908 = 0; nest_i_50908 < n_36887; nest_i_50908++) {
        ((double *) mem_50259.mem)[nest_i_50908] = 0.10000000149011612;
    }
    // trmodel.fut:124:47-52
    
    double i64_res_48703 = sitofp_i64_f64(n_36887);
    
    // trmodel.fut:124:39-52
    
    double zs_res_48704 = 1.0 / i64_res_48703;
    
    // trmodel.fut:124:24-52
    if (memblock_alloc(ctx, &mem_50261, bytes_50258, "mem_50261")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:124:24-52
    for (int64_t nest_i_50909 = 0; nest_i_50909 < n_36887; nest_i_50909++) {
        ((double *) mem_50261.mem)[nest_i_50909] = zs_res_48704;
    }
    // trmodel.fut:126:24-44
    if (memblock_alloc(ctx, &mem_50263, bytes_50262, "mem_50263")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:126:24-44
    for (int64_t nest_i_50910 = 0; nest_i_50910 < c_36886; nest_i_50910++) {
        ((double *) mem_50263.mem)[nest_i_50910] = 1.0;
    }
    // trmodel.fut:127:24-44
    if (memblock_alloc(ctx, &mem_50265, bytes_50258, "mem_50265")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:127:24-44
    for (int64_t nest_i_50911 = 0; nest_i_50911 < n_36887; nest_i_50911++) {
        ((double *) mem_50265.mem)[nest_i_50911] = 0.0;
    }
    // trmodel_test.fut:185:49-62
    if (memblock_alloc(ctx, &mem_50268, bytes_50267, "mem_50268")) {
        err = 1;
        goto cleanup;
    }
    // trmodel_test.fut:185:49-62
    for (int64_t nest_i_50912 = 0; nest_i_50912 < n_36887; nest_i_50912++) {
        for (int64_t nest_i_50913 = 0; nest_i_50913 < c_36886; nest_i_50913++) {
            ((double *) mem_50268.mem)[nest_i_50912 * c_36886 + nest_i_50913] = 6.0;
        }
    }
    // trmodel_test.fut:185:49-62
    if (memblock_alloc(ctx, &mem_50271, bytes_50267, "mem_50271")) {
        err = 1;
        goto cleanup;
    }
    // trmodel_test.fut:185:49-62
    for (int64_t nest_i_50914 = 0; nest_i_50914 < n_36887; nest_i_50914++) {
        for (int64_t nest_i_50915 = 0; nest_i_50915 < c_36886; nest_i_50915++) {
            ((double *) mem_50271.mem)[nest_i_50914 * c_36886 + nest_i_50915] = -0.5;
        }
    }
    // trmodel_test.fut:185:49-62
    if (memblock_alloc(ctx, &mem_50274, bytes_50267, "mem_50274")) {
        err = 1;
        goto cleanup;
    }
    // trmodel_test.fut:185:49-62
    for (int64_t nest_i_50916 = 0; nest_i_50916 < n_36887; nest_i_50916++) {
        for (int64_t nest_i_50917 = 0; nest_i_50917 < c_36886; nest_i_50917++) {
            ((double *) mem_50274.mem)[nest_i_50916 * c_36886 + nest_i_50917] = 0.0;
        }
    }
    // trmodel.fut:133:24-45
    if (memblock_alloc(ctx, &mem_50275, (int64_t) 0, "mem_50275")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:133:24-45
    for (int64_t nest_i_50918 = 0; nest_i_50918 < replicate_arg0_48713; nest_i_50918++) { }
    // trmodel.fut:134:24-45
    if (memblock_alloc(ctx, &mem_50276, (int64_t) 0, "mem_50276")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:134:24-45
    for (int64_t nest_i_50919 = 0; nest_i_50919 < replicate_arg0_48715; nest_i_50919++) { }
    // trmodel.fut:135:24-39
    if (memblock_alloc(ctx, &mem_50277, (int64_t) 0, "mem_50277")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:135:24-39
    for (int64_t nest_i_50920 = 0; nest_i_50920 < Ax_36889; nest_i_50920++) { }
    // trmodel.fut:136:24-48
    if (memblock_alloc(ctx, &mem_50279, bytes_50262, "mem_50279")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:136:24-48
    for (int64_t nest_i_50921 = 0; nest_i_50921 < c_36886; nest_i_50921++) {
        ((double *) mem_50279.mem)[nest_i_50921] = -10.0;
    }
    // trmodel.fut:137:24-44
    if (memblock_alloc(ctx, &mem_50281, bytes_50262, "mem_50281")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:137:24-44
    for (int64_t nest_i_50922 = 0; nest_i_50922 < c_36886; nest_i_50922++) {
        ((double *) mem_50281.mem)[nest_i_50922] = 0.0;
    }
    // trmodel.fut:180:28-68
    if (mem_50283_cached_sizze_51020 < bytes_50282) {
        err = lexical_realloc(ctx, &mem_50283, &mem_50283_cached_sizze_51020, bytes_50282);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:180:28-68
    
    double discard_49983;
    double scanacc_49979 = 1.0;
    
    for (int64_t i_49981 = 0; i_49981 < dzlz7bUZLzmZRz20UAxz20U1z7dUzg_46740; i_49981++) {
        // trmodel.fut:180:33-38
        
        double zt_res_46746 = 0.85 * scanacc_49979;
        
        ((double *) mem_50283)[i_49981] = zt_res_46746;
        
        double scanacc_tmp_50923 = zt_res_46746;
        
        scanacc_49979 = scanacc_tmp_50923;
    }
    discard_49983 = scanacc_49979;
    // trmodel.fut:180:75-181:53
    if (mem_50292_cached_sizze_51021 < bytes_50291) {
        err = lexical_realloc(ctx, &mem_50292, &mem_50292_cached_sizze_51021, bytes_50291);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:180:75-181:53
    for (int64_t i_49990 = 0; i_49990 < c_36886; i_49990++) {
        double eta_p_46750 = ((double *) newprices_mem_50257.mem)[i_49990];
        
        // trmodel.fut:181:30-44
        for (int64_t i_49986 = 0; i_49986 < Ax_36889; i_49986++) {
            bool index_concat_cmp_50245 = sle64((int64_t) 1, i_49986);
            double index_concat_branch_50249;
            
            if (index_concat_cmp_50245) {
                int64_t index_concat_i_50246 = sub64(i_49986, (int64_t) 1);
                double index_concat_50247 = ((double *) mem_50283)[index_concat_i_50246];
                
                index_concat_branch_50249 = index_concat_50247;
            } else {
                index_concat_branch_50249 = 1.0;
            }
            // trmodel.fut:181:34-41
            
            double zt_res_46753 = eta_p_46750 * index_concat_branch_50249;
            
            ((double *) mem_50292)[i_49990 * Ax_36889 + i_49986] = zt_res_46753;
        }
    }
    // trmodel_test.fut:186:7-189:57
    if (memblock_alloc(ctx, &mem_50311, bytes_50310, "mem_50311")) {
        err = 1;
        goto cleanup;
    }
    // trmodel_test.fut:186:7-189:57
    // trmodel_test.fut:186:7-189:57
    lmad_copy_8b(ctx, 2, (uint64_t *) mem_50311.mem, (int64_t) 0, (int64_t []) {c_36886, (int64_t) 1}, (uint64_t *) mem_50292, (int64_t) 0, (int64_t []) {(int64_t) 1, Ax_36889}, (int64_t []) {Ax_36889, c_36886});
    // trmodel_test.fut:186:7-189:57
    if (futrts_utility_10336(ctx, &ext_mem_50313, mem_50279, mem_50281, mem_50281, mem_50277, mem_50259, mem_50276, mem_50275, newprices_mem_50257, mem_50263, mem_50265, mem_50261, mem_50268, mem_50271, mem_50274, mem_50311, n_36887, c_36886, Ax_36889, replicate_arg0_48713, replicate_arg0_48715, 0.949999988079071, 1.0, 0.5, (int64_t) 1) != 0) {
        err = 1;
        goto cleanup;
    }
    if (memblock_unref(ctx, &mem_50259, "mem_50259") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50261, "mem_50261") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50263, "mem_50263") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50265, "mem_50265") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50268, "mem_50268") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50271, "mem_50271") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50274, "mem_50274") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50275, "mem_50275") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50276, "mem_50276") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50277, "mem_50277") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50279, "mem_50279") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50281, "mem_50281") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50311, "mem_50311") != 0)
        return 1;
    // ../lib/github.com/diku-dk/segmented/segmented.fut:33:17-42
    if (mem_50671_cached_sizze_51042 < bytes_50670) {
        err = lexical_realloc(ctx, &mem_50671, &mem_50671_cached_sizze_51042, bytes_50670);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:33:17-42
    for (int64_t nest_i_50927 = 0; nest_i_50927 < num_segments_47504; nest_i_50927++) {
        ((double *) mem_50671)[nest_i_50927] = 0.0;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:33:17-42
    if (mem_50673_cached_sizze_51043 < bytes_50670) {
        err = lexical_realloc(ctx, &mem_50673, &mem_50673_cached_sizze_51043, bytes_50670);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:33:17-42
    for (int64_t nest_i_50928 = 0; nest_i_50928 < num_segments_47504; nest_i_50928++) {
        ((int64_t *) mem_50673)[nest_i_50928] = (int64_t) 0;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:33:17-42
    if (mem_50675_cached_sizze_51044 < bytes_50670) {
        err = lexical_realloc(ctx, &mem_50675, &mem_50675_cached_sizze_51044, bytes_50670);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:33:17-42
    for (int64_t nest_i_50929 = 0; nest_i_50929 < num_segments_47504; nest_i_50929++) {
        ((int64_t *) mem_50675)[nest_i_50929] = (int64_t) 0;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:37:6-71
    
    bool acc_cert_48821;
    bool acc_cert_48822;
    bool acc_cert_48823;
    
    // ../lib/github.com/diku-dk/segmented/segmented.fut:37:6-71
    
    int64_t inpacc_49944;
    int64_t inpacc_49945;
    double inpacc_49946;
    int64_t inpacc_48974;
    int64_t inpacc_48975;
    double inpacc_48976;
    
    inpacc_48974 = (int64_t) 0;
    inpacc_48975 = (int64_t) 0;
    inpacc_48976 = 0.0;
    for (int64_t i_50117 = 0; i_50117 < replicate_arg0_48713; i_50117++) {
        bool x_50164 = ((bool *) mem_50648)[i_50117];
        int64_t x_50165 = ((int64_t *) ext_mem_50647.mem)[i_50117];
        int64_t x_50166 = ((int64_t *) ext_mem_50644.mem)[i_50117];
        double x_50167 = ((double *) ext_mem_50641.mem)[i_50117];
        
        // ../lib/github.com/diku-dk/segmented/segmented.fut:9:11-13:24
        
        int64_t tmp_50177;
        
        if (x_50164) {
            tmp_50177 = x_50165;
        } else {
            tmp_50177 = (int64_t) 0;
        }
        // ../lib/github.com/diku-dk/segmented/segmented.fut:9:11-13:24
        
        int64_t tmp_50178;
        
        if (x_50164) {
            tmp_50178 = x_50166;
        } else {
            tmp_50178 = (int64_t) 0;
        }
        
        int64_t eta_p_50198 = ((int64_t *) mem_50656)[i_50117];
        bool eta_p_50199 = ((bool *) mem_50657)[i_50117];
        
        // ../lib/github.com/diku-dk/segmented/segmented.fut:9:11-13:24
        
        int64_t tmp_50204;
        
        if (x_50164) {
            tmp_50204 = tmp_50177;
        } else {
            tmp_50204 = inpacc_48974;
        }
        // ../lib/github.com/diku-dk/segmented/segmented.fut:9:11-13:24
        
        int64_t tmp_50205;
        
        if (x_50164) {
            tmp_50205 = tmp_50178;
        } else {
            tmp_50205 = inpacc_48975;
        }
        // ../lib/github.com/diku-dk/segmented/segmented.fut:9:11-13:24
        
        double tmp_50206;
        
        if (x_50164) {
            tmp_50206 = x_50167;
        } else {
            // ../lib/github.com/diku-dk/sparse/mono.fut:85:57-66
            
            double zp_res_50207 = inpacc_48976 + x_50167;
            
            tmp_50206 = zp_res_50207;
        }
        // ../lib/github.com/diku-dk/segmented/segmented.fut:36:19-40
        
        int64_t lifted_index_res_50208;
        
        if (eta_p_50199) {
            // ../lib/github.com/diku-dk/segmented/segmented.fut:36:30-32
            
            int64_t lifted_index_res_t_res_50209 = sub64(eta_p_50198, (int64_t) 1);
            
            lifted_index_res_50208 = lifted_index_res_t_res_50209;
        } else {
            lifted_index_res_50208 = (int64_t) -1;
        }
        // ../lib/github.com/diku-dk/segmented/segmented.fut:37:6-71
        // UpdateAcc
        if (sle64((int64_t) 0, lifted_index_res_50208) && slt64(lifted_index_res_50208, num_segments_47504)) {
            ((int64_t *) mem_50675)[lifted_index_res_50208] = tmp_50204;
        }
        // ../lib/github.com/diku-dk/segmented/segmented.fut:37:6-71
        // UpdateAcc
        if (sle64((int64_t) 0, lifted_index_res_50208) && slt64(lifted_index_res_50208, num_segments_47504)) {
            ((int64_t *) mem_50673)[lifted_index_res_50208] = tmp_50205;
        }
        // ../lib/github.com/diku-dk/segmented/segmented.fut:37:6-71
        // UpdateAcc
        if (sle64((int64_t) 0, lifted_index_res_50208) && slt64(lifted_index_res_50208, num_segments_47504)) {
            ((double *) mem_50671)[lifted_index_res_50208] = tmp_50206;
        }
        // ../lib/github.com/diku-dk/segmented/segmented.fut:9:11-13:24
        
        double tmp_49045;
        
        if (x_50164) {
            tmp_49045 = x_50167;
        } else {
            // ../lib/github.com/diku-dk/sparse/mono.fut:85:57-66
            
            double zp_res_49046 = inpacc_48976 + x_50167;
            
            tmp_49045 = zp_res_49046;
        }
        
        int64_t inpacc_tmp_50930 = tmp_50204;
        int64_t inpacc_tmp_50931 = tmp_50205;
        double inpacc_tmp_50932 = tmp_49045;
        
        inpacc_48974 = inpacc_tmp_50930;
        inpacc_48975 = inpacc_tmp_50931;
        inpacc_48976 = inpacc_tmp_50932;
    }
    inpacc_49944 = inpacc_48974;
    inpacc_49945 = inpacc_48975;
    inpacc_49946 = inpacc_48976;
    if (memblock_unref(ctx, &ext_mem_50641, "ext_mem_50641") != 0)
        return 1;
    if (memblock_unref(ctx, &ext_mem_50644, "ext_mem_50644") != 0)
        return 1;
    if (memblock_unref(ctx, &ext_mem_50647, "ext_mem_50647") != 0)
        return 1;
    // ../lib/github.com/diku-dk/sparse/mono.fut:127:27-47
    if (mem_50677_cached_sizze_51045 < bytes_50338) {
        err = lexical_realloc(ctx, &mem_50677, &mem_50677_cached_sizze_51045, bytes_50338);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // ../lib/github.com/diku-dk/sparse/mono.fut:127:27-47
    for (int64_t nest_i_50936 = 0; nest_i_50936 < replicate_arg0_48713; nest_i_50936++) {
        ((double *) mem_50677)[nest_i_50936] = 0.0;
    }
    // ../lib/github.com/diku-dk/sparse/mono.fut:128:30-43
    if (mem_50679_cached_sizze_51046 < bytes_50338) {
        err = lexical_realloc(ctx, &mem_50679, &mem_50679_cached_sizze_51046, bytes_50338);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // ../lib/github.com/diku-dk/sparse/mono.fut:128:30-43
    for (int64_t nest_i_50937 = 0; nest_i_50937 < replicate_arg0_48713; nest_i_50937++) {
        ((int64_t *) mem_50679)[nest_i_50937] = (int64_t) 0;
    }
    // ../lib/github.com/diku-dk/sparse/mono.fut:127:18-128:50
    
    bool acc_cert_47537;
    bool acc_cert_47546;
    
    // ../lib/github.com/diku-dk/sparse/mono.fut:127:18-128:50
    for (int64_t i_50125 = 0; i_50125 < num_segments_47504; i_50125++) {
        int64_t v_49447 = ((int64_t *) mem_50675)[i_50125];
        double v_49448 = ((double *) mem_50671)[i_50125];
        int64_t v_49450 = ((int64_t *) mem_50673)[i_50125];
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:127:18-54
        // UpdateAcc
        if (sle64((int64_t) 0, v_49447) && slt64(v_49447, replicate_arg0_48713)) {
            ((double *) mem_50677)[v_49447] = v_49448;
        }
        // ../lib/github.com/diku-dk/sparse/mono.fut:128:21-50
        // UpdateAcc
        if (sle64((int64_t) 0, v_49447) && slt64(v_49447, replicate_arg0_48713)) {
            ((int64_t *) mem_50679)[v_49447] = v_49450;
        }
    }
    // trmodel.fut:379:5-26
    if (memblock_alloc(ctx, &mem_50681, bytes_50338, "mem_50681")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:379:5-26
    for (int64_t nest_i_50940 = 0; nest_i_50940 < replicate_arg0_48713; nest_i_50940++) {
        ((double *) mem_50681.mem)[nest_i_50940] = 0.0;
    }
    // trmodel.fut:390:30-402:30
    if (mem_50686_cached_sizze_51047 < bytes_50685) {
        err = lexical_realloc(ctx, &mem_50686, &mem_50686_cached_sizze_51047, bytes_50685);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:403:23-411:38
    if (mem_50694_cached_sizze_51048 < bytes_50338) {
        err = lexical_realloc(ctx, &mem_50694, &mem_50694_cached_sizze_51048, bytes_50338);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:403:23-411:38
    if (mem_50697_cached_sizze_51049 < bytes_50696) {
        err = lexical_realloc(ctx, &mem_50697, &mem_50697_cached_sizze_51049, bytes_50696);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:403:23-411:38
    if (mem_50699_cached_sizze_51050 < bytes_50338) {
        err = lexical_realloc(ctx, &mem_50699, &mem_50699_cached_sizze_51050, bytes_50338);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:417:28-63
    if (mem_50730_cached_sizze_51051 < bytes_50729) {
        err = lexical_realloc(ctx, &mem_50730, &mem_50730_cached_sizze_51051, bytes_50729);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel_test.fut:191:6-66
    if (memblock_set(ctx, &mem_param_50684, &mem_50681, "mem_50681") != 0)
        return 1;
    for (int64_t _i_47607 = 0; _i_47607 < N_36890; _i_47607++) {
        // trmodel.fut:410:28-36
        
        double zt_rhs_47642 = ((double *) mem_param_50684.mem)[zp_lhs_48712];
        
        // trmodel.fut:410:17-36
        
        double zt_res_47643 = 0.949999988079071 * zt_rhs_47642;
        
        // trmodel.fut:390:30-402:30
        for (int64_t i_50128 = 0; i_50128 < zp_lhs_48712; i_50128++) {
            double eta_p_47632 = ((double *) mem_param_50684.mem)[i_50128];
            
            // trmodel.fut:402:18-30
            
            double zt_res_47633 = 0.949999988079071 * eta_p_47632;
            
            ((double *) mem_50686)[i_50128] = zt_res_47633;
        }
        // trmodel.fut:403:23-411:38
        for (int64_t i_50140 = 0; i_50140 < replicate_arg0_48713; i_50140++) {
            int64_t eta_p_49521 = ((int64_t *) mem_50679)[i_50140];
            
            // ../lib/github.com/diku-dk/sparse/mono.fut:155:27-31
            
            bool x_49525 = sle64((int64_t) 0, eta_p_49521);
            
            // ../lib/github.com/diku-dk/sparse/mono.fut:155:27-31
            
            bool y_49526 = slt64(eta_p_49521, replicate_arg0_48713);
            
            // ../lib/github.com/diku-dk/sparse/mono.fut:155:27-31
            
            bool bounds_check_49527 = x_49525 && y_49526;
            
            // ../lib/github.com/diku-dk/sparse/mono.fut:155:27-31
            
            bool index_certs_49528;
            
            if (!bounds_check_49527) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) eta_p_49521, "] out of bounds for array of shape [", (long long) replicate_arg0_48713, "].", "-> #0  ../lib/github.com/diku-dk/sparse/mono.fut:155:27-31\n   #1  trmodel.fut:394:9-29\n   #2  trmodel.fut:428:15-429:27\n   #3  trmodel_test.fut:186:7-191:66\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            double eta_p_49519 = ((double *) ext_mem_50313.mem)[i_50140 * replicate_arg0_48715 + utils_trade_47574];
            double eta_p_49522 = ((double *) mem_50677)[i_50140];
            double eta_p_49523 = ((double *) ext_mem_50313.mem)[i_50140 * replicate_arg0_48715];
            
            // ../lib/github.com/diku-dk/sparse/mono.fut:155:27-31
            
            double zt_rhs_49529 = ((double *) mem_param_50684.mem)[eta_p_49521];
            
            // ../lib/github.com/diku-dk/sparse/mono.fut:155:21-31
            
            double zt_res_49530 = eta_p_49522 * zt_rhs_49529;
            
            // trmodel.fut:394:37-49
            
            double zt_res_49532 = 0.949999988079071 * zt_res_49530;
            
            // trmodel.fut:395:17-22
            
            double zp_res_49534 = eta_p_49523 + zt_res_49532;
            
            // trmodel.fut:396:26-56
            
            bool cond_49536 = i_50140 == zp_lhs_48712;
            
            // trmodel.fut:396:26-56
            
            double lifted_lambda_res_49537;
            
            if (cond_49536) {
                lifted_lambda_res_49537 = NAN;
            } else {
                lifted_lambda_res_49537 = zp_res_49534;
            }
            // trmodel.fut:403:23-407:44
            for (int64_t i_50132 = 0; i_50132 < zp_lhs_48712; i_50132++) {
                double eta_p_49540 = ((double *) mem_50686)[i_50132];
                int64_t index_primexp_50152 = (int64_t) 1 + i_50132;
                double eta_p_49541 = ((double *) ext_mem_50313.mem)[i_50140 * replicate_arg0_48715 + index_primexp_50152];
                
                // trmodel.fut:407:23-28
                
                double zp_res_49542 = eta_p_49540 + eta_p_49541;
                
                ((double *) mem_50697)[i_50140 * zp_lhs_48712 + i_50132] = zp_res_49542;
            }
            // trmodel.fut:411:16-23
            
            double zp_res_49545 = zt_res_47643 + eta_p_49519;
            
            ((double *) mem_50694)[i_50140] = zp_res_49545;
            ((double *) mem_50699)[i_50140] = lifted_lambda_res_49537;
        }
        // trmodel.fut:417:28-63
        for (int64_t nest_i_50948 = 0; nest_i_50948 < replicate_arg0_48713; nest_i_50948++) {
            for (int64_t nest_i_50949 = 0; nest_i_50949 < replicate_arg0_48715; nest_i_50949++) {
                ((double *) mem_50730)[nest_i_50948 * replicate_arg0_48715 + nest_i_50949] = 0.0;
            }
        }
        // trmodel.fut:419:11-24
        // trmodel.fut:419:11-24
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_50730, (int64_t) 0, (int64_t []) {replicate_arg0_48715}, (uint64_t *) mem_50699, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {replicate_arg0_48713});
        // trmodel.fut:420:11-39
        // trmodel.fut:420:11-39
        lmad_copy_8b(ctx, 2, (uint64_t *) mem_50730, (int64_t) 1, (int64_t []) {replicate_arg0_48715, (int64_t) 1}, (uint64_t *) mem_50697, (int64_t) 0, (int64_t []) {zp_lhs_48712, (int64_t) 1}, (int64_t []) {replicate_arg0_48713, zp_lhs_48712});
        // trmodel.fut:421:11-28
        // trmodel.fut:421:11-28
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_50730, utils_trade_47574, (int64_t []) {replicate_arg0_48715}, (uint64_t *) mem_50694, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {replicate_arg0_48713});
        // trmodel.fut:417:21-426:34
        if (memblock_alloc(ctx, &mem_50732, bytes_50338, "mem_50732")) {
            err = 1;
            goto cleanup;
        }
        // trmodel.fut:417:21-426:34
        for (int64_t i_50150 = 0; i_50150 < replicate_arg0_48713; i_50150++) {
            // trmodel.fut:218:5-219:26
            
            double defunc_0_f_res_49961;
            double redout_50144 = -INFINITY;
            
            for (int64_t i_50145 = 0; i_50145 < replicate_arg0_48715; i_50145++) {
                double eta_p_49561 = ((double *) mem_50730)[i_50150 * replicate_arg0_48715 + i_50145];
                
                // trmodel.fut:218:16-49
                
                bool isnan_res_49562 = futrts_isnan64(eta_p_49561);
                
                // trmodel.fut:218:16-49
                
                double lifted_lambda_res_49563;
                
                if (isnan_res_49562) {
                    lifted_lambda_res_49563 = -INFINITY;
                } else {
                    lifted_lambda_res_49563 = eta_p_49561;
                }
                // trmodel.fut:219:12-17
                
                double max_res_47662 = fmax64(lifted_lambda_res_49563, redout_50144);
                double redout_tmp_50951 = max_res_47662;
                
                redout_50144 = redout_tmp_50951;
            }
            defunc_0_f_res_49961 = redout_50144;
            // trmodel.fut:227:5-228:27
            
            double defunc_0_f_res_49962;
            double redout_50146 = 0.0;
            
            for (int64_t i_50147 = 0; i_50147 < replicate_arg0_48715; i_50147++) {
                double eta_p_49553 = ((double *) mem_50730)[i_50150 * replicate_arg0_48715 + i_50147];
                
                // trmodel.fut:233:28-36
                
                double zm_res_49554 = eta_p_49553 - defunc_0_f_res_49961;
                
                // trmodel.fut:233:55-58
                
                double exp_res_49555 = futrts_exp64(zm_res_49554);
                
                // trmodel.fut:227:16-48
                
                bool isnan_res_49557 = futrts_isnan64(exp_res_49555);
                
                // trmodel.fut:227:16-48
                
                double lifted_lambda_res_49558;
                
                if (isnan_res_49557) {
                    lifted_lambda_res_49558 = 0.0;
                } else {
                    lifted_lambda_res_49558 = exp_res_49555;
                }
                // trmodel.fut:228:12-17
                
                double zp_res_47677 = lifted_lambda_res_49558 + redout_50146;
                double redout_tmp_50952 = zp_res_47677;
                
                redout_50146 = redout_tmp_50952;
            }
            defunc_0_f_res_49962 = redout_50146;
            // trmodel.fut:234:26-29
            
            double log_res_47678 = futrts_log64(defunc_0_f_res_49962);
            
            // trmodel.fut:234:45-53
            
            double zp_res_47680 = log_res_47678 + defunc_0_f_res_49961;
            
            ((double *) mem_50732.mem)[i_50150] = zp_res_47680;
        }
        if (memblock_set(ctx, &mem_param_tmp_50941, &mem_50732, "mem_50732") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_50684, &mem_param_tmp_50941, "mem_param_tmp_50941") != 0)
            return 1;
    }
    if (memblock_set(ctx, &ext_mem_50741, &mem_param_50684, "mem_param_50684") != 0)
        return 1;
    if (memblock_unref(ctx, &ext_mem_50313, "ext_mem_50313") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50681, "mem_50681") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_50838, &ext_mem_50741, "ext_mem_50741") != 0)
        return 1;
    prim_out_50839 = replicate_arg0_48713;
    if (memblock_set(ctx, &*mem_out_p_51018, &mem_out_50838, "mem_out_50838") != 0)
        return 1;
    *out_prim_out_51019 = prim_out_50839;
    
  cleanup:
    {
        free(mem_50283);
        free(mem_50292);
        free(mem_50316);
        free(mem_50335);
        free(mem_50337);
        free(mem_50346);
        free(mem_50349);
        free(mem_50352);
        free(mem_50366);
        free(mem_50368);
        free(mem_50370);
        free(mem_50469);
        free(mem_50472);
        free(mem_50475);
        free(mem_50489);
        free(mem_50491);
        free(mem_50506);
        free(mem_50509);
        free(mem_50512);
        free(mem_50648);
        free(mem_50656);
        free(mem_50657);
        free(mem_50671);
        free(mem_50673);
        free(mem_50675);
        free(mem_50677);
        free(mem_50679);
        free(mem_50686);
        free(mem_50694);
        free(mem_50697);
        free(mem_50699);
        free(mem_50730);
        if (memblock_unref(ctx, &mem_param_tmp_50941, "mem_param_tmp_50941") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50732, "mem_50732") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_50684, "mem_param_50684") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50741, "ext_mem_50741") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50681, "mem_50681") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50313, "ext_mem_50313") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50311, "mem_50311") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50281, "mem_50281") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50279, "mem_50279") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50277, "mem_50277") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50276, "mem_50276") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50275, "mem_50275") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50274, "mem_50274") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50271, "mem_50271") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50268, "mem_50268") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50265, "mem_50265") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50263, "mem_50263") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50261, "mem_50261") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50259, "mem_50259") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_50869, "mem_param_tmp_50869") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_50868, "mem_param_tmp_50868") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_50867, "mem_param_tmp_50867") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50628, "mem_50628") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50624, "mem_50624") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50620, "mem_50620") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50571, "mem_50571") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50567, "mem_50567") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50563, "mem_50563") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50578, "mem_50578") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50576, "mem_50576") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50574, "mem_50574") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50599, "ext_mem_50599") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50602, "ext_mem_50602") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50605, "ext_mem_50605") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_50466, "mem_param_50466") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_50463, "mem_param_50463") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_50460, "mem_param_50460") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50636, "ext_mem_50636") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50637, "ext_mem_50637") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50638, "ext_mem_50638") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50456, "mem_50456") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50452, "mem_50452") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50448, "mem_50448") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50641, "ext_mem_50641") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50644, "ext_mem_50644") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50647, "ext_mem_50647") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50343, "mem_50343") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50341, "mem_50341") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50339, "mem_50339") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_50838, "mem_out_50838") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_test_carprice_buy(struct futhark_context *ctx, struct memblock *mem_out_p_51052, int64_t *out_prim_out_51053, struct memblock newprices_mem_50257, int64_t c_29010, int64_t n_29011, int64_t Ax_29013)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_50259_cached_sizze_51054 = 0;
    unsigned char *mem_50259 = NULL;
    int64_t mem_50268_cached_sizze_51055 = 0;
    unsigned char *mem_50268 = NULL;
    int64_t mem_50287_cached_sizze_51056 = 0;
    unsigned char *mem_50287 = NULL;
    struct memblock mem_50299;
    
    mem_50299.references = NULL;
    
    struct memblock mem_out_50838;
    
    mem_out_50838.references = NULL;
    
    int64_t prim_out_50839;
    int64_t dzlz7bUZLztZRz20Ucz20UAxz7dUzg_39985 = mul64(c_29010, Ax_29013);
    int64_t dzlz7bUZLzpZRz20UZLZLzpZRz20U1z20UZLZLztZRz20Ucz20UAxZRZRz20U1z7dUzg_39986 = add64((int64_t) 2, dzlz7bUZLztZRz20Ucz20UAxz7dUzg_39985);
    
    // trmodel.fut:180:61-65
    
    int64_t dzlz7bUZLzmZRz20UAxz20U1z7dUzg_39987 = sub64(Ax_29013, (int64_t) 1);
    
    // trmodel.fut:180:28-68
    
    int64_t bytes_50258 = (int64_t) 8 * dzlz7bUZLzmZRz20UAxz20U1z7dUzg_39987;
    
    // trmodel.fut:180:75-181:53
    
    int64_t binop_x_50266 = (int64_t) 8 * c_29010;
    
    // trmodel.fut:180:75-181:53
    
    int64_t bytes_50267 = Ax_29013 * binop_x_50266;
    
    // trmodel_test.fut:89:6-36
    
    int64_t bytes_50298 = (int64_t) 8 * dzlz7bUZLzpZRz20UZLZLzpZRz20U1z20UZLZLztZRz20Ucz20UAxZRZRz20U1z7dUzg_39986;
    
    // trmodel.fut:180:28-68
    if (mem_50259_cached_sizze_51054 < bytes_50258) {
        err = lexical_realloc(ctx, &mem_50259, &mem_50259_cached_sizze_51054, bytes_50258);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:180:28-68
    
    double discard_49983;
    double scanacc_49979 = 1.0;
    
    for (int64_t i_49981 = 0; i_49981 < dzlz7bUZLzmZRz20UAxz20U1z7dUzg_39987; i_49981++) {
        // trmodel.fut:180:33-38
        
        double zt_res_39993 = 0.85 * scanacc_49979;
        
        ((double *) mem_50259)[i_49981] = zt_res_39993;
        
        double scanacc_tmp_50840 = zt_res_39993;
        
        scanacc_49979 = scanacc_tmp_50840;
    }
    discard_49983 = scanacc_49979;
    // trmodel.fut:180:75-181:53
    if (mem_50268_cached_sizze_51055 < bytes_50267) {
        err = lexical_realloc(ctx, &mem_50268, &mem_50268_cached_sizze_51055, bytes_50267);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:180:75-181:53
    for (int64_t i_49990 = 0; i_49990 < c_29010; i_49990++) {
        double eta_p_39997 = ((double *) newprices_mem_50257.mem)[i_49990];
        
        // trmodel.fut:181:30-44
        for (int64_t i_49986 = 0; i_49986 < Ax_29013; i_49986++) {
            bool index_concat_cmp_50188 = sle64((int64_t) 1, i_49986);
            double index_concat_branch_50192;
            
            if (index_concat_cmp_50188) {
                int64_t index_concat_i_50189 = sub64(i_49986, (int64_t) 1);
                double index_concat_50190 = ((double *) mem_50259)[index_concat_i_50189];
                
                index_concat_branch_50192 = index_concat_50190;
            } else {
                index_concat_branch_50192 = 1.0;
            }
            // trmodel.fut:181:34-41
            
            double zt_res_40000 = eta_p_39997 * index_concat_branch_50192;
            
            ((double *) mem_50268)[i_49990 * Ax_29013 + i_49986] = zt_res_40000;
        }
    }
    // trmodel_test.fut:87:12-61
    if (mem_50287_cached_sizze_51056 < bytes_50267) {
        err = lexical_realloc(ctx, &mem_50287, &mem_50287_cached_sizze_51056, bytes_50267);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel_test.fut:87:12-61
    for (int64_t i_49994 = 0; i_49994 < c_29010; i_49994++) {
        // trmodel_test.fut:87:12-61
        for (int64_t nest_i_50845 = 0; nest_i_50845 < Ax_29013; nest_i_50845++) {
            ((int64_t *) mem_50287)[i_49994 * Ax_29013 + nest_i_50845] = i_49994;
        }
    }
    // trmodel_test.fut:89:6-36
    if (memblock_alloc(ctx, &mem_50299, bytes_50298, "mem_50299")) {
        err = 1;
        goto cleanup;
    }
    
    int64_t index_concat_add_50174 = add64((int64_t) 1, dzlz7bUZLztZRz20Ucz20UAxz7dUzg_39985);
    
    // trmodel_test.fut:89:6-36
    for (int64_t i_49998 = 0; i_49998 < dzlz7bUZLzpZRz20UZLZLzpZRz20U1z20UZLZLztZRz20Ucz20UAxZRZRz20U1z7dUzg_39986; i_49998++) {
        bool index_concat_cmp_50176 = sle64(index_concat_add_50174, i_49998);
        int8_t index_concat_branch_50184;
        
        if (index_concat_cmp_50176) {
            index_concat_branch_50184 = (int8_t) 1;
        } else {
            bool index_concat_cmp_50179 = sle64((int64_t) 1, i_49998);
            int8_t index_concat_branch_50183;
            
            if (index_concat_cmp_50179) {
                index_concat_branch_50183 = (int8_t) 2;
            } else {
                index_concat_branch_50183 = (int8_t) 0;
            }
            index_concat_branch_50184 = index_concat_branch_50183;
        }
        
        int64_t index_concat_branch_50173;
        
        if (index_concat_cmp_50176) {
            index_concat_branch_50173 = (int64_t) 0;
        } else {
            bool index_concat_cmp_50168 = sle64((int64_t) 1, i_49998);
            int64_t index_concat_branch_50172;
            
            if (index_concat_cmp_50168) {
                int64_t index_concat_i_50169 = sub64(i_49998, (int64_t) 1);
                int64_t binop_x_50198 = squot64(index_concat_i_50169, Ax_29013);
                int64_t binop_y_50199 = Ax_29013 * binop_x_50198;
                int64_t new_index_50200 = index_concat_i_50169 - binop_y_50199;
                
                index_concat_branch_50172 = new_index_50200;
            } else {
                index_concat_branch_50172 = (int64_t) 0;
            }
            index_concat_branch_50173 = index_concat_branch_50172;
        }
        
        int64_t index_concat_branch_50162;
        
        if (index_concat_cmp_50176) {
            index_concat_branch_50162 = (int64_t) 0;
        } else {
            bool index_concat_cmp_50157 = sle64((int64_t) 1, i_49998);
            int64_t index_concat_branch_50161;
            
            if (index_concat_cmp_50157) {
                int64_t index_concat_i_50158 = sub64(i_49998, (int64_t) 1);
                int64_t new_index_50193 = squot64(index_concat_i_50158, Ax_29013);
                int64_t binop_y_50195 = Ax_29013 * new_index_50193;
                int64_t new_index_50196 = index_concat_i_50158 - binop_y_50195;
                int64_t index_concat_50159 = ((int64_t *) mem_50287)[new_index_50193 * Ax_29013 + new_index_50196];
                
                index_concat_branch_50161 = index_concat_50159;
            } else {
                index_concat_branch_50161 = (int64_t) 0;
            }
            index_concat_branch_50162 = index_concat_branch_50161;
        }
        // trmodel.fut:196:5-201:24
        
        double carprice_buy_res_40027;
        
        if (index_concat_branch_50184 == (int8_t) 0) {
            carprice_buy_res_40027 = NAN;
        } else if (index_concat_branch_50184 == (int8_t) 1) {
            carprice_buy_res_40027 = 0.0;
        } else {
            // trmodel.fut:200:15-35
            
            bool cond_40028 = sle64((int64_t) 0, index_concat_branch_50173);
            
            // trmodel.fut:200:31-35
            
            bool tmp_t_res_40029 = slt64(index_concat_branch_50173, Ax_29013);
            
            // trmodel_test.fut:89:11-27
            
            bool x_40030 = cond_40028 && tmp_t_res_40029;
            
            // trmodel.fut:200:7-201:24
            
            bool assert_c_40031;
            
            if (!x_40030) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "Assertion is false: (age >= 0 && age < Ax)", "-> #0  trmodel.fut:200:7-201:24\n   #1  trmodel_test.fut:89:11-27\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // trmodel.fut:200:7-201:24
            
            bool x_40032 = sle64((int64_t) 0, index_concat_branch_50162);
            
            // trmodel.fut:200:7-201:24
            
            bool y_40033 = slt64(index_concat_branch_50162, c_29010);
            
            // trmodel.fut:200:7-201:24
            
            bool bounds_check_40034 = x_40032 && y_40033;
            
            // trmodel.fut:200:7-201:24
            
            bool index_ok_40035 = x_40030 && bounds_check_40034;
            
            // trmodel.fut:200:7-201:24
            
            bool index_certs_40036;
            
            if (!index_ok_40035) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) index_concat_branch_50173, ", ", (long long) index_concat_branch_50162, "] out of bounds for array of shape [", (long long) Ax_29013, "][", (long long) c_29010, "].", "-> #0  trmodel.fut:200:7-201:24\n   #1  trmodel_test.fut:89:11-27\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            double case_res_40037 = ((double *) mem_50268)[index_concat_branch_50162 * Ax_29013 + index_concat_branch_50173];
            
            carprice_buy_res_40027 = case_res_40037;
        }
        ((double *) mem_50299.mem)[i_49998] = carprice_buy_res_40027;
    }
    if (memblock_set(ctx, &mem_out_50838, &mem_50299, "mem_50299") != 0)
        return 1;
    prim_out_50839 = dzlz7bUZLzpZRz20UZLZLzpZRz20U1z20UZLZLztZRz20Ucz20UAxZRZRz20U1z7dUzg_39986;
    if (memblock_set(ctx, &*mem_out_p_51052, &mem_out_50838, "mem_out_50838") != 0)
        return 1;
    *out_prim_out_51053 = prim_out_50839;
    
  cleanup:
    {
        free(mem_50259);
        free(mem_50268);
        free(mem_50287);
        if (memblock_unref(ctx, &mem_50299, "mem_50299") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_50838, "mem_out_50838") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_test_carprice_sell(struct futhark_context *ctx, struct memblock *mem_out_p_51057, int64_t *out_prim_out_51058, struct memblock newprices_mem_50257, int64_t c_27423, int64_t n_27424, int64_t Ax_27426)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_50259_cached_sizze_51059 = 0;
    unsigned char *mem_50259 = NULL;
    int64_t mem_50268_cached_sizze_51060 = 0;
    unsigned char *mem_50268 = NULL;
    int64_t mem_50286_cached_sizze_51061 = 0;
    unsigned char *mem_50286 = NULL;
    int64_t mem_50295_cached_sizze_51062 = 0;
    unsigned char *mem_50295 = NULL;
    struct memblock mem_50307;
    
    mem_50307.references = NULL;
    
    struct memblock mem_out_50838;
    
    mem_out_50838.references = NULL;
    
    int64_t prim_out_50839;
    int64_t dzlz7bUZLztZRz20Ucz20UAxz7dUzg_39985 = mul64(c_27423, Ax_27426);
    int64_t dzlz7bUZLzpZRz20UZLZLztZRz20Ucz20UAxZRz20U1z7dUzg_39986 = add64((int64_t) 1, dzlz7bUZLztZRz20Ucz20UAxz7dUzg_39985);
    
    // trmodel.fut:180:61-65
    
    int64_t dzlz7bUZLzmZRz20UAxz20U1z7dUzg_40006 = sub64(Ax_27426, (int64_t) 1);
    
    // trmodel.fut:180:28-68
    
    int64_t bytes_50258 = (int64_t) 8 * dzlz7bUZLzmZRz20UAxz20U1z7dUzg_40006;
    
    // trmodel.fut:180:75-181:53
    
    int64_t binop_x_50266 = (int64_t) 8 * c_27423;
    
    // trmodel.fut:180:75-181:53
    
    int64_t bytes_50267 = Ax_27426 * binop_x_50266;
    
    // trmodel_test.fut:60:12-61
    
    int64_t bytes_50285 = (int64_t) 8 * Ax_27426;
    
    // trmodel_test.fut:62:6-37
    
    int64_t bytes_50306 = (int64_t) 8 * dzlz7bUZLzpZRz20UZLZLztZRz20Ucz20UAxZRz20U1z7dUzg_39986;
    
    // trmodel.fut:180:28-68
    if (mem_50259_cached_sizze_51059 < bytes_50258) {
        err = lexical_realloc(ctx, &mem_50259, &mem_50259_cached_sizze_51059, bytes_50258);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:180:28-68
    
    double discard_49983;
    double scanacc_49979 = 1.0;
    
    for (int64_t i_49981 = 0; i_49981 < dzlz7bUZLzmZRz20UAxz20U1z7dUzg_40006; i_49981++) {
        // trmodel.fut:180:33-38
        
        double zt_res_40012 = 0.85 * scanacc_49979;
        
        ((double *) mem_50259)[i_49981] = zt_res_40012;
        
        double scanacc_tmp_50840 = zt_res_40012;
        
        scanacc_49979 = scanacc_tmp_50840;
    }
    discard_49983 = scanacc_49979;
    // trmodel.fut:180:75-181:53
    if (mem_50268_cached_sizze_51060 < bytes_50267) {
        err = lexical_realloc(ctx, &mem_50268, &mem_50268_cached_sizze_51060, bytes_50267);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:180:75-181:53
    for (int64_t i_49990 = 0; i_49990 < c_27423; i_49990++) {
        double eta_p_40016 = ((double *) newprices_mem_50257.mem)[i_49990];
        
        // trmodel.fut:181:30-44
        for (int64_t i_49986 = 0; i_49986 < Ax_27426; i_49986++) {
            bool index_concat_cmp_50175 = sle64((int64_t) 1, i_49986);
            double index_concat_branch_50179;
            
            if (index_concat_cmp_50175) {
                int64_t index_concat_i_50176 = sub64(i_49986, (int64_t) 1);
                double index_concat_50177 = ((double *) mem_50259)[index_concat_i_50176];
                
                index_concat_branch_50179 = index_concat_50177;
            } else {
                index_concat_branch_50179 = 1.0;
            }
            // trmodel.fut:181:34-41
            
            double zt_res_40019 = eta_p_40016 * index_concat_branch_50179;
            
            ((double *) mem_50268)[i_49990 * Ax_27426 + i_49986] = zt_res_40019;
        }
    }
    // trmodel_test.fut:60:12-61
    if (mem_50286_cached_sizze_51061 < bytes_50285) {
        err = lexical_realloc(ctx, &mem_50286, &mem_50286_cached_sizze_51061, bytes_50285);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel_test.fut:60:12-61
    for (int64_t i_49994 = 0; i_49994 < Ax_27426; i_49994++) {
        // trmodel_test.fut:60:58-60
        
        int64_t tmp_40030 = add64((int64_t) 1, i_49994);
        
        ((int64_t *) mem_50286)[i_49994] = tmp_40030;
    }
    // trmodel_test.fut:60:12-61
    if (mem_50295_cached_sizze_51062 < bytes_50267) {
        err = lexical_realloc(ctx, &mem_50295, &mem_50295_cached_sizze_51062, bytes_50267);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel_test.fut:60:12-61
    for (int64_t i_49998 = 0; i_49998 < c_27423; i_49998++) {
        // trmodel_test.fut:60:12-61
        for (int64_t nest_i_50846 = 0; nest_i_50846 < Ax_27426; nest_i_50846++) {
            ((int64_t *) mem_50295)[i_49998 * Ax_27426 + nest_i_50846] = i_49998;
        }
    }
    // trmodel_test.fut:62:6-37
    if (memblock_alloc(ctx, &mem_50307, bytes_50306, "mem_50307")) {
        err = 1;
        goto cleanup;
    }
    // trmodel_test.fut:62:6-37
    for (int64_t i_50002 = 0; i_50002 < dzlz7bUZLzpZRz20UZLZLztZRz20Ucz20UAxZRz20U1z7dUzg_39986; i_50002++) {
        bool index_concat_cmp_50165 = sle64(dzlz7bUZLztZRz20Ucz20UAxz7dUzg_39985, i_50002);
        int8_t index_concat_branch_50169 = btoi_bool_i8(index_concat_cmp_50165);
        int64_t index_concat_branch_50163;
        
        if (index_concat_cmp_50165) {
            index_concat_branch_50163 = (int64_t) 0;
        } else {
            int64_t binop_x_50185 = squot64(i_50002, Ax_27426);
            int64_t binop_y_50186 = Ax_27426 * binop_x_50185;
            int64_t new_index_50187 = i_50002 - binop_y_50186;
            int64_t index_concat_50162 = ((int64_t *) mem_50286)[new_index_50187];
            
            index_concat_branch_50163 = index_concat_50162;
        }
        
        int64_t index_concat_branch_50157;
        
        if (index_concat_cmp_50165) {
            index_concat_branch_50157 = (int64_t) 0;
        } else {
            int64_t new_index_50180 = squot64(i_50002, Ax_27426);
            int64_t binop_y_50182 = Ax_27426 * new_index_50180;
            int64_t new_index_50183 = i_50002 - binop_y_50182;
            int64_t index_concat_50156 = ((int64_t *) mem_50295)[new_index_50180 * Ax_27426 + new_index_50183];
            
            index_concat_branch_50157 = index_concat_50156;
        }
        // trmodel.fut:188:5-193:28
        
        double carprice_sell_res_40048;
        
        if (index_concat_branch_50169 == (int8_t) 1) {
            carprice_sell_res_40048 = 0.0;
        } else {
            // trmodel.fut:191:15-36
            
            bool cond_40049 = sle64((int64_t) 0, index_concat_branch_50163);
            
            // trmodel.fut:191:31-36
            
            bool tmp_t_res_40050 = sle64(index_concat_branch_50163, Ax_27426);
            
            // trmodel_test.fut:62:11-28
            
            bool x_40051 = cond_40049 && tmp_t_res_40050;
            
            // trmodel.fut:191:7-193:28
            
            bool assert_c_40052;
            
            if (!x_40051) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "Assertion is false: (age >= 0 && age <= Ax)", "-> #0  trmodel.fut:191:7-193:28\n   #1  trmodel_test.fut:62:11-28\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // trmodel.fut:191:7-193:28
            
            bool cond_40053 = index_concat_branch_50163 == Ax_27426;
            
            // trmodel.fut:191:7-193:28
            
            double case_res_40054;
            
            if (cond_40053) {
                // trmodel.fut:192:26-44
                
                bool x_48738 = sle64((int64_t) 0, index_concat_branch_50157);
                
                // trmodel.fut:192:26-44
                
                bool y_48739 = slt64(index_concat_branch_50157, c_27423);
                
                // trmodel.fut:192:26-44
                
                bool bounds_check_48740 = x_48738 && y_48739;
                
                // trmodel.fut:192:26-44
                
                bool index_certs_48741;
                
                if (!bounds_check_48740) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) index_concat_branch_50157, "] out of bounds for array of shape [", (long long) c_27423, "].", "-> #0  trmodel.fut:192:26-44\n   #1  trmodel_test.fut:62:11-28\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                case_res_40054 = 1.0;
            } else {
                // trmodel.fut:193:13-27
                
                bool y_40060 = slt64(index_concat_branch_50163, Ax_27426);
                
                // trmodel.fut:193:13-27
                
                bool bounds_check_40061 = cond_40049 && y_40060;
                
                // trmodel.fut:193:13-27
                
                bool x_40062 = sle64((int64_t) 0, index_concat_branch_50157);
                
                // trmodel.fut:193:13-27
                
                bool y_40063 = slt64(index_concat_branch_50157, c_27423);
                
                // trmodel.fut:193:13-27
                
                bool bounds_check_40064 = x_40062 && y_40063;
                
                // trmodel.fut:193:13-27
                
                bool index_ok_40065 = bounds_check_40061 && bounds_check_40064;
                
                // trmodel.fut:193:13-27
                
                bool index_certs_40066;
                
                if (!index_ok_40065) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) index_concat_branch_50163, ", ", (long long) index_concat_branch_50157, "] out of bounds for array of shape [", (long long) Ax_27426, "][", (long long) c_27423, "].", "-> #0  trmodel.fut:193:13-27\n   #1  trmodel_test.fut:62:11-28\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                double case_res_f_res_40067 = ((double *) mem_50268)[index_concat_branch_50157 * Ax_27426 + index_concat_branch_50163];
                
                case_res_40054 = case_res_f_res_40067;
            }
            carprice_sell_res_40048 = case_res_40054;
        }
        ((double *) mem_50307.mem)[i_50002] = carprice_sell_res_40048;
    }
    if (memblock_set(ctx, &mem_out_50838, &mem_50307, "mem_50307") != 0)
        return 1;
    prim_out_50839 = dzlz7bUZLzpZRz20UZLZLztZRz20Ucz20UAxZRz20U1z7dUzg_39986;
    if (memblock_set(ctx, &*mem_out_p_51057, &mem_out_50838, "mem_out_50838") != 0)
        return 1;
    *out_prim_out_51058 = prim_out_50839;
    
  cleanup:
    {
        free(mem_50259);
        free(mem_50268);
        free(mem_50286);
        free(mem_50295);
        if (memblock_unref(ctx, &mem_50307, "mem_50307") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_50838, "mem_out_50838") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_test_ev_scrap(struct futhark_context *ctx, struct memblock *mem_out_p_51063, int64_t *out_prim_out_51064, struct memblock newprices_mem_50257, int64_t c_28302, int64_t n_28303, int64_t Ax_28305)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_50259_cached_sizze_51065 = 0;
    unsigned char *mem_50259 = NULL;
    int64_t mem_50268_cached_sizze_51066 = 0;
    unsigned char *mem_50268 = NULL;
    int64_t mem_50286_cached_sizze_51067 = 0;
    unsigned char *mem_50286 = NULL;
    int64_t mem_50295_cached_sizze_51068 = 0;
    unsigned char *mem_50295 = NULL;
    struct memblock mem_50307;
    
    mem_50307.references = NULL;
    
    struct memblock mem_out_50838;
    
    mem_out_50838.references = NULL;
    
    int64_t prim_out_50839;
    int64_t dzlz7bUZLztZRz20Ucz20UAxz7dUzg_40398 = mul64(c_28302, Ax_28305);
    int64_t dzlz7bUZLzpZRz20UZLZLztZRz20Ucz20UAxZRz20U1z7dUzg_40399 = add64((int64_t) 1, dzlz7bUZLztZRz20Ucz20UAxz7dUzg_40398);
    
    // trmodel.fut:180:61-65
    
    int64_t dzlz7bUZLzmZRz20UAxz20U1z7dUzg_40419 = sub64(Ax_28305, (int64_t) 1);
    
    // trmodel.fut:180:28-68
    
    int64_t bytes_50258 = (int64_t) 8 * dzlz7bUZLzmZRz20UAxz20U1z7dUzg_40419;
    
    // trmodel.fut:180:75-181:53
    
    int64_t binop_x_50266 = (int64_t) 8 * c_28302;
    
    // trmodel.fut:180:75-181:53
    
    int64_t bytes_50267 = Ax_28305 * binop_x_50266;
    
    // trmodel_test.fut:74:12-62
    
    int64_t bytes_50285 = (int64_t) 8 * Ax_28305;
    
    // trmodel_test.fut:76:6-36
    
    int64_t bytes_50306 = (int64_t) 8 * dzlz7bUZLzpZRz20UZLZLztZRz20Ucz20UAxZRz20U1z7dUzg_40399;
    
    // trmodel.fut:180:28-68
    if (mem_50259_cached_sizze_51065 < bytes_50258) {
        err = lexical_realloc(ctx, &mem_50259, &mem_50259_cached_sizze_51065, bytes_50258);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:180:28-68
    
    double discard_49983;
    double scanacc_49979 = 1.0;
    
    for (int64_t i_49981 = 0; i_49981 < dzlz7bUZLzmZRz20UAxz20U1z7dUzg_40419; i_49981++) {
        // trmodel.fut:180:33-38
        
        double zt_res_40425 = 0.85 * scanacc_49979;
        
        ((double *) mem_50259)[i_49981] = zt_res_40425;
        
        double scanacc_tmp_50840 = zt_res_40425;
        
        scanacc_49979 = scanacc_tmp_50840;
    }
    discard_49983 = scanacc_49979;
    // trmodel.fut:180:75-181:53
    if (mem_50268_cached_sizze_51066 < bytes_50267) {
        err = lexical_realloc(ctx, &mem_50268, &mem_50268_cached_sizze_51066, bytes_50267);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:180:75-181:53
    for (int64_t i_49990 = 0; i_49990 < c_28302; i_49990++) {
        double eta_p_40429 = ((double *) newprices_mem_50257.mem)[i_49990];
        
        // trmodel.fut:181:30-44
        for (int64_t i_49986 = 0; i_49986 < Ax_28305; i_49986++) {
            bool index_concat_cmp_50175 = sle64((int64_t) 1, i_49986);
            double index_concat_branch_50179;
            
            if (index_concat_cmp_50175) {
                int64_t index_concat_i_50176 = sub64(i_49986, (int64_t) 1);
                double index_concat_50177 = ((double *) mem_50259)[index_concat_i_50176];
                
                index_concat_branch_50179 = index_concat_50177;
            } else {
                index_concat_branch_50179 = 1.0;
            }
            // trmodel.fut:181:34-41
            
            double zt_res_40432 = eta_p_40429 * index_concat_branch_50179;
            
            ((double *) mem_50268)[i_49990 * Ax_28305 + i_49986] = zt_res_40432;
        }
    }
    // trmodel_test.fut:74:12-62
    if (mem_50286_cached_sizze_51067 < bytes_50285) {
        err = lexical_realloc(ctx, &mem_50286, &mem_50286_cached_sizze_51067, bytes_50285);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel_test.fut:74:12-62
    for (int64_t i_49994 = 0; i_49994 < Ax_28305; i_49994++) {
        // trmodel_test.fut:74:59-61
        
        int64_t tmp_40444 = add64((int64_t) 1, i_49994);
        
        ((int64_t *) mem_50286)[i_49994] = tmp_40444;
    }
    // trmodel_test.fut:74:12-62
    if (mem_50295_cached_sizze_51068 < bytes_50267) {
        err = lexical_realloc(ctx, &mem_50295, &mem_50295_cached_sizze_51068, bytes_50267);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel_test.fut:74:12-62
    for (int64_t i_49998 = 0; i_49998 < c_28302; i_49998++) {
        // trmodel_test.fut:74:12-62
        for (int64_t nest_i_50846 = 0; nest_i_50846 < Ax_28305; nest_i_50846++) {
            ((int64_t *) mem_50295)[i_49998 * Ax_28305 + nest_i_50846] = i_49998;
        }
    }
    // trmodel_test.fut:76:6-36
    if (memblock_alloc(ctx, &mem_50307, bytes_50306, "mem_50307")) {
        err = 1;
        goto cleanup;
    }
    // trmodel_test.fut:76:6-36
    for (int64_t i_50002 = 0; i_50002 < dzlz7bUZLzpZRz20UZLZLztZRz20Ucz20UAxZRz20U1z7dUzg_40399; i_50002++) {
        bool index_concat_cmp_50165 = sle64(dzlz7bUZLztZRz20Ucz20UAxz7dUzg_40398, i_50002);
        int8_t index_concat_branch_50169 = btoi_bool_i8(index_concat_cmp_50165);
        int64_t index_concat_branch_50163;
        
        if (index_concat_cmp_50165) {
            index_concat_branch_50163 = (int64_t) 0;
        } else {
            int64_t binop_x_50185 = squot64(i_50002, Ax_28305);
            int64_t binop_y_50186 = Ax_28305 * binop_x_50185;
            int64_t new_index_50187 = i_50002 - binop_y_50186;
            int64_t index_concat_50162 = ((int64_t *) mem_50286)[new_index_50187];
            
            index_concat_branch_50163 = index_concat_50162;
        }
        
        int64_t index_concat_branch_50157;
        
        if (index_concat_cmp_50165) {
            index_concat_branch_50157 = (int64_t) 0;
        } else {
            int64_t new_index_50180 = squot64(i_50002, Ax_28305);
            int64_t binop_y_50182 = Ax_28305 * new_index_50180;
            int64_t new_index_50183 = i_50002 - binop_y_50182;
            int64_t index_concat_50156 = ((int64_t *) mem_50295)[new_index_50180 * Ax_28305 + new_index_50183];
            
            index_concat_branch_50157 = index_concat_50156;
        }
        // trmodel.fut:255:8-258:50
        
        double ev_scrap_res_40462;
        
        if (index_concat_branch_50169 == (int8_t) 1) {
            // trmodel.fut:254:33-44
            
            bool y_48766 = slt64((int64_t) 1, n_28303);
            
            // trmodel.fut:254:33-44
            
            bool index_certs_48767;
            
            if (!y_48766) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 1, "] out of bounds for array of shape [", (long long) n_28303, "].", "-> #0  trmodel.fut:254:33-44\n   #1  trmodel.fut:256:30-32\n   #2  trmodel_test.fut:76:11-23\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // trmodel.fut:250:9-252:56
            
            double pscrap_48742;
            
            if (index_concat_branch_50169 == (int8_t) 1) {
                pscrap_48742 = NAN;
            } else {
                // trmodel.fut:252:38-56
                
                bool x_48743 = sle64((int64_t) 0, index_concat_branch_50157);
                
                // trmodel.fut:252:38-56
                
                bool y_48744 = slt64(index_concat_branch_50157, c_28302);
                
                // trmodel.fut:252:38-56
                
                bool bounds_check_48745 = x_48743 && y_48744;
                
                // trmodel.fut:252:38-56
                
                bool index_certs_48746;
                
                if (!bounds_check_48745) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) index_concat_branch_50157, "] out of bounds for array of shape [", (long long) c_28302, "].", "-> #0  trmodel.fut:252:38-56\n   #1  trmodel.fut:256:30-32\n   #2  trmodel_test.fut:76:11-23\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                pscrap_48742 = 1.0;
            }
            // trmodel.fut:188:5-193:28
            
            double carprice_sell_res_48747;
            
            if (index_concat_branch_50169 == (int8_t) 1) {
                carprice_sell_res_48747 = 0.0;
            } else {
                // trmodel.fut:191:15-36
                
                bool cond_48748 = sle64((int64_t) 0, index_concat_branch_50163);
                
                // trmodel.fut:191:31-36
                
                bool tmp_t_res_48749 = sle64(index_concat_branch_50163, Ax_28305);
                
                // trmodel.fut:245:36-253:39
                
                bool x_48750 = cond_48748 && tmp_t_res_48749;
                
                // trmodel.fut:191:7-193:28
                
                bool assert_c_48751;
                
                if (!x_48750) {
                    set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "Assertion is false: (age >= 0 && age <= Ax)", "-> #0  trmodel.fut:191:7-193:28\n   #1  trmodel.fut:245:36-253:39\n   #2  trmodel.fut:256:30-32\n   #3  trmodel_test.fut:76:11-23\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                // trmodel.fut:191:7-193:28
                
                bool cond_48752 = index_concat_branch_50163 == Ax_28305;
                
                // trmodel.fut:191:7-193:28
                
                double case_res_48753;
                
                if (cond_48752) {
                    // trmodel.fut:192:26-44
                    
                    bool x_48754 = sle64((int64_t) 0, index_concat_branch_50157);
                    
                    // trmodel.fut:192:26-44
                    
                    bool y_48755 = slt64(index_concat_branch_50157, c_28302);
                    
                    // trmodel.fut:192:26-44
                    
                    bool bounds_check_48756 = x_48754 && y_48755;
                    
                    // trmodel.fut:192:26-44
                    
                    bool index_certs_48757;
                    
                    if (!bounds_check_48756) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) index_concat_branch_50157, "] out of bounds for array of shape [", (long long) c_28302, "].", "-> #0  trmodel.fut:192:26-44\n   #1  trmodel.fut:245:36-253:39\n   #2  trmodel.fut:256:30-32\n   #3  trmodel_test.fut:76:11-23\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    case_res_48753 = 1.0;
                } else {
                    // trmodel.fut:193:13-27
                    
                    bool y_48758 = slt64(index_concat_branch_50163, Ax_28305);
                    
                    // trmodel.fut:193:13-27
                    
                    bool bounds_check_48759 = cond_48748 && y_48758;
                    
                    // trmodel.fut:193:13-27
                    
                    bool x_48760 = sle64((int64_t) 0, index_concat_branch_50157);
                    
                    // trmodel.fut:193:13-27
                    
                    bool y_48761 = slt64(index_concat_branch_50157, c_28302);
                    
                    // trmodel.fut:193:13-27
                    
                    bool bounds_check_48762 = x_48760 && y_48761;
                    
                    // trmodel.fut:193:13-27
                    
                    bool index_ok_48763 = bounds_check_48759 && bounds_check_48762;
                    
                    // trmodel.fut:193:13-27
                    
                    bool index_certs_48764;
                    
                    if (!index_ok_48763) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) index_concat_branch_50163, ", ", (long long) index_concat_branch_50157, "] out of bounds for array of shape [", (long long) Ax_28305, "][", (long long) c_28302, "].", "-> #0  trmodel.fut:193:13-27\n   #1  trmodel.fut:245:36-253:39\n   #2  trmodel.fut:256:30-32\n   #3  trmodel_test.fut:76:11-23\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    double case_res_f_res_48765 = ((double *) mem_50268)[index_concat_branch_50157 * Ax_28305 + index_concat_branch_50163];
                    
                    case_res_48753 = case_res_f_res_48765;
                }
                carprice_sell_res_48747 = case_res_48753;
            }
            // trmodel.fut:254:48-60
            
            double zm_res_48768 = pscrap_48742 - carprice_sell_res_48747;
            
            // trmodel.fut:254:33-60
            
            double zt_res_48769 = 0.10000000149011612 * zm_res_48768;
            
            // trmodel.fut:213:8-215:34
            
            bool isnan_res_48770 = futrts_isnan64(zt_res_48769);
            
            // trmodel.fut:213:8-215:34
            
            double nanmax2_res_48771;
            
            if (isnan_res_48770) {
                nanmax2_res_48771 = 0.0;
            } else {
                // trmodel.fut:215:27-34
                
                double max_res_48772 = fmax64(0.0, zt_res_48769);
                
                nanmax2_res_48771 = max_res_48772;
            }
            // trmodel.fut:239:26-34
            
            double zm_res_48773 = 0.0 - nanmax2_res_48771;
            
            // trmodel.fut:239:38-46
            
            double zs_res_48774 = zm_res_48773 / 0.5;
            
            // trmodel.fut:239:50-53
            
            double exp_res_48775 = futrts_exp64(zs_res_48774);
            
            // trmodel.fut:239:26-34
            
            double zm_res_48776 = zt_res_48769 - nanmax2_res_48771;
            
            // trmodel.fut:239:38-46
            
            double zs_res_48777 = zm_res_48776 / 0.5;
            
            // trmodel.fut:239:50-53
            
            double exp_res_48778 = futrts_exp64(zs_res_48777);
            
            // trmodel.fut:222:8-224:30
            
            bool isnan_res_48779 = futrts_isnan64(exp_res_48778);
            
            // trmodel.fut:222:8-224:30
            
            double nansum2_res_48780;
            
            if (isnan_res_48779) {
                nansum2_res_48780 = exp_res_48775;
            } else {
                // trmodel.fut:223:20-224:30
                
                bool isnan_res_48781 = futrts_isnan64(exp_res_48775);
                
                // trmodel.fut:223:20-224:30
                
                double nansum2_res_f_res_48782;
                
                if (isnan_res_48781) {
                    nansum2_res_f_res_48782 = exp_res_48778;
                } else {
                    // trmodel.fut:224:27-30
                    
                    double zp_res_48783 = exp_res_48775 + exp_res_48778;
                    
                    nansum2_res_f_res_48782 = zp_res_48783;
                }
                nansum2_res_48780 = nansum2_res_f_res_48782;
            }
            // trmodel.fut:240:42-45
            
            double log_res_48784 = futrts_log64(nansum2_res_48780);
            
            // trmodel.fut:240:49-57
            
            double zt_res_48785 = 0.5 * log_res_48784;
            
            // trmodel.fut:240:61-69
            
            double zp_res_48786 = nanmax2_res_48771 + zt_res_48785;
            
            ev_scrap_res_40462 = zp_res_48786;
        } else {
            // trmodel.fut:257:36-258:50
            
            bool cond_40515 = index_concat_branch_50163 == Ax_28305;
            
            // trmodel.fut:257:36-258:50
            
            double case_res_40516;
            
            if (cond_40515) {
                case_res_40516 = 0.0;
            } else {
                // trmodel.fut:254:33-44
                
                bool y_40543 = slt64((int64_t) 1, n_28303);
                
                // trmodel.fut:254:33-44
                
                bool index_certs_40545;
                
                if (!y_40543) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 1, "] out of bounds for array of shape [", (long long) n_28303, "].", "-> #0  trmodel.fut:254:33-44\n   #1  trmodel.fut:258:48-50\n   #2  trmodel_test.fut:76:11-23\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                // trmodel.fut:250:9-252:56
                
                double pscrap_40517;
                
                if (index_concat_branch_50169 == (int8_t) 1) {
                    pscrap_40517 = NAN;
                } else {
                    // trmodel.fut:252:38-56
                    
                    bool x_40518 = sle64((int64_t) 0, index_concat_branch_50157);
                    
                    // trmodel.fut:252:38-56
                    
                    bool y_40519 = slt64(index_concat_branch_50157, c_28302);
                    
                    // trmodel.fut:252:38-56
                    
                    bool bounds_check_40520 = x_40518 && y_40519;
                    
                    // trmodel.fut:252:38-56
                    
                    bool index_certs_40521;
                    
                    if (!bounds_check_40520) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) index_concat_branch_50157, "] out of bounds for array of shape [", (long long) c_28302, "].", "-> #0  trmodel.fut:252:38-56\n   #1  trmodel.fut:258:48-50\n   #2  trmodel_test.fut:76:11-23\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    pscrap_40517 = 1.0;
                }
                // trmodel.fut:188:5-193:28
                
                double carprice_sell_res_40523;
                
                if (index_concat_branch_50169 == (int8_t) 1) {
                    carprice_sell_res_40523 = 0.0;
                } else {
                    // trmodel.fut:191:15-36
                    
                    bool cond_40524 = sle64((int64_t) 0, index_concat_branch_50163);
                    
                    // trmodel.fut:191:31-36
                    
                    bool tmp_t_res_40525 = sle64(index_concat_branch_50163, Ax_28305);
                    
                    // trmodel.fut:245:36-253:39
                    
                    bool x_40526 = cond_40524 && tmp_t_res_40525;
                    
                    // trmodel.fut:191:7-193:28
                    
                    bool assert_c_40527;
                    
                    if (!x_40526) {
                        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "Assertion is false: (age >= 0 && age <= Ax)", "-> #0  trmodel.fut:191:7-193:28\n   #1  trmodel.fut:245:36-253:39\n   #2  trmodel.fut:258:48-50\n   #3  trmodel_test.fut:76:11-23\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    // trmodel.fut:191:7-193:28
                    
                    double case_res_40528;
                    
                    if (cond_40515) {
                        // trmodel.fut:192:26-44
                        
                        bool x_48787 = sle64((int64_t) 0, index_concat_branch_50157);
                        
                        // trmodel.fut:192:26-44
                        
                        bool y_48788 = slt64(index_concat_branch_50157, c_28302);
                        
                        // trmodel.fut:192:26-44
                        
                        bool bounds_check_48789 = x_48787 && y_48788;
                        
                        // trmodel.fut:192:26-44
                        
                        bool index_certs_48790;
                        
                        if (!bounds_check_48789) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) index_concat_branch_50157, "] out of bounds for array of shape [", (long long) c_28302, "].", "-> #0  trmodel.fut:192:26-44\n   #1  trmodel.fut:245:36-253:39\n   #2  trmodel.fut:258:48-50\n   #3  trmodel_test.fut:76:11-23\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        case_res_40528 = 1.0;
                    } else {
                        // trmodel.fut:193:13-27
                        
                        bool y_40534 = slt64(index_concat_branch_50163, Ax_28305);
                        
                        // trmodel.fut:193:13-27
                        
                        bool bounds_check_40535 = cond_40524 && y_40534;
                        
                        // trmodel.fut:193:13-27
                        
                        bool x_40536 = sle64((int64_t) 0, index_concat_branch_50157);
                        
                        // trmodel.fut:193:13-27
                        
                        bool y_40537 = slt64(index_concat_branch_50157, c_28302);
                        
                        // trmodel.fut:193:13-27
                        
                        bool bounds_check_40538 = x_40536 && y_40537;
                        
                        // trmodel.fut:193:13-27
                        
                        bool index_ok_40539 = bounds_check_40535 && bounds_check_40538;
                        
                        // trmodel.fut:193:13-27
                        
                        bool index_certs_40540;
                        
                        if (!index_ok_40539) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) index_concat_branch_50163, ", ", (long long) index_concat_branch_50157, "] out of bounds for array of shape [", (long long) Ax_28305, "][", (long long) c_28302, "].", "-> #0  trmodel.fut:193:13-27\n   #1  trmodel.fut:245:36-253:39\n   #2  trmodel.fut:258:48-50\n   #3  trmodel_test.fut:76:11-23\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        double case_res_f_res_40541 = ((double *) mem_50268)[index_concat_branch_50157 * Ax_28305 + index_concat_branch_50163];
                        
                        case_res_40528 = case_res_f_res_40541;
                    }
                    carprice_sell_res_40523 = case_res_40528;
                }
                // trmodel.fut:254:48-60
                
                double zm_res_40547 = pscrap_40517 - carprice_sell_res_40523;
                
                // trmodel.fut:254:33-60
                
                double zt_res_40548 = 0.10000000149011612 * zm_res_40547;
                
                // trmodel.fut:213:8-215:34
                
                bool isnan_res_40549 = futrts_isnan64(zt_res_40548);
                
                // trmodel.fut:213:8-215:34
                
                double nanmax2_res_40550;
                
                if (isnan_res_40549) {
                    nanmax2_res_40550 = 0.0;
                } else {
                    // trmodel.fut:215:27-34
                    
                    double max_res_40551 = fmax64(0.0, zt_res_40548);
                    
                    nanmax2_res_40550 = max_res_40551;
                }
                // trmodel.fut:239:26-34
                
                double zm_res_40554 = 0.0 - nanmax2_res_40550;
                
                // trmodel.fut:239:38-46
                
                double zs_res_40555 = zm_res_40554 / 0.5;
                
                // trmodel.fut:239:50-53
                
                double exp_res_40556 = futrts_exp64(zs_res_40555);
                
                // trmodel.fut:239:26-34
                
                double zm_res_40557 = zt_res_40548 - nanmax2_res_40550;
                
                // trmodel.fut:239:38-46
                
                double zs_res_40558 = zm_res_40557 / 0.5;
                
                // trmodel.fut:239:50-53
                
                double exp_res_40559 = futrts_exp64(zs_res_40558);
                
                // trmodel.fut:222:8-224:30
                
                bool isnan_res_40560 = futrts_isnan64(exp_res_40559);
                
                // trmodel.fut:222:8-224:30
                
                double nansum2_res_40561;
                
                if (isnan_res_40560) {
                    nansum2_res_40561 = exp_res_40556;
                } else {
                    // trmodel.fut:223:20-224:30
                    
                    bool isnan_res_40562 = futrts_isnan64(exp_res_40556);
                    
                    // trmodel.fut:223:20-224:30
                    
                    double nansum2_res_f_res_40563;
                    
                    if (isnan_res_40562) {
                        nansum2_res_f_res_40563 = exp_res_40559;
                    } else {
                        // trmodel.fut:224:27-30
                        
                        double zp_res_40564 = exp_res_40556 + exp_res_40559;
                        
                        nansum2_res_f_res_40563 = zp_res_40564;
                    }
                    nansum2_res_40561 = nansum2_res_f_res_40563;
                }
                // trmodel.fut:240:42-45
                
                double log_res_40565 = futrts_log64(nansum2_res_40561);
                
                // trmodel.fut:240:49-57
                
                double zt_res_40566 = 0.5 * log_res_40565;
                
                // trmodel.fut:240:61-69
                
                double zp_res_40567 = nanmax2_res_40550 + zt_res_40566;
                
                case_res_40516 = zp_res_40567;
            }
            ev_scrap_res_40462 = case_res_40516;
        }
        ((double *) mem_50307.mem)[i_50002] = ev_scrap_res_40462;
    }
    if (memblock_set(ctx, &mem_out_50838, &mem_50307, "mem_50307") != 0)
        return 1;
    prim_out_50839 = dzlz7bUZLzpZRz20UZLZLztZRz20Ucz20UAxZRz20U1z7dUzg_40399;
    if (memblock_set(ctx, &*mem_out_p_51063, &mem_out_50838, "mem_out_50838") != 0)
        return 1;
    *out_prim_out_51064 = prim_out_50839;
    
  cleanup:
    {
        free(mem_50259);
        free(mem_50268);
        free(mem_50286);
        free(mem_50295);
        if (memblock_unref(ctx, &mem_50307, "mem_50307") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_50838, "mem_out_50838") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_test_notrade(struct futhark_context *ctx, struct memblock *mem_out_p_51069, int64_t *out_prim_out_51070, int64_t n_26596, int64_t c_26597, int64_t Ax_26598)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_50259_cached_sizze_51071 = 0;
    unsigned char *mem_50259 = NULL;
    int64_t mem_50278_cached_sizze_51072 = 0;
    unsigned char *mem_50278 = NULL;
    int64_t mem_50280_cached_sizze_51073 = 0;
    unsigned char *mem_50280 = NULL;
    int64_t mem_50289_cached_sizze_51074 = 0;
    unsigned char *mem_50289 = NULL;
    int64_t mem_50292_cached_sizze_51075 = 0;
    unsigned char *mem_50292 = NULL;
    int64_t mem_50295_cached_sizze_51076 = 0;
    unsigned char *mem_50295 = NULL;
    int64_t mem_50309_cached_sizze_51077 = 0;
    unsigned char *mem_50309 = NULL;
    int64_t mem_50311_cached_sizze_51078 = 0;
    unsigned char *mem_50311 = NULL;
    int64_t mem_50313_cached_sizze_51079 = 0;
    unsigned char *mem_50313 = NULL;
    int64_t mem_50412_cached_sizze_51080 = 0;
    unsigned char *mem_50412 = NULL;
    int64_t mem_50415_cached_sizze_51081 = 0;
    unsigned char *mem_50415 = NULL;
    int64_t mem_50418_cached_sizze_51082 = 0;
    unsigned char *mem_50418 = NULL;
    int64_t mem_50432_cached_sizze_51083 = 0;
    unsigned char *mem_50432 = NULL;
    int64_t mem_50434_cached_sizze_51084 = 0;
    unsigned char *mem_50434 = NULL;
    int64_t mem_50449_cached_sizze_51085 = 0;
    unsigned char *mem_50449 = NULL;
    int64_t mem_50452_cached_sizze_51086 = 0;
    unsigned char *mem_50452 = NULL;
    int64_t mem_50455_cached_sizze_51087 = 0;
    unsigned char *mem_50455 = NULL;
    int64_t mem_50591_cached_sizze_51088 = 0;
    unsigned char *mem_50591 = NULL;
    int64_t mem_50599_cached_sizze_51089 = 0;
    unsigned char *mem_50599 = NULL;
    int64_t mem_50600_cached_sizze_51090 = 0;
    unsigned char *mem_50600 = NULL;
    int64_t mem_50614_cached_sizze_51091 = 0;
    unsigned char *mem_50614 = NULL;
    int64_t mem_50616_cached_sizze_51092 = 0;
    unsigned char *mem_50616 = NULL;
    int64_t mem_50618_cached_sizze_51093 = 0;
    unsigned char *mem_50618 = NULL;
    int64_t mem_50620_cached_sizze_51094 = 0;
    unsigned char *mem_50620 = NULL;
    int64_t mem_50622_cached_sizze_51095 = 0;
    unsigned char *mem_50622 = NULL;
    struct memblock mem_50625;
    
    mem_50625.references = NULL;
    
    struct memblock mem_param_tmp_50869;
    
    mem_param_tmp_50869.references = NULL;
    
    struct memblock mem_param_tmp_50868;
    
    mem_param_tmp_50868.references = NULL;
    
    struct memblock mem_param_tmp_50867;
    
    mem_param_tmp_50867.references = NULL;
    
    struct memblock mem_50571;
    
    mem_50571.references = NULL;
    
    struct memblock mem_50567;
    
    mem_50567.references = NULL;
    
    struct memblock mem_50563;
    
    mem_50563.references = NULL;
    
    struct memblock mem_50514;
    
    mem_50514.references = NULL;
    
    struct memblock mem_50510;
    
    mem_50510.references = NULL;
    
    struct memblock mem_50506;
    
    mem_50506.references = NULL;
    
    struct memblock mem_50521;
    
    mem_50521.references = NULL;
    
    struct memblock mem_50519;
    
    mem_50519.references = NULL;
    
    struct memblock mem_50517;
    
    mem_50517.references = NULL;
    
    struct memblock ext_mem_50542;
    
    ext_mem_50542.references = NULL;
    
    struct memblock ext_mem_50545;
    
    ext_mem_50545.references = NULL;
    
    struct memblock ext_mem_50548;
    
    ext_mem_50548.references = NULL;
    
    struct memblock mem_param_50409;
    
    mem_param_50409.references = NULL;
    
    struct memblock mem_param_50406;
    
    mem_param_50406.references = NULL;
    
    struct memblock mem_param_50403;
    
    mem_param_50403.references = NULL;
    
    struct memblock ext_mem_50579;
    
    ext_mem_50579.references = NULL;
    
    struct memblock ext_mem_50580;
    
    ext_mem_50580.references = NULL;
    
    struct memblock ext_mem_50581;
    
    ext_mem_50581.references = NULL;
    
    struct memblock mem_50399;
    
    mem_50399.references = NULL;
    
    struct memblock mem_50395;
    
    mem_50395.references = NULL;
    
    struct memblock mem_50391;
    
    mem_50391.references = NULL;
    
    struct memblock ext_mem_50584;
    
    ext_mem_50584.references = NULL;
    
    struct memblock ext_mem_50587;
    
    ext_mem_50587.references = NULL;
    
    struct memblock ext_mem_50590;
    
    ext_mem_50590.references = NULL;
    
    struct memblock mem_50286;
    
    mem_50286.references = NULL;
    
    struct memblock mem_50284;
    
    mem_50284.references = NULL;
    
    struct memblock mem_50282;
    
    mem_50282.references = NULL;
    
    struct memblock mem_out_50838;
    
    mem_out_50838.references = NULL;
    
    int64_t prim_out_50839;
    
    // trmodel.fut:133:36-39
    
    int64_t zp_lhs_48712 = mul64(c_26597, Ax_26598);
    
    // trmodel.fut:133:39-41
    
    int64_t replicate_arg0_48713 = add64((int64_t) 1, zp_lhs_48712);
    
    // trmodel.fut:368:38-40
    
    int64_t zeze_rhs_46742 = sub64(Ax_26598, (int64_t) 1);
    
    // trmodel.fut:367:8-370:41
    
    int64_t binop_x_50257 = (int64_t) 8 * c_26597;
    
    // trmodel.fut:367:8-370:41
    
    int64_t bytes_50258 = Ax_26598 * binop_x_50257;
    
    // trmodel.fut:367:8-370:41
    if (mem_50259_cached_sizze_51071 < bytes_50258) {
        err = lexical_realloc(ctx, &mem_50259, &mem_50259_cached_sizze_51071, bytes_50258);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:367:8-370:41
    for (int64_t i_49984 = 0; i_49984 < c_26597; i_49984++) {
        // trmodel.fut:367:8-370:41
        for (int64_t i_49980 = 0; i_49980 < Ax_26598; i_49980++) {
            // trmodel.fut:368:28-370:41
            
            bool cond_46747 = i_49980 == zeze_rhs_46742;
            
            // trmodel.fut:368:28-370:41
            
            int64_t lifted_lambda_res_46748;
            
            if (cond_46747) {
                // trmodel.fut:369:34-37
                
                int64_t lifted_lambda_res_t_res_49548 = mul64(Ax_26598, i_49984);
                
                lifted_lambda_res_46748 = lifted_lambda_res_t_res_49548;
            } else {
                // trmodel.fut:370:34-37
                
                int64_t zp_lhs_46750 = mul64(Ax_26598, i_49984);
                
                // trmodel.fut:370:37-39
                
                int64_t zp_lhs_46751 = add64(zp_lhs_46750, i_49980);
                
                // trmodel.fut:370:39-41
                
                int64_t lifted_lambda_res_f_res_46752 = add64((int64_t) 1, zp_lhs_46751);
                
                lifted_lambda_res_46748 = lifted_lambda_res_f_res_46752;
            }
            ((int64_t *) mem_50259)[i_49984 * Ax_26598 + i_49980] = lifted_lambda_res_46748;
        }
    }
    // trmodel_test.fut:33:16-34:24
    if (mem_50278_cached_sizze_51072 < bytes_50258) {
        err = lexical_realloc(ctx, &mem_50278, &mem_50278_cached_sizze_51072, bytes_50258);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel_test.fut:33:16-34:24
    // trmodel_test.fut:33:16-34:24
    lmad_copy_8b(ctx, 2, (uint64_t *) mem_50278, (int64_t) 0, (int64_t []) {Ax_26598, (int64_t) 1}, (uint64_t *) mem_50259, (int64_t) 0, (int64_t []) {Ax_26598, (int64_t) 1}, (int64_t []) {c_26597, Ax_26598});
    // trmodel_test.fut:33:16-34:24
    if (mem_50280_cached_sizze_51073 < (int64_t) 8) {
        err = lexical_realloc(ctx, &mem_50280, &mem_50280_cached_sizze_51073, (int64_t) 8);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel_test.fut:33:16-34:24
    for (int64_t nest_i_50842 = 0; nest_i_50842 < (int64_t) 1; nest_i_50842++) {
        ((int64_t *) mem_50280)[nest_i_50842] = zp_lhs_48712;
    }
    // trmodel_test.fut:33:16-34:24
    
    int64_t bytes_50281 = (int64_t) 8 * replicate_arg0_48713;
    
    // trmodel_test.fut:33:16-34:24
    if (memblock_alloc(ctx, &mem_50282, bytes_50281, "mem_50282")) {
        err = 1;
        goto cleanup;
    }
    // trmodel_test.fut:33:16-34:24
    
    int64_t tmp_offs_50843 = (int64_t) 0;
    
    // trmodel_test.fut:33:16-34:24
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_50282.mem, tmp_offs_50843, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_50278, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {zp_lhs_48712});
    tmp_offs_50843 += zp_lhs_48712;
    // trmodel_test.fut:33:16-34:24
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_50282.mem, tmp_offs_50843, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_50280, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {(int64_t) 1});
    tmp_offs_50843 += (int64_t) 1;
    // trmodel.fut:375:36-84
    if (memblock_alloc(ctx, &mem_50284, bytes_50281, "mem_50284")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:375:36-84
    for (int64_t i_50844 = 0; i_50844 < replicate_arg0_48713; i_50844++) {
        int64_t x_50845 = (int64_t) 0 + i_50844 * (int64_t) 1;
        
        ((int64_t *) mem_50284.mem)[i_50844] = x_50845;
    }
    // trmodel.fut:375:36-84
    if (memblock_alloc(ctx, &mem_50286, bytes_50281, "mem_50286")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:375:36-84
    for (int64_t nest_i_50846 = 0; nest_i_50846 < replicate_arg0_48713; nest_i_50846++) {
        ((double *) mem_50286.mem)[nest_i_50846] = 1.0;
    }
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:226:3-265:14
    
    bool cond_46761 = sle64(replicate_arg0_48713, (int64_t) 1);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:231:34-50
    
    int64_t zp_rhs_46762 = sdiv_safe64(zp_lhs_48712, (int64_t) 20);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:231:26-50
    
    int64_t min_num_blocks_46763 = add64((int64_t) 1, zp_rhs_46762);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:184:3-39
    
    bool loop_cond_46764 = slt64((int64_t) 1, min_num_blocks_46763);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:184:3-39
    
    bool smallest_pow_2_geq_than_res_46765;
    int64_t smallest_pow_2_geq_than_res_46766;
    bool loop_while_46767;
    int64_t x_46768;
    
    loop_while_46767 = loop_cond_46764;
    x_46768 = (int64_t) 1;
    while (loop_while_46767) {
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:184:37-39
        
        int64_t loopres_46769 = mul64((int64_t) 2, x_46768);
        
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:184:29-32
        
        bool loop_cond_46770 = slt64(loopres_46769, min_num_blocks_46763);
        bool loop_while_tmp_50847 = loop_cond_46770;
        int64_t x_tmp_50848 = loopres_46769;
        
        loop_while_46767 = loop_while_tmp_50847;
        x_46768 = x_tmp_50848;
    }
    smallest_pow_2_geq_than_res_46765 = loop_while_46767;
    smallest_pow_2_geq_than_res_46766 = x_46768;
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:234:30-42
    
    bool zzero_46771 = smallest_pow_2_geq_than_res_46766 == (int64_t) 0;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:234:30-42
    
    bool nonzzero_46772 = !zzero_46771;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75
    
    bool protect_assert_disj_46773 = cond_46761 || nonzzero_46772;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:234:30-42
    
    bool nonzzero_cert_46774;
    
    if (!protect_assert_disj_46773) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:234:30-42\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:375:19-85\n   #6  trmodel_test.fut:33:16-34:24\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:234:30-42
    
    int64_t zp_rhs_46775 = sdiv_safe64(zp_lhs_48712, smallest_pow_2_geq_than_res_46766);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:234:22-42
    
    int64_t block_sizze_46776 = add64((int64_t) 1, zp_rhs_46775);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
    
    int64_t flat_dim_46777 = smallest_pow_2_geq_than_res_46766 * block_sizze_46776;
    bool x_46778 = !cond_46761;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:238:54-65
    
    int64_t greatest_divisor_leq_than_arg1_46779 = mul64((int64_t) 2, block_sizze_46776);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:11-71
    
    bool cond_46780 = slt64((int64_t) 8, greatest_divisor_leq_than_arg1_46779);
    int64_t d_46781;
    
    if (x_46778) {
        bool x_49550;
        int64_t x_49551;
        bool loop_while_49552;
        int64_t d_49553;
        
        loop_while_49552 = cond_46780;
        d_49553 = (int64_t) 1;
        while (loop_while_49552) {
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:69-71
            
            int64_t loopres_49554 = add64((int64_t) 1, d_49553);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:36-38
            
            bool zzero_49555 = loopres_49554 == (int64_t) 0;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:36-38
            
            bool nonzzero_49556 = !zzero_49555;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:36-38
            
            bool nonzzero_cert_49557;
            
            if (!nonzzero_49556) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:36-38\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:238:5-65\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:33:16-34:24\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:36-38
            
            int64_t zg_lhs_49558 = sdiv64(greatest_divisor_leq_than_arg1_46779, loopres_49554);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:35-64
            
            bool cond_49559 = slt64((int64_t) 8, zg_lhs_49558);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:35-64
            
            bool loop_cond_49560;
            
            if (cond_49559) {
                loop_cond_49560 = 1;
            } else {
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:57-59
                
                int64_t znze_lhs_49561 = smod64(greatest_divisor_leq_than_arg1_46779, loopres_49554);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:60-64
                
                bool loop_cond_f_res_49562 = znze_lhs_49561 == (int64_t) 0;
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:190:60-64
                
                bool loop_cond_f_res_49563 = !loop_cond_f_res_49562;
                
                loop_cond_49560 = loop_cond_f_res_49563;
            }
            
            bool loop_while_tmp_50849 = loop_cond_49560;
            int64_t d_tmp_50850 = loopres_49554;
            
            loop_while_49552 = loop_while_tmp_50849;
            d_49553 = d_tmp_50850;
        }
        x_49550 = loop_while_49552;
        x_49551 = d_49553;
        d_46781 = x_49551;
    } else {
        d_46781 = (int64_t) 0;
    }
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:191:7-9
    
    bool zzero_46796 = d_46781 == (int64_t) 0;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:191:7-9
    
    bool nonzzero_46797 = !zzero_46796;
    bool protect_assert_disj_46798 = cond_46761 || nonzzero_46797;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:191:7-9
    
    bool nonzzero_cert_46799;
    
    if (!protect_assert_disj_46798) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:191:7-9\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:238:5-65\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:33:16-34:24\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:191:7-9
    
    int64_t greatest_divisor_leq_than_res_46800 = sdiv_safe64(greatest_divisor_leq_than_arg1_46779, d_46781);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:60-64
    
    bool y_46801 = slt64((int64_t) 0, replicate_arg0_48713);
    bool protect_assert_disj_46802 = cond_46761 || y_46801;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:60-64
    
    bool index_certs_46803;
    
    if (!protect_assert_disj_46802) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) replicate_arg0_48713, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:60-64\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:375:19-85\n   #6  trmodel_test.fut:33:16-34:24\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool index_concat_cmp_46804 = sle64(zp_lhs_48712, (int64_t) 0);
    int64_t index_concat_branch_46805;
    
    if (x_46778) {
        bool x_49565 = !index_concat_cmp_46804;
        int64_t new_index_49566 = squot_safe64((int64_t) 0, Ax_26598);
        int64_t binop_y_49567 = Ax_26598 * new_index_49566;
        int64_t new_index_49568 = (int64_t) 0 - binop_y_49567;
        int64_t index_concat_49569;
        
        if (x_49565) {
            int64_t x_49570 = ((int64_t *) mem_50259)[new_index_49566 * Ax_26598 + new_index_49568];
            
            index_concat_49569 = x_49570;
        } else {
            index_concat_49569 = (int64_t) 0;
        }
        
        int64_t x_49571;
        
        if (index_concat_cmp_46804) {
            x_49571 = zp_lhs_48712;
        } else {
            x_49571 = index_concat_49569;
        }
        index_concat_branch_46805 = x_49571;
    } else {
        index_concat_branch_46805 = (int64_t) 0;
    }
    
    int64_t defunc_0_reduce_res_46813;
    int64_t defunc_0_reduce_res_46814;
    
    if (x_46778) {
        int64_t x_49575;
        int64_t x_49576;
        int64_t redout_49986;
        int64_t redout_49987;
        
        redout_49986 = (int64_t) 0;
        redout_49987 = index_concat_branch_46805;
        for (int64_t i_49989 = 0; i_49989 < replicate_arg0_48713; i_49989++) {
            bool index_concat_cmp_50232 = sle64(zp_lhs_48712, i_49989);
            int64_t index_concat_branch_50236;
            
            if (index_concat_cmp_50232) {
                index_concat_branch_50236 = zp_lhs_48712;
            } else {
                int64_t new_index_50243 = squot64(i_49989, Ax_26598);
                int64_t binop_y_50245 = Ax_26598 * new_index_50243;
                int64_t new_index_50246 = i_49989 - binop_y_50245;
                int64_t index_concat_50235 = ((int64_t *) mem_50259)[new_index_50243 * Ax_26598 + new_index_50246];
                
                index_concat_branch_50236 = index_concat_50235;
            }
            // ../lib/github.com/diku-dk/sparse/mono.fut:75:41-74
            
            bool cond_49587 = slt64(redout_49986, i_49989);
            
            // ../lib/github.com/diku-dk/sparse/mono.fut:75:53-73
            
            bool cond_49588 = redout_49986 == i_49989;
            
            // ../lib/github.com/diku-dk/sparse/mono.fut:75:68-73
            
            bool lifted_lambda_res_f_res_t_res_49589 = sle64(redout_49987, index_concat_branch_50236);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:34-58
            
            bool x_49590 = cond_49588 && lifted_lambda_res_f_res_t_res_49589;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:34-58
            
            bool x_49591 = !cond_49587;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:34-58
            
            bool y_49592 = x_49590 && x_49591;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:34-58
            
            bool lifted_lambda_res_49593 = cond_49587 || y_49592;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:18-66
            
            int64_t defunc_0_op_res_49594;
            
            if (lifted_lambda_res_49593) {
                defunc_0_op_res_49594 = i_49989;
            } else {
                defunc_0_op_res_49594 = redout_49986;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:240:18-66
            
            int64_t defunc_0_op_res_49595;
            
            if (lifted_lambda_res_49593) {
                defunc_0_op_res_49595 = index_concat_branch_50236;
            } else {
                defunc_0_op_res_49595 = redout_49987;
            }
            
            int64_t redout_tmp_50851 = defunc_0_op_res_49594;
            int64_t redout_tmp_50852 = defunc_0_op_res_49595;
            
            redout_49986 = redout_tmp_50851;
            redout_49987 = redout_tmp_50852;
        }
        x_49575 = redout_49986;
        x_49576 = redout_49987;
        defunc_0_reduce_res_46813 = x_49575;
        defunc_0_reduce_res_46814 = x_49576;
    } else {
        defunc_0_reduce_res_46813 = (int64_t) 0;
        defunc_0_reduce_res_46814 = (int64_t) 0;
    }
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
    
    bool bounds_invalid_upwards_46838 = slt64(smallest_pow_2_geq_than_res_46766, (int64_t) 0);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
    
    bool valid_46839 = !bounds_invalid_upwards_46838;
    bool protect_assert_disj_46840 = cond_46761 || valid_46839;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
    
    bool range_valid_c_46841;
    
    if (!protect_assert_disj_46840) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) smallest_pow_2_geq_than_res_46766, " is invalid.", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:375:19-85\n   #6  trmodel_test.fut:33:16-34:24\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:244:19-246:44
    
    bool bounds_invalid_upwards_46842 = slt64(block_sizze_46776, (int64_t) 0);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:244:19-246:44
    
    bool valid_46843 = !bounds_invalid_upwards_46842;
    bool protect_assert_disj_46844 = cond_46761 || valid_46843;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:244:19-246:44
    
    bool range_valid_c_46845;
    
    if (!protect_assert_disj_46844) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) block_sizze_46776, " is invalid.", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:244:19-246:44\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:375:19-85\n   #6  trmodel_test.fut:33:16-34:24\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:163:3-176:6
    
    bool cond_46846 = sle64(block_sizze_46776, (int64_t) 1);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:166:25-27
    
    int64_t tmp_46847 = sub64(block_sizze_46776, (int64_t) 2);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:166:3-176:6
    
    bool bounds_invalid_upwards_46848 = slt64(tmp_46847, (int64_t) 0);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:166:3-176:6
    
    int64_t distance_46849 = add64((int64_t) 1, tmp_46847);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:166:3-176:6
    
    bool valid_46850 = !bounds_invalid_upwards_46848;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
    
    bool protect_assert_disj_46851 = cond_46846 || valid_46850;
    bool protect_assert_disj_46852 = cond_46761 || protect_assert_disj_46851;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:166:3-176:6
    
    bool range_valid_c_46853;
    
    if (!protect_assert_disj_46852) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "...", (long long) tmp_46847, " is invalid.", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:166:3-176:6\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:248:7-37\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:33:16-34:24\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:251:5-262:26
    
    bool loop_cond_46854 = slt64(block_sizze_46776, flat_dim_46777);
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:147:30-42
    
    bool zzero_46855 = greatest_divisor_leq_than_res_46800 == (int64_t) 0;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:147:30-42
    
    bool nonzzero_46856 = !zzero_46855;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:265:3-14
    
    bool empty_slice_46857 = replicate_arg0_48713 == (int64_t) 0;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
    
    int64_t binop_x_50287 = (int64_t) 8 * smallest_pow_2_geq_than_res_46766;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
    
    int64_t bytes_50288 = block_sizze_46776 * binop_x_50287;
    
    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:244:19-246:44
    
    int64_t bytes_50308 = (int64_t) 8 * block_sizze_46776;
    
    if (cond_46761) {
        if (memblock_set(ctx, &ext_mem_50590, &mem_50284, "mem_50284") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_50587, &mem_50282, "mem_50282") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_50584, &mem_50286, "mem_50286") != 0)
            return 1;
    } else {
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
        if (mem_50289_cached_sizze_51074 < bytes_50288) {
            err = lexical_realloc(ctx, &mem_50289, &mem_50289_cached_sizze_51074, bytes_50288);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
        if (mem_50292_cached_sizze_51075 < bytes_50288) {
            err = lexical_realloc(ctx, &mem_50292, &mem_50292_cached_sizze_51075, bytes_50288);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
        if (mem_50295_cached_sizze_51076 < bytes_50288) {
            err = lexical_realloc(ctx, &mem_50295, &mem_50295_cached_sizze_51076, bytes_50288);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:244:19-246:44
        if (mem_50309_cached_sizze_51077 < bytes_50308) {
            err = lexical_realloc(ctx, &mem_50309, &mem_50309_cached_sizze_51077, bytes_50308);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:244:19-246:44
        if (mem_50311_cached_sizze_51078 < bytes_50308) {
            err = lexical_realloc(ctx, &mem_50311, &mem_50311_cached_sizze_51078, bytes_50308);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:244:19-246:44
        if (mem_50313_cached_sizze_51079 < bytes_50308) {
            err = lexical_realloc(ctx, &mem_50313, &mem_50313_cached_sizze_51079, bytes_50308);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:14-248:37
        for (int64_t i_50006 = 0; i_50006 < smallest_pow_2_geq_than_res_46766; i_50006++) {
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:245:18-29
            
            int64_t zp_lhs_46868 = mul64(block_sizze_46776, i_50006);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:244:19-246:44
            for (int64_t i_49996 = 0; i_49996 < block_sizze_46776; i_49996++) {
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:245:30-33
                
                int64_t k_46873 = add64(zp_lhs_46868, i_49996);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:246:12-44
                
                bool cond_46874 = slt64(k_46873, replicate_arg0_48713);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:246:12-44
                
                int64_t lifted_lambda_res_46875;
                int64_t lifted_lambda_res_46876;
                double lifted_lambda_res_46877;
                
                if (cond_46874) {
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:246:26-30
                    
                    bool x_49603 = sle64((int64_t) 0, k_46873);
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:246:26-30
                    
                    bool bounds_check_49604 = cond_46874 && x_49603;
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:246:26-30
                    
                    bool index_certs_49605;
                    
                    if (!bounds_check_49604) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) k_46873, "] out of bounds for array of shape [", (long long) replicate_arg0_48713, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:246:26-30\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:375:19-85\n   #6  trmodel_test.fut:33:16-34:24\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    bool index_concat_cmp_49606 = sle64(zp_lhs_48712, k_46873);
                    int64_t index_concat_branch_49607;
                    
                    if (index_concat_cmp_49606) {
                        index_concat_branch_49607 = zp_lhs_48712;
                    } else {
                        int64_t new_index_49608 = squot64(k_46873, Ax_26598);
                        int64_t binop_y_49609 = Ax_26598 * new_index_49608;
                        int64_t new_index_49610 = k_46873 - binop_y_49609;
                        int64_t index_concat_49611 = ((int64_t *) mem_50259)[new_index_49608 * Ax_26598 + new_index_49610];
                        
                        index_concat_branch_49607 = index_concat_49611;
                    }
                    lifted_lambda_res_46875 = k_46873;
                    lifted_lambda_res_46876 = index_concat_branch_49607;
                    lifted_lambda_res_46877 = 1.0;
                } else {
                    lifted_lambda_res_46875 = defunc_0_reduce_res_46813;
                    lifted_lambda_res_46876 = defunc_0_reduce_res_46814;
                    lifted_lambda_res_46877 = 1.0;
                }
                ((int64_t *) mem_50309)[i_49996] = lifted_lambda_res_46875;
                ((int64_t *) mem_50311)[i_49996] = lifted_lambda_res_46876;
                ((double *) mem_50313)[i_49996] = lifted_lambda_res_46877;
            }
            if (!cond_46846) {
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:166:3-176:6
                for (int64_t i_46893 = 0; i_46893 < distance_46849; i_46893++) {
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:34-36
                    
                    int64_t gt_arg1_46897 = add64((int64_t) 1, i_46893);
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37
                    
                    bool x_46898 = sle64((int64_t) 0, gt_arg1_46897);
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37
                    
                    bool y_46899 = slt64(gt_arg1_46897, block_sizze_46776);
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37
                    
                    bool bounds_check_46900 = x_46898 && y_46899;
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37
                    
                    bool index_certs_46901;
                    
                    if (!bounds_check_46900) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) gt_arg1_46897, "] out of bounds for array of shape [", (long long) block_sizze_46776, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:248:7-37\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:33:16-34:24\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30
                    
                    bool y_46904 = slt64(i_46893, block_sizze_46776);
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30
                    
                    bool index_certs_46905;
                    
                    if (!y_46904) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_46893, "] out of bounds for array of shape [", (long long) block_sizze_46776, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:248:7-37\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:33:16-34:24\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37
                    
                    int64_t gt_arg1_46902 = ((int64_t *) mem_50309)[gt_arg1_46897];
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37
                    
                    int64_t gt_arg1_46903 = ((int64_t *) mem_50311)[gt_arg1_46897];
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30
                    
                    int64_t gt_arg0_46906 = ((int64_t *) mem_50309)[i_46893];
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30
                    
                    int64_t gt_arg0_46907 = ((int64_t *) mem_50311)[i_46893];
                    
                    // ../lib/github.com/diku-dk/sparse/mono.fut:75:41-74
                    
                    bool cond_46908 = slt64(gt_arg0_46906, gt_arg1_46902);
                    
                    // ../lib/github.com/diku-dk/sparse/mono.fut:75:53-73
                    
                    bool cond_46909 = gt_arg0_46906 == gt_arg1_46902;
                    
                    // ../lib/github.com/diku-dk/sparse/mono.fut:75:68-73
                    
                    bool lifted_lambda_res_f_res_t_res_46910 = sle64(gt_arg0_46907, gt_arg1_46903);
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:18-25
                    
                    bool x_46911 = cond_46909 && lifted_lambda_res_f_res_t_res_46910;
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:18-25
                    
                    bool x_46912 = !cond_46908;
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:18-25
                    
                    bool y_46913 = x_46911 && x_46912;
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:18-25
                    
                    bool lifted_lambda_res_46914 = cond_46908 || y_46913;
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:16-26
                    
                    bool defunc_0_lifted_gt_res_46915 = !lifted_lambda_res_46914;
                    
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:168:7-174:17
                    
                    bool s_46916;
                    int64_t s_46920;
                    bool loop_while_46921;
                    int64_t j_46925;
                    
                    loop_while_46921 = defunc_0_lifted_gt_res_46915;
                    j_46925 = i_46893;
                    while (loop_while_46921) {
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28
                        
                        bool x_46926 = sle64((int64_t) 0, j_46925);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28
                        
                        bool y_46927 = slt64(j_46925, block_sizze_46776);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28
                        
                        bool bounds_check_46928 = x_46926 && y_46927;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28
                        
                        bool index_certs_46929;
                        
                        if (!bounds_check_46928) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_46925, "] out of bounds for array of shape [", (long long) block_sizze_46776, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:248:7-37\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:33:16-34:24\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:38-40
                        
                        int64_t copy_arg0_46933 = add64((int64_t) 1, j_46925);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41
                        
                        bool x_46934 = sle64((int64_t) 0, copy_arg0_46933);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41
                        
                        bool y_46935 = slt64(copy_arg0_46933, block_sizze_46776);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41
                        
                        bool bounds_check_46936 = x_46934 && y_46935;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41
                        
                        bool index_certs_46937;
                        
                        if (!bounds_check_46936) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) copy_arg0_46933, "] out of bounds for array of shape [", (long long) block_sizze_46776, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:248:7-37\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:33:16-34:24\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28
                        
                        int64_t copy_arg0_46930 = ((int64_t *) mem_50309)[j_46925];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28
                        
                        int64_t copy_arg0_46931 = ((int64_t *) mem_50311)[j_46925];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:170:24-28
                        
                        double copy_arg0_46932 = ((double *) mem_50313)[j_46925];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41
                        
                        int64_t copy_arg0_46938 = ((int64_t *) mem_50309)[copy_arg0_46933];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41
                        
                        int64_t copy_arg0_46939 = ((int64_t *) mem_50311)[copy_arg0_46933];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:35-41
                        
                        double copy_arg0_46940 = ((double *) mem_50313)[copy_arg0_46933];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:17-41
                        ((int64_t *) mem_50309)[j_46925] = copy_arg0_46938;
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:17-41
                        ((int64_t *) mem_50311)[j_46925] = copy_arg0_46939;
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:171:17-41
                        ((double *) mem_50313)[j_46925] = copy_arg0_46940;
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:172:17-35
                        ((int64_t *) mem_50309)[copy_arg0_46933] = copy_arg0_46930;
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:172:17-35
                        ((int64_t *) mem_50311)[copy_arg0_46933] = copy_arg0_46931;
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:172:17-35
                        ((double *) mem_50313)[copy_arg0_46933] = copy_arg0_46932;
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:174:14-16
                        
                        int64_t tmp_46947 = sub64(j_46925, (int64_t) 1);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:13-37
                        
                        bool cond_46948 = sle64((int64_t) 0, tmp_46947);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:13-37
                        
                        bool loop_cond_46949;
                        
                        if (cond_46948) {
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30
                            
                            bool y_49614 = slt64(tmp_46947, block_sizze_46776);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30
                            
                            bool bounds_check_49615 = cond_46948 && y_49614;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30
                            
                            bool index_certs_49616;
                            
                            if (!bounds_check_49615) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_46947, "] out of bounds for array of shape [", (long long) block_sizze_46776, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:248:7-37\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:33:16-34:24\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37
                            
                            int64_t gt_arg1_49612 = ((int64_t *) mem_50309)[j_46925];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:31-37
                            
                            int64_t gt_arg1_49613 = ((int64_t *) mem_50311)[j_46925];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30
                            
                            int64_t gt_arg0_49617 = ((int64_t *) mem_50309)[tmp_46947];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:169:26-30
                            
                            int64_t gt_arg0_49618 = ((int64_t *) mem_50311)[tmp_46947];
                            
                            // ../lib/github.com/diku-dk/sparse/mono.fut:75:41-74
                            
                            bool cond_49619 = slt64(gt_arg0_49617, gt_arg1_49612);
                            
                            // ../lib/github.com/diku-dk/sparse/mono.fut:75:53-73
                            
                            bool cond_49620 = gt_arg0_49617 == gt_arg1_49612;
                            
                            // ../lib/github.com/diku-dk/sparse/mono.fut:75:68-73
                            
                            bool lifted_lambda_res_f_res_t_res_49621 = sle64(gt_arg0_49618, gt_arg1_49613);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:18-25
                            
                            bool x_49622 = cond_49620 && lifted_lambda_res_f_res_t_res_49621;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:18-25
                            
                            bool x_49623 = !cond_49619;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:18-25
                            
                            bool y_49624 = x_49622 && x_49623;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:18-25
                            
                            bool lifted_lambda_res_49625 = cond_49619 || y_49624;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:164:16-26
                            
                            bool defunc_0_lifted_gt_res_49626 = !lifted_lambda_res_49625;
                            
                            loop_cond_46949 = defunc_0_lifted_gt_res_49626;
                        } else {
                            loop_cond_46949 = 0;
                        }
                        
                        bool loop_while_tmp_50862 = loop_cond_46949;
                        int64_t j_tmp_50866 = tmp_46947;
                        
                        loop_while_46921 = loop_while_tmp_50862;
                        j_46925 = j_tmp_50866;
                    }
                    s_46916 = loop_while_46921;
                    s_46920 = j_46925;
                }
            }
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_50289, i_50006 * block_sizze_46776, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_50313, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {block_sizze_46776});
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_50292, i_50006 * block_sizze_46776, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_50311, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {block_sizze_46776});
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_50295, i_50006 * block_sizze_46776, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_50309, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {block_sizze_46776});
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
        if (memblock_alloc(ctx, &mem_50391, bytes_50288, "mem_50391")) {
            err = 1;
            goto cleanup;
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
        lmad_copy_8b(ctx, 2, (uint64_t *) mem_50391.mem, (int64_t) 0, (int64_t []) {block_sizze_46776, (int64_t) 1}, (uint64_t *) mem_50295, (int64_t) 0, (int64_t []) {block_sizze_46776, (int64_t) 1}, (int64_t []) {smallest_pow_2_geq_than_res_46766, block_sizze_46776});
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
        if (memblock_alloc(ctx, &mem_50395, bytes_50288, "mem_50395")) {
            err = 1;
            goto cleanup;
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
        lmad_copy_8b(ctx, 2, (uint64_t *) mem_50395.mem, (int64_t) 0, (int64_t []) {block_sizze_46776, (int64_t) 1}, (uint64_t *) mem_50292, (int64_t) 0, (int64_t []) {block_sizze_46776, (int64_t) 1}, (int64_t []) {smallest_pow_2_geq_than_res_46766, block_sizze_46776});
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
        if (memblock_alloc(ctx, &mem_50399, bytes_50288, "mem_50399")) {
            err = 1;
            goto cleanup;
        }
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:243:5-248:38
        lmad_copy_8b(ctx, 2, (uint64_t *) mem_50399.mem, (int64_t) 0, (int64_t []) {block_sizze_46776, (int64_t) 1}, (uint64_t *) mem_50289, (int64_t) 0, (int64_t []) {block_sizze_46776, (int64_t) 1}, (int64_t []) {smallest_pow_2_geq_than_res_46766, block_sizze_46776});
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:251:5-262:26
        
        int64_t data_46968;
        bool data_46969;
        int64_t data_46973;
        int64_t loop_dz2084Uz2082U_46974;
        bool loop_while_46975;
        int64_t stride_46979;
        
        if (memblock_set(ctx, &mem_param_50403, &mem_50391, "mem_50391") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_50406, &mem_50395, "mem_50395") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_50409, &mem_50399, "mem_50399") != 0)
            return 1;
        loop_dz2084Uz2082U_46974 = flat_dim_46777;
        loop_while_46975 = loop_cond_46854;
        stride_46979 = block_sizze_46776;
        while (loop_while_46975) {
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:253:27-35
            
            int64_t next_stride_46980 = mul64((int64_t) 2, stride_46979);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:254:33-46
            
            bool zzero_46981 = next_stride_46980 == (int64_t) 0;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:254:33-46
            
            bool nonzzero_46982 = !zzero_46981;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:254:33-46
            
            bool nonzzero_cert_46983;
            
            if (!nonzzero_46982) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:254:33-46\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:375:19-85\n   #6  trmodel_test.fut:33:16-34:24\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:254:33-46
            
            int64_t num_merges_46984 = sdiv64(flat_dim_46777, next_stride_46980);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool bounds_invalid_upwards_46985 = slt64(num_merges_46984, (int64_t) 0);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool valid_46986 = !bounds_invalid_upwards_46985;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool range_valid_c_46987;
            
            if (!valid_46986) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) num_merges_46984, " is invalid.", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:375:19-85\n   #6  trmodel_test.fut:33:16-34:24\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56
            
            int64_t m_46989 = sub64(next_stride_46980, (int64_t) 1);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56
            
            bool zzero_leq_i_p_m_t_s_46990 = sle64((int64_t) 0, m_46989);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:144:3-155:47
            
            bool cond_46992 = slt64(next_stride_46980, (int64_t) 10);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59
            
            bool protect_assert_disj_46993 = nonzzero_46856 || cond_46992;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:147:30-42
            
            bool nonzzero_cert_46994;
            
            if (!protect_assert_disj_46993) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "division by zero", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:147:30-42\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:33:16-34:24\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:147:30-42
            
            int64_t zeze_lhs_46995 = smod_safe64(next_stride_46980, greatest_divisor_leq_than_res_46800);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:147:43-47
            
            bool num_blocks_46996 = zeze_lhs_46995 == (int64_t) 0;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59
            
            bool protect_assert_disj_46997 = cond_46992 || num_blocks_46996;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:147:20-65
            
            bool assert_c_46998;
            
            if (!protect_assert_disj_46997) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "Assertion is false: (n % block_size == 0)", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:147:20-65\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:33:16-34:24\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:147:20-65
            
            int64_t num_blocks_46999 = sdiv_safe64(next_stride_46980, greatest_divisor_leq_than_res_46800);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:15-27
            
            int64_t dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_47000 = add64((int64_t) 1, num_blocks_46999);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:34-41
            
            int64_t j_m_i_47001 = sub64(next_stride_46980, stride_46979);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
            
            int64_t flat_dim_47002 = greatest_divisor_leq_than_res_46800 * num_blocks_46999;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84
            
            bool bounds_invalid_upwards_47003 = slt64(dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_47000, (int64_t) 0);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool empty_slice_47004 = j_m_i_47001 == (int64_t) 0;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            int64_t m_47005 = sub64(j_m_i_47001, (int64_t) 1);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool zzero_lte_i_47006 = sle64((int64_t) 0, stride_46979);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool i_lte_j_47007 = sle64(stride_46979, next_stride_46980);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59
            
            bool empty_slice_47008 = stride_46979 == (int64_t) 0;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59
            
            int64_t m_47009 = sub64(stride_46979, (int64_t) 1);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
            
            bool bounds_invalid_upwards_47010 = slt64(num_blocks_46999, (int64_t) 0);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:15-54
            
            bool cond_47011 = slt64((int64_t) 0, stride_46979);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84
            
            bool valid_47012 = !bounds_invalid_upwards_47003;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            int64_t i_p_m_t_s_47013 = add64(stride_46979, m_47005);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59
            
            bool zzero_leq_i_p_m_t_s_47014 = sle64((int64_t) 0, m_47009);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59
            
            bool i_p_m_t_s_leq_w_47015 = slt64(m_47009, next_stride_46980);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
            
            bool valid_47016 = !bounds_invalid_upwards_47010;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:3-46
            
            bool i_p_m_t_s_leq_w_47017 = slt64(m_46989, flat_dim_47002);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54
            
            bool y_47018 = slt64((int64_t) 0, j_m_i_47001);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool protect_assert_disj_47019 = cond_46992 || valid_47012;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84
            
            bool range_valid_c_47020;
            
            if (!protect_assert_disj_47019) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_47000, " is invalid.", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:33:16-34:24\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool zzero_leq_i_p_m_t_s_47021 = sle64((int64_t) 0, i_p_m_t_s_47013);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool i_p_m_t_s_leq_w_47022 = slt64(i_p_m_t_s_47013, next_stride_46980);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59
            
            bool y_47023 = zzero_leq_i_p_m_t_s_47014 && i_p_m_t_s_leq_w_47015;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool protect_assert_disj_47024 = cond_46992 || valid_47016;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
            
            bool range_valid_c_47025;
            
            if (!protect_assert_disj_47024) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Range ", (long long) (int64_t) 0, "..", (long long) (int64_t) 1, "..<", (long long) num_blocks_46999, " is invalid.", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:33:16-34:24\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:3-46
            
            bool y_47026 = zzero_leq_i_p_m_t_s_46990 && i_p_m_t_s_leq_w_47017;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool y_47027 = zzero_lte_i_47006 && i_p_m_t_s_leq_w_47022;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59
            
            bool forwards_ok_47028 = zzero_lte_i_47006 && y_47023;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:3-46
            
            bool ok_or_empty_47029 = zzero_46981 || y_47026;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool protect_assert_disj_47030 = cond_47011 || y_47018;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool y_47031 = zzero_leq_i_p_m_t_s_47021 && y_47027;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59
            
            bool ok_or_empty_47032 = empty_slice_47008 || forwards_ok_47028;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool protect_assert_disj_47033 = cond_46992 || ok_or_empty_47029;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:3-46
            
            bool index_certs_47034;
            
            if (!protect_assert_disj_47033) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) next_stride_46980, "] out of bounds for array of shape [", (long long) flat_dim_47002, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:3-46\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:33:16-34:24\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool loop_not_taken_47035 = !cond_46992;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool protect_assert_disj_47036 = protect_assert_disj_47030 || loop_not_taken_47035;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54
            
            bool index_certs_47037;
            
            if (!protect_assert_disj_47036) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_47001, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:5-43\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:375:19-85\n   #8  trmodel_test.fut:33:16-34:24\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool forwards_ok_47038 = i_lte_j_47007 && y_47031;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool protect_assert_disj_47039 = cond_46992 || ok_or_empty_47032;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59
            
            bool index_certs_47040;
            
            if (!protect_assert_disj_47039) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) stride_46979, "] out of bounds for array of shape [", (long long) next_stride_46980, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:52-59\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:33:16-34:24\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool protect_assert_disj_47041 = ok_or_empty_47032 || loop_not_taken_47035;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:26-33
            
            bool index_certs_47042;
            
            if (!protect_assert_disj_47041) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) stride_46979, "] out of bounds for array of shape [", (long long) next_stride_46980, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:26-33\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:33:16-34:24\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool ok_or_empty_47043 = empty_slice_47004 || forwards_ok_47038;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool protect_assert_disj_47044 = cond_46992 || ok_or_empty_47043;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67
            
            bool index_certs_47045;
            
            if (!protect_assert_disj_47044) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) stride_46979, ":] out of bounds for array of shape [", (long long) next_stride_46980, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:60-67\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:33:16-34:24\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            bool protect_assert_disj_47046 = loop_not_taken_47035 || ok_or_empty_47043;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:34-41
            
            bool index_certs_47047;
            
            if (!protect_assert_disj_47046) {
                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) stride_46979, ":] out of bounds for array of shape [", (long long) next_stride_46980, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:34-41\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:33:16-34:24\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            int64_t binop_x_50410 = (int64_t) 8 * num_merges_46984;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            
            int64_t bytes_50411 = next_stride_46980 * binop_x_50410;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56
            
            bool i_lte_j_46991 = sle64((int64_t) 0, next_stride_46980);
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            if (mem_50412_cached_sizze_51080 < bytes_50411) {
                err = lexical_realloc(ctx, &mem_50412, &mem_50412_cached_sizze_51080, bytes_50411);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            if (mem_50415_cached_sizze_51081 < bytes_50411) {
                err = lexical_realloc(ctx, &mem_50415, &mem_50415_cached_sizze_51081, bytes_50411);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            if (mem_50418_cached_sizze_51082 < bytes_50411) {
                err = lexical_realloc(ctx, &mem_50418, &mem_50418_cached_sizze_51082, bytes_50411);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84
            
            int64_t bytes_50431 = (int64_t) 8 * dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_47000;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
            
            int64_t binop_x_50447 = (int64_t) 8 * num_blocks_46999;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
            
            int64_t bytes_50448 = greatest_divisor_leq_than_res_46800 * binop_x_50447;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
            
            int64_t bytes_50516 = (int64_t) 16 * stride_46979;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
            for (int64_t i_50033 = 0; i_50033 < num_merges_46984; i_50033++) {
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:257:26-39
                
                int64_t start_47052 = mul64(next_stride_46980, i_50033);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                int64_t j_m_i_47053 = sub64(loop_dz2084Uz2082U_46974, start_47052);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool empty_slice_47054 = j_m_i_47053 == (int64_t) 0;
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                int64_t m_47055 = sub64(j_m_i_47053, (int64_t) 1);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                int64_t i_p_m_t_s_47056 = add64(start_47052, m_47055);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool zzero_leq_i_p_m_t_s_47057 = sle64((int64_t) 0, i_p_m_t_s_47056);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool i_p_m_t_s_leq_w_47058 = slt64(i_p_m_t_s_47056, loop_dz2084Uz2082U_46974);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool zzero_lte_i_47059 = sle64((int64_t) 0, start_47052);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool i_lte_j_47060 = sle64(start_47052, loop_dz2084Uz2082U_46974);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool y_47061 = i_p_m_t_s_leq_w_47058 && zzero_lte_i_47059;
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool y_47062 = zzero_leq_i_p_m_t_s_47057 && y_47061;
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool forwards_ok_47063 = i_lte_j_47060 && y_47062;
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool ok_or_empty_47064 = empty_slice_47054 || forwards_ok_47063;
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56
                
                bool index_certs_47065;
                
                if (!ok_or_empty_47064) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) start_47052, ":] out of bounds for array of shape [", (long long) loop_dz2084Uz2082U_46974, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:41-56\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:375:19-85\n   #6  trmodel_test.fut:33:16-34:24\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56
                
                bool i_p_m_t_s_leq_w_47066 = slt64(m_46989, j_m_i_47053);
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56
                
                bool y_47067 = zzero_leq_i_p_m_t_s_46990 && i_p_m_t_s_leq_w_47066;
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56
                
                bool forwards_ok_47068 = i_lte_j_46991 && y_47067;
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56
                
                bool ok_or_empty_47069 = zzero_46981 || forwards_ok_47068;
                
                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56
                
                bool index_certs_47070;
                
                if (!ok_or_empty_47069) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) next_stride_46980, "] out of bounds for array of shape [", (long long) j_m_i_47053, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:258:23-56\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:375:19-85\n   #6  trmodel_test.fut:33:16-34:24\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                if (cond_46992) {
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:15-54
                    
                    int64_t dummy_49663;
                    int64_t dummy_49664;
                    double dummy_49665;
                    
                    if (cond_47011) {
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                        
                        int64_t head_res_49666 = ((int64_t *) mem_param_50403.mem)[start_47052];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                        
                        int64_t head_res_49667 = ((int64_t *) mem_param_50406.mem)[start_47052];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                        
                        double head_res_49668 = ((double *) mem_param_50409.mem)[start_47052];
                        
                        dummy_49663 = head_res_49666;
                        dummy_49664 = head_res_49667;
                        dummy_49665 = head_res_49668;
                    } else {
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                        
                        int64_t index_primexp_49669 = stride_46979 + start_47052;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                        
                        int64_t head_res_49670 = ((int64_t *) mem_param_50403.mem)[index_primexp_49669];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                        
                        int64_t head_res_49671 = ((int64_t *) mem_param_50406.mem)[index_primexp_49669];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                        
                        double head_res_49672 = ((double *) mem_param_50409.mem)[index_primexp_49669];
                        
                        dummy_49663 = head_res_49670;
                        dummy_49664 = head_res_49671;
                        dummy_49665 = head_res_49672;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
                    if (memblock_alloc(ctx, &mem_50517, bytes_50516, "mem_50517")) {
                        err = 1;
                        goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
                    for (int64_t nest_i_50879 = 0; nest_i_50879 < next_stride_46980; nest_i_50879++) {
                        ((int64_t *) mem_50517.mem)[nest_i_50879] = dummy_49663;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
                    if (memblock_alloc(ctx, &mem_50519, bytes_50516, "mem_50519")) {
                        err = 1;
                        goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
                    for (int64_t nest_i_50880 = 0; nest_i_50880 < next_stride_46980; nest_i_50880++) {
                        ((int64_t *) mem_50519.mem)[nest_i_50880] = dummy_49664;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
                    if (memblock_alloc(ctx, &mem_50521, bytes_50516, "mem_50521")) {
                        err = 1;
                        goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
                    for (int64_t nest_i_50881 = 0; nest_i_50881 < next_stride_46980; nest_i_50881++) {
                        ((double *) mem_50521.mem)[nest_i_50881] = dummy_49665;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:5-110:29
                    
                    int64_t data_49676;
                    int64_t i_49681 = (int64_t) 0;
                    
                    for (int64_t k_49680 = 0; k_49680 < next_stride_46980; k_49680++) {
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:103:16-18
                        
                        int64_t j_49685 = sub64(k_49680, i_49681);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:9-108:20
                        
                        bool cond_49686 = j_49685 == j_m_i_47001;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:9-108:20
                        
                        bool cond_49687;
                        
                        if (cond_49686) {
                            cond_49687 = 1;
                        } else {
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:30-59
                            
                            bool cond_49688 = slt64(i_49681, stride_46979);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:30-59
                            
                            bool cond_f_res_49689;
                            
                            if (cond_49688) {
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59
                                
                                bool x_49690 = sle64((int64_t) 0, j_49685);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59
                                
                                bool y_49691 = slt64(j_49685, j_m_i_47001);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59
                                
                                bool bounds_check_49692 = x_49690 && y_49691;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59
                                
                                bool index_certs_49693;
                                
                                if (!bounds_check_49692) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_49685, "] out of bounds for array of shape [", (long long) j_m_i_47001, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:5-43\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:375:19-85\n   #8  trmodel_test.fut:33:16-34:24\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54
                                
                                bool x_49698 = sle64((int64_t) 0, i_49681);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54
                                
                                bool bounds_check_49699 = cond_49688 && x_49698;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54
                                
                                bool index_certs_49700;
                                
                                if (!bounds_check_49699) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_49681, "] out of bounds for array of shape [", (long long) stride_46979, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:5-43\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:375:19-85\n   #8  trmodel_test.fut:33:16-34:24\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59
                                
                                int64_t index_primexp_49694 = stride_46979 + j_49685;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t index_primexp_49695 = start_47052 + index_primexp_49694;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t leq_arg1_49696 = ((int64_t *) mem_param_50403.mem)[index_primexp_49695];
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t leq_arg1_49697 = ((int64_t *) mem_param_50406.mem)[index_primexp_49695];
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t index_primexp_49701 = start_47052 + i_49681;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t leq_arg0_49702 = ((int64_t *) mem_param_50403.mem)[index_primexp_49701];
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t leq_arg0_49703 = ((int64_t *) mem_param_50406.mem)[index_primexp_49701];
                                
                                // ../lib/github.com/diku-dk/sparse/mono.fut:75:41-74
                                
                                bool cond_49704 = slt64(leq_arg0_49702, leq_arg1_49696);
                                
                                // ../lib/github.com/diku-dk/sparse/mono.fut:75:53-73
                                
                                bool cond_49705 = leq_arg0_49702 == leq_arg1_49696;
                                
                                // ../lib/github.com/diku-dk/sparse/mono.fut:75:68-73
                                
                                bool lifted_lambda_res_f_res_t_res_49706 = sle64(leq_arg0_49703, leq_arg1_49697);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:46-59
                                
                                bool x_49707 = cond_49705 && lifted_lambda_res_f_res_t_res_49706;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:46-59
                                
                                bool x_49708 = !cond_49704;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:46-59
                                
                                bool y_49709 = x_49707 && x_49708;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:46-59
                                
                                bool lifted_lambda_res_49710 = cond_49704 || y_49709;
                                
                                cond_f_res_49689 = lifted_lambda_res_49710;
                            } else {
                                cond_f_res_49689 = 0;
                            }
                            cond_49687 = cond_f_res_49689;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:9-108:20
                        
                        int64_t loopres_49711;
                        int64_t loopres_49712;
                        int64_t loopres_49713;
                        double loopres_49714;
                        
                        if (cond_49687) {
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21
                            
                            bool x_49716 = sle64((int64_t) 0, i_49681);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21
                            
                            bool y_49717 = slt64(i_49681, stride_46979);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21
                            
                            bool bounds_check_49718 = x_49716 && y_49717;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21
                            
                            bool index_certs_49719;
                            
                            if (!bounds_check_49718) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_49681, "] out of bounds for array of shape [", (long long) stride_46979, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:5-43\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:375:19-85\n   #8  trmodel_test.fut:33:16-34:24\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:13-15
                            
                            int64_t tmp_49715 = add64((int64_t) 1, i_49681);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t index_primexp_49720 = start_47052 + i_49681;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t tmp_49721 = ((int64_t *) mem_param_50403.mem)[index_primexp_49720];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t tmp_49722 = ((int64_t *) mem_param_50406.mem)[index_primexp_49720];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            double tmp_49723 = ((double *) mem_param_50409.mem)[index_primexp_49720];
                            
                            loopres_49711 = tmp_49715;
                            loopres_49712 = tmp_49721;
                            loopres_49713 = tmp_49722;
                            loopres_49714 = tmp_49723;
                        } else {
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19
                            
                            bool x_49724 = sle64((int64_t) 0, j_49685);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19
                            
                            bool y_49725 = slt64(j_49685, j_m_i_47001);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19
                            
                            bool bounds_check_49726 = x_49724 && y_49725;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19
                            
                            bool index_certs_49727;
                            
                            if (!bounds_check_49726) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_49685, "] out of bounds for array of shape [", (long long) j_m_i_47001, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:145:5-43\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:375:19-85\n   #8  trmodel_test.fut:33:16-34:24\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59
                            
                            int64_t index_primexp_49728 = stride_46979 + j_49685;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t index_primexp_49729 = start_47052 + index_primexp_49728;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t tmp_49730 = ((int64_t *) mem_param_50403.mem)[index_primexp_49729];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t tmp_49731 = ((int64_t *) mem_param_50406.mem)[index_primexp_49729];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            double tmp_49732 = ((double *) mem_param_50409.mem)[index_primexp_49729];
                            
                            loopres_49711 = i_49681;
                            loopres_49712 = tmp_49730;
                            loopres_49713 = tmp_49731;
                            loopres_49714 = tmp_49732;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:110:11-28
                        ((int64_t *) mem_50517.mem)[k_49680] = loopres_49712;
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:110:11-28
                        ((int64_t *) mem_50519.mem)[k_49680] = loopres_49713;
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:110:11-28
                        ((double *) mem_50521.mem)[k_49680] = loopres_49714;
                        
                        int64_t i_tmp_50882 = loopres_49711;
                        
                        i_49681 = i_tmp_50882;
                    }
                    data_49676 = i_49681;
                    if (memblock_set(ctx, &ext_mem_50548, &mem_50517, "mem_50517") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_50545, &mem_50519, "mem_50519") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_50542, &mem_50521, "mem_50521") != 0)
                        return 1;
                } else {
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84
                    if (mem_50432_cached_sizze_51083 < bytes_50431) {
                        err = lexical_realloc(ctx, &mem_50432, &mem_50432_cached_sizze_51083, bytes_50431);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84
                    if (mem_50434_cached_sizze_51084 < bytes_50431) {
                        err = lexical_realloc(ctx, &mem_50434, &mem_50434_cached_sizze_51084, bytes_50431);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84
                    for (int64_t i_50014 = 0; i_50014 < dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_47000; i_50014++) {
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:71-83
                        
                        int64_t split_count_arg3_47151 = mul64(greatest_divisor_leq_than_res_46800, i_50014);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:32:15-39
                        
                        int64_t min_res_47152 = smin64(stride_46979, split_count_arg3_47151);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:33:15-39
                        
                        int64_t min_res_47153 = smin64(j_m_i_47001, split_count_arg3_47151);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:36:27-37
                        
                        int64_t zm_lhs_47154 = add64(min_res_47152, min_res_47153);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:36:39-46
                        
                        int64_t slack_47155 = sub64(zm_lhs_47154, split_count_arg3_47151);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:37:17-39
                        
                        int64_t min_res_47156 = smin64(min_res_47152, slack_47155);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:38:17-39
                        
                        int64_t min_res_47157 = smin64(min_res_47153, min_res_47156);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:40:32-39
                        
                        int64_t max_arg1_47158 = sub64(min_res_47152, min_res_47157);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:40:15-39
                        
                        int64_t max_res_47159 = smax64((int64_t) 0, max_arg1_47158);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:41:32-39
                        
                        int64_t max_arg1_47160 = sub64(min_res_47153, min_res_47157);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:41:15-39
                        
                        int64_t max_res_47161 = smax64((int64_t) 0, max_arg1_47160);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:43:23-40
                        
                        int64_t zm_lhs_47162 = sub64(split_count_arg3_47151, max_res_47159);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:43:42-59
                        
                        int64_t count_47163 = sub64(zm_lhs_47162, max_res_47161);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:81:5-83:39
                        
                        bool loop_cond_47164 = slt64((int64_t) 0, count_47163);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:81:5-83:39
                        
                        bool defunc_0_split_count_res_47165;
                        int64_t defunc_0_split_count_res_47166;
                        int64_t defunc_0_split_count_res_47167;
                        int64_t defunc_0_split_count_res_47168;
                        int64_t defunc_0_split_count_res_47169;
                        int64_t defunc_0_split_count_res_47170;
                        bool loop_while_47171;
                        int64_t ss_47172;
                        int64_t ss_47173;
                        int64_t tt_47174;
                        int64_t tt_47175;
                        int64_t count_47176;
                        
                        loop_while_47171 = loop_cond_47164;
                        ss_47172 = max_res_47159;
                        ss_47173 = min_res_47152;
                        tt_47174 = max_res_47161;
                        tt_47175 = min_res_47153;
                        count_47176 = count_47163;
                        while (loop_while_47171) {
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:48:11-15
                            
                            int64_t zlze_lhs_47177 = sub64(ss_47173, ss_47172);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:48:5-78:40
                            
                            bool cond_47178 = sle64(zlze_lhs_47177, (int64_t) 0);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38
                            
                            int64_t defunc_0_lifted_step_res_47179;
                            int64_t defunc_0_lifted_step_res_47180;
                            int64_t defunc_0_lifted_step_res_47181;
                            int64_t defunc_0_lifted_step_res_47182;
                            
                            if (cond_47178) {
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:49:24-30
                                
                                int64_t tmp_49736 = add64(tt_47174, count_47176);
                                
                                defunc_0_lifted_step_res_47179 = ss_47172;
                                defunc_0_lifted_step_res_47180 = tmp_49736;
                                defunc_0_lifted_step_res_47181 = tt_47175;
                                defunc_0_lifted_step_res_47182 = (int64_t) 0;
                            } else {
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:50:16-20
                                
                                int64_t zlze_lhs_47184 = sub64(tt_47175, tt_47174);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:50:10-78:40
                                
                                bool cond_47185 = sle64(zlze_lhs_47184, (int64_t) 0);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38
                                
                                int64_t defunc_0_lifted_step_res_f_res_47186;
                                int64_t defunc_0_lifted_step_res_f_res_47187;
                                int64_t defunc_0_lifted_step_res_f_res_47188;
                                int64_t defunc_0_lifted_step_res_f_res_47189;
                                
                                if (cond_47185) {
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:51:12-18
                                    
                                    int64_t tmp_49737 = add64(ss_47172, count_47176);
                                    
                                    defunc_0_lifted_step_res_f_res_47186 = tmp_49737;
                                    defunc_0_lifted_step_res_f_res_47187 = tt_47174;
                                    defunc_0_lifted_step_res_f_res_47188 = tt_47175;
                                    defunc_0_lifted_step_res_f_res_47189 = (int64_t) 0;
                                } else {
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:52:10-78:40
                                    
                                    bool cond_47191 = count_47176 == (int64_t) 1;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38
                                    
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_47192;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_47193;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_47194;
                                    int64_t defunc_0_lifted_step_res_f_res_f_res_47195;
                                    
                                    if (cond_47191) {
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:21-27
                                        
                                        bool x_49739 = sle64((int64_t) 0, ss_47172);
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:21-27
                                        
                                        bool y_49740 = slt64(ss_47172, stride_46979);
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:21-27
                                        
                                        bool bounds_check_49741 = x_49739 && y_49740;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:21-27
                                        
                                        bool index_certs_49742;
                                        
                                        if (!bounds_check_49741) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) ss_47172, "] out of bounds for array of shape [", (long long) stride_46979, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:21-27\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:36-83\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #4  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #7  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #8  trmodel.fut:375:19-85\n   #9  trmodel_test.fut:33:16-34:24\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:14-20
                                        
                                        bool x_49746 = sle64((int64_t) 0, tt_47174);
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:14-20
                                        
                                        bool y_49747 = slt64(tt_47174, j_m_i_47001);
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:14-20
                                        
                                        bool bounds_check_49748 = x_49746 && y_49747;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:14-20
                                        
                                        bool index_certs_49749;
                                        
                                        if (!bounds_check_49748) {
                                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tt_47174, "] out of bounds for array of shape [", (long long) j_m_i_47001, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:14-20\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:36-83\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #4  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #7  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #8  trmodel.fut:375:19-85\n   #9  trmodel_test.fut:33:16-34:24\n"));
                                            err = FUTHARK_PROGRAM_ERROR;
                                            goto cleanup;
                                        }
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                        
                                        int64_t index_primexp_49743 = start_47052 + ss_47172;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                        
                                        int64_t leq_arg1_49744 = ((int64_t *) mem_param_50403.mem)[index_primexp_49743];
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                        
                                        int64_t leq_arg1_49745 = ((int64_t *) mem_param_50406.mem)[index_primexp_49743];
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84
                                        
                                        int64_t index_primexp_49750 = stride_46979 + tt_47174;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                        
                                        int64_t index_primexp_49751 = start_47052 + index_primexp_49750;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                        
                                        int64_t leq_arg0_49752 = ((int64_t *) mem_param_50403.mem)[index_primexp_49751];
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                        
                                        int64_t leq_arg0_49753 = ((int64_t *) mem_param_50406.mem)[index_primexp_49751];
                                        
                                        // ../lib/github.com/diku-dk/sparse/mono.fut:75:41-74
                                        
                                        bool cond_49754 = slt64(leq_arg0_49752, leq_arg1_49744);
                                        
                                        // ../lib/github.com/diku-dk/sparse/mono.fut:75:53-73
                                        
                                        bool cond_49755 = leq_arg0_49752 == leq_arg1_49744;
                                        
                                        // ../lib/github.com/diku-dk/sparse/mono.fut:75:68-73
                                        
                                        bool lifted_lambda_res_f_res_t_res_49756 = sle64(leq_arg0_49753, leq_arg1_49745);
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:7-56:38
                                        
                                        bool x_49757 = cond_49755 && lifted_lambda_res_f_res_t_res_49756;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:7-56:38
                                        
                                        bool x_49758 = !cond_49754;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:7-56:38
                                        
                                        bool y_49759 = x_49757 && x_49758;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:53:7-56:38
                                        
                                        bool lifted_lambda_res_49760 = cond_49754 || y_49759;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38
                                        
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_t_res_49761;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_t_res_49762;
                                        
                                        if (lifted_lambda_res_49760) {
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:54:26-28
                                            
                                            int64_t tmp_49763 = add64((int64_t) 1, tt_47174);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_49761 = ss_47172;
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_49762 = tmp_49763;
                                        } else {
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:56:14-16
                                            
                                            int64_t tmp_49764 = add64((int64_t) 1, ss_47172);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_49761 = tmp_49764;
                                            defunc_0_lifted_step_res_f_res_f_res_t_res_49762 = tt_47174;
                                        }
                                        defunc_0_lifted_step_res_f_res_f_res_47192 = defunc_0_lifted_step_res_f_res_f_res_t_res_49761;
                                        defunc_0_lifted_step_res_f_res_f_res_47193 = defunc_0_lifted_step_res_f_res_f_res_t_res_49762;
                                        defunc_0_lifted_step_res_f_res_f_res_47194 = tt_47175;
                                        defunc_0_lifted_step_res_f_res_f_res_47195 = (int64_t) 0;
                                    } else {
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:58:19-22
                                        
                                        int64_t m_47222 = sdiv64(count_47176, (int64_t) 2);
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:59:19-22
                                        
                                        int64_t n_47223 = sub64(count_47176, m_47222);
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:71:7-73:30
                                        
                                        bool cond_47224 = n_47223 == (int64_t) 0;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:72:10-12
                                        
                                        int64_t zgze_lhs_47225 = add64(ss_47172, m_47222);
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:72:13-19
                                        
                                        bool cond_f_res_47226 = sle64(ss_47173, zgze_lhs_47225);
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38
                                        
                                        bool x_47227 = !cond_47224;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38
                                        
                                        bool y_47228 = cond_f_res_47226 && x_47227;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38
                                        
                                        bool cond_47229 = cond_47224 || y_47228;
                                        
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:71:7-73:30
                                        
                                        bool leq_y_x_47230;
                                        
                                        if (cond_47229) {
                                            leq_y_x_47230 = 1;
                                        } else {
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:22-30
                                            
                                            bool x_47231 = sle64((int64_t) 0, zgze_lhs_47225);
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:22-30
                                            
                                            bool y_47232 = slt64(zgze_lhs_47225, stride_46979);
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:22-30
                                            
                                            bool bounds_check_47233 = x_47231 && y_47232;
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:22-30
                                            
                                            bool index_certs_47234;
                                            
                                            if (!bounds_check_47233) {
                                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) zgze_lhs_47225, "] out of bounds for array of shape [", (long long) stride_46979, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:22-30\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:36-83\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #4  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #7  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #8  trmodel.fut:375:19-85\n   #9  trmodel_test.fut:33:16-34:24\n"));
                                                err = FUTHARK_PROGRAM_ERROR;
                                                goto cleanup;
                                            }
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:16-18
                                            
                                            int64_t zm_lhs_47238 = add64(tt_47174, n_47223);
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:18-20
                                            
                                            int64_t leq_arg0_47239 = sub64(zm_lhs_47238, (int64_t) 1);
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:11-21
                                            
                                            bool x_47240 = sle64((int64_t) 0, leq_arg0_47239);
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:11-21
                                            
                                            bool y_47241 = slt64(leq_arg0_47239, j_m_i_47001);
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:11-21
                                            
                                            bool bounds_check_47242 = x_47240 && y_47241;
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:11-21
                                            
                                            bool index_certs_47243;
                                            
                                            if (!bounds_check_47242) {
                                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) leq_arg0_47239, "] out of bounds for array of shape [", (long long) j_m_i_47001, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:11-21\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:36-83\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #4  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #7  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #8  trmodel.fut:375:19-85\n   #9  trmodel_test.fut:33:16-34:24\n"));
                                                err = FUTHARK_PROGRAM_ERROR;
                                                goto cleanup;
                                            }
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                            
                                            int64_t index_primexp_47235 = start_47052 + zgze_lhs_47225;
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                            
                                            int64_t leq_arg1_47236 = ((int64_t *) mem_param_50403.mem)[index_primexp_47235];
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                            
                                            int64_t leq_arg1_47237 = ((int64_t *) mem_param_50406.mem)[index_primexp_47235];
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:149:5-84
                                            
                                            int64_t index_primexp_47244 = stride_46979 + leq_arg0_47239;
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                            
                                            int64_t index_primexp_47245 = start_47052 + index_primexp_47244;
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                            
                                            int64_t leq_arg0_47246 = ((int64_t *) mem_param_50403.mem)[index_primexp_47245];
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                            
                                            int64_t leq_arg0_47247 = ((int64_t *) mem_param_50406.mem)[index_primexp_47245];
                                            
                                            // ../lib/github.com/diku-dk/sparse/mono.fut:75:41-74
                                            
                                            bool cond_47248 = slt64(leq_arg0_47246, leq_arg1_47236);
                                            
                                            // ../lib/github.com/diku-dk/sparse/mono.fut:75:53-73
                                            
                                            bool cond_47249 = leq_arg0_47246 == leq_arg1_47236;
                                            
                                            // ../lib/github.com/diku-dk/sparse/mono.fut:75:68-73
                                            
                                            bool lifted_lambda_res_f_res_t_res_47250 = sle64(leq_arg0_47247, leq_arg1_47237);
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:7-30
                                            
                                            bool x_47251 = cond_47249 && lifted_lambda_res_f_res_t_res_47250;
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:7-30
                                            
                                            bool x_47252 = !cond_47248;
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:7-30
                                            
                                            bool y_47253 = x_47251 && x_47252;
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:73:7-30
                                            
                                            bool lifted_lambda_res_47254 = cond_47248 || y_47253;
                                            
                                            leq_y_x_47230 = lifted_lambda_res_47254;
                                        }
                                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:83:23-38
                                        
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_47255;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_47256;
                                        int64_t defunc_0_lifted_step_res_f_res_f_res_f_res_47257;
                                        
                                        if (leq_y_x_47230) {
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:76:24-26
                                            
                                            int64_t tmp_49765 = add64(tt_47174, n_47223);
                                            
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:76:39-41
                                            
                                            int64_t tmp_49766 = sub64(count_47176, n_47223);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_47255 = tmp_49765;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_47256 = tt_47175;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_47257 = tmp_49766;
                                        } else {
                                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:78:29-31
                                            
                                            int64_t tmp_47260 = add64(tt_47174, n_47223);
                                            
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_47255 = tt_47174;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_47256 = tmp_47260;
                                            defunc_0_lifted_step_res_f_res_f_res_f_res_47257 = count_47176;
                                        }
                                        defunc_0_lifted_step_res_f_res_f_res_47192 = ss_47172;
                                        defunc_0_lifted_step_res_f_res_f_res_47193 = defunc_0_lifted_step_res_f_res_f_res_f_res_47255;
                                        defunc_0_lifted_step_res_f_res_f_res_47194 = defunc_0_lifted_step_res_f_res_f_res_f_res_47256;
                                        defunc_0_lifted_step_res_f_res_f_res_47195 = defunc_0_lifted_step_res_f_res_f_res_f_res_47257;
                                    }
                                    defunc_0_lifted_step_res_f_res_47186 = defunc_0_lifted_step_res_f_res_f_res_47192;
                                    defunc_0_lifted_step_res_f_res_47187 = defunc_0_lifted_step_res_f_res_f_res_47193;
                                    defunc_0_lifted_step_res_f_res_47188 = defunc_0_lifted_step_res_f_res_f_res_47194;
                                    defunc_0_lifted_step_res_f_res_47189 = defunc_0_lifted_step_res_f_res_f_res_47195;
                                }
                                defunc_0_lifted_step_res_47179 = defunc_0_lifted_step_res_f_res_47186;
                                defunc_0_lifted_step_res_47180 = defunc_0_lifted_step_res_f_res_47187;
                                defunc_0_lifted_step_res_47181 = defunc_0_lifted_step_res_f_res_47188;
                                defunc_0_lifted_step_res_47182 = defunc_0_lifted_step_res_f_res_47189;
                            }
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:32:32-39
                            
                            int64_t min_arg1_47261 = add64(defunc_0_lifted_step_res_47179, defunc_0_lifted_step_res_47182);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:32:15-39
                            
                            int64_t min_res_47262 = smin64(ss_47173, min_arg1_47261);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:33:32-39
                            
                            int64_t min_arg1_47263 = add64(defunc_0_lifted_step_res_47180, defunc_0_lifted_step_res_47182);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:33:15-39
                            
                            int64_t min_res_47264 = smin64(defunc_0_lifted_step_res_47181, min_arg1_47263);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:36:21-25
                            
                            int64_t zp_lhs_47265 = sub64(min_res_47262, defunc_0_lifted_step_res_47179);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:36:33-37
                            
                            int64_t zp_rhs_47266 = sub64(min_res_47264, defunc_0_lifted_step_res_47180);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:36:27-37
                            
                            int64_t zm_lhs_47267 = add64(zp_lhs_47265, zp_rhs_47266);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:36:39-46
                            
                            int64_t slack_47268 = sub64(zm_lhs_47267, defunc_0_lifted_step_res_47182);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:37:17-39
                            
                            int64_t min_res_47269 = smin64(zp_lhs_47265, slack_47268);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:38:17-39
                            
                            int64_t min_res_47270 = smin64(zp_rhs_47266, min_res_47269);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:40:32-39
                            
                            int64_t max_arg1_47271 = sub64(min_res_47262, min_res_47270);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:40:15-39
                            
                            int64_t max_res_47272 = smax64(defunc_0_lifted_step_res_47179, max_arg1_47271);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:41:32-39
                            
                            int64_t max_arg1_47273 = sub64(min_res_47264, min_res_47270);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:41:15-39
                            
                            int64_t max_res_47274 = smax64(defunc_0_lifted_step_res_47180, max_arg1_47273);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:43:30-40
                            
                            int64_t zm_rhs_47275 = sub64(max_res_47272, defunc_0_lifted_step_res_47179);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:43:23-40
                            
                            int64_t zm_lhs_47276 = sub64(defunc_0_lifted_step_res_47182, zm_rhs_47275);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:43:49-59
                            
                            int64_t zm_rhs_47277 = sub64(max_res_47274, defunc_0_lifted_step_res_47180);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:43:42-59
                            
                            int64_t count_47278 = sub64(zm_lhs_47276, zm_rhs_47277);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:82:17-20
                            
                            bool loop_cond_47279 = slt64((int64_t) 0, count_47278);
                            bool loop_while_tmp_50888 = loop_cond_47279;
                            int64_t ss_tmp_50889 = max_res_47272;
                            int64_t ss_tmp_50890 = min_res_47262;
                            int64_t tt_tmp_50891 = max_res_47274;
                            int64_t tt_tmp_50892 = min_res_47264;
                            int64_t count_tmp_50893 = count_47278;
                            
                            loop_while_47171 = loop_while_tmp_50888;
                            ss_47172 = ss_tmp_50889;
                            ss_47173 = ss_tmp_50890;
                            tt_47174 = tt_tmp_50891;
                            tt_47175 = tt_tmp_50892;
                            count_47176 = count_tmp_50893;
                        }
                        defunc_0_split_count_res_47165 = loop_while_47171;
                        defunc_0_split_count_res_47166 = ss_47172;
                        defunc_0_split_count_res_47167 = ss_47173;
                        defunc_0_split_count_res_47168 = tt_47174;
                        defunc_0_split_count_res_47169 = tt_47175;
                        defunc_0_split_count_res_47170 = count_47176;
                        ((int64_t *) mem_50432)[i_50014] = defunc_0_split_count_res_47166;
                        ((int64_t *) mem_50434)[i_50014] = defunc_0_split_count_res_47168;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
                    if (mem_50449_cached_sizze_51085 < bytes_50448) {
                        err = lexical_realloc(ctx, &mem_50449, &mem_50449_cached_sizze_51085, bytes_50448);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
                    if (mem_50452_cached_sizze_51086 < bytes_50448) {
                        err = lexical_realloc(ctx, &mem_50452, &mem_50452_cached_sizze_51086, bytes_50448);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
                    if (mem_50455_cached_sizze_51087 < bytes_50448) {
                        err = lexical_realloc(ctx, &mem_50455, &mem_50455_cached_sizze_51087, bytes_50448);
                        if (err != FUTHARK_SUCCESS)
                            goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
                    for (int64_t i_50023 = 0; i_50023 < num_blocks_46999; i_50023++) {
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:151:22-34
                        
                        bool y_47286 = slt64(i_50023, dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_47000);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:151:22-34
                        
                        bool index_certs_47288;
                        
                        if (!y_47286) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_50023, "] out of bounds for array of shape [", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_47000, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:151:22-34\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:33:16-34:24\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:151:22-34
                        
                        int64_t defunc_0_f_res_47289 = ((int64_t *) mem_50432)[i_50023];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:151:22-34
                        
                        int64_t defunc_0_f_res_47290 = ((int64_t *) mem_50434)[i_50023];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:152:33-35
                        
                        int64_t tmp_47291 = add64((int64_t) 1, i_50023);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36
                        
                        bool x_47292 = sle64((int64_t) 0, tmp_47291);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36
                        
                        bool y_47293 = slt64(tmp_47291, dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_47000);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36
                        
                        bool bounds_check_47294 = x_47292 && y_47293;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36
                        
                        bool index_certs_47295;
                        
                        if (!bounds_check_47294) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tmp_47291, "] out of bounds for array of shape [", (long long) dzlz7bUZLzpZRz20U1z20Unum_blocksz7dUzg_47000, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:33:16-34:24\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36
                        
                        int64_t defunc_0_f_res_47296 = ((int64_t *) mem_50432)[tmp_47291];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:152:22-36
                        
                        int64_t defunc_0_f_res_47297 = ((int64_t *) mem_50434)[tmp_47291];
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:45-49
                        
                        int64_t merge_sequential_arg2_47298 = add64(stride_46979, defunc_0_f_res_47290);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:53-57
                        
                        int64_t merge_sequential_arg2_47299 = add64(stride_46979, defunc_0_f_res_47297);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        int64_t j_m_i_47300 = sub64(merge_sequential_arg2_47299, merge_sequential_arg2_47298);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool empty_slice_47301 = j_m_i_47300 == (int64_t) 0;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        int64_t m_47302 = sub64(j_m_i_47300, (int64_t) 1);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        int64_t i_p_m_t_s_47303 = add64(merge_sequential_arg2_47298, m_47302);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool zzero_leq_i_p_m_t_s_47304 = sle64((int64_t) 0, i_p_m_t_s_47303);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool i_p_m_t_s_leq_w_47305 = slt64(i_p_m_t_s_47303, next_stride_46980);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool zzero_lte_i_47306 = sle64((int64_t) 0, merge_sequential_arg2_47298);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool i_lte_j_47307 = sle64(merge_sequential_arg2_47298, merge_sequential_arg2_47299);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool y_47308 = i_p_m_t_s_leq_w_47305 && zzero_lte_i_47306;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool y_47309 = zzero_leq_i_p_m_t_s_47304 && y_47308;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool forwards_ok_47310 = i_lte_j_47307 && y_47309;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool ok_or_empty_47311 = empty_slice_47301 || forwards_ok_47310;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58
                        
                        bool index_certs_47312;
                        
                        if (!ok_or_empty_47311) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) merge_sequential_arg2_47298, ":", (long long) merge_sequential_arg2_47299, "] out of bounds for array of shape [", (long long) next_stride_46980, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:40-58\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:33:16-34:24\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        int64_t j_m_i_47313 = sub64(defunc_0_f_res_47296, defunc_0_f_res_47289);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool empty_slice_47314 = j_m_i_47313 == (int64_t) 0;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        int64_t m_47315 = sub64(j_m_i_47313, (int64_t) 1);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        int64_t i_p_m_t_s_47316 = add64(defunc_0_f_res_47289, m_47315);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool zzero_leq_i_p_m_t_s_47317 = sle64((int64_t) 0, i_p_m_t_s_47316);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool i_p_m_t_s_leq_w_47318 = slt64(i_p_m_t_s_47316, next_stride_46980);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool zzero_lte_i_47319 = sle64((int64_t) 0, defunc_0_f_res_47289);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool i_lte_j_47320 = sle64(defunc_0_f_res_47289, defunc_0_f_res_47296);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool y_47321 = i_p_m_t_s_leq_w_47318 && zzero_lte_i_47319;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool y_47322 = zzero_leq_i_p_m_t_s_47317 && y_47321;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool forwards_ok_47323 = i_lte_j_47320 && y_47322;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool ok_or_empty_47324 = empty_slice_47314 || forwards_ok_47323;
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39
                        
                        bool index_certs_47325;
                        
                        if (!ok_or_empty_47324) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) defunc_0_f_res_47289, ":", (long long) defunc_0_f_res_47296, "] out of bounds for array of shape [", (long long) next_stride_46980, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:29-39\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #6  trmodel.fut:375:19-85\n   #7  trmodel_test.fut:33:16-34:24\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:15-54
                        
                        bool cond_47326 = slt64((int64_t) 0, j_m_i_47313);
                        
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:15-54
                        
                        int64_t dummy_47327;
                        int64_t dummy_47328;
                        double dummy_47329;
                        
                        if (cond_47326) {
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:36-42
                            
                            bool index_certs_49767;
                            
                            if (!cond_47326) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_47313, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:36-42\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:8-69\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:375:19-85\n   #8  trmodel_test.fut:33:16-34:24\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t index_primexp_49768 = start_47052 + defunc_0_f_res_47289;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t head_res_49769 = ((int64_t *) mem_param_50403.mem)[index_primexp_49768];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t head_res_49770 = ((int64_t *) mem_param_50406.mem)[index_primexp_49768];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            double head_res_49771 = ((double *) mem_param_50409.mem)[index_primexp_49768];
                            
                            dummy_47327 = head_res_49769;
                            dummy_47328 = head_res_49770;
                            dummy_47329 = head_res_49771;
                        } else {
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54
                            
                            bool y_47335 = slt64((int64_t) 0, j_m_i_47300);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54
                            
                            bool index_certs_47336;
                            
                            if (!y_47335) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) j_m_i_47300, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:100:48-54\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:8-69\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:375:19-85\n   #8  trmodel_test.fut:33:16-34:24\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t index_primexp_47337 = start_47052 + merge_sequential_arg2_47298;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t head_res_47338 = ((int64_t *) mem_param_50403.mem)[index_primexp_47337];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            int64_t head_res_47339 = ((int64_t *) mem_param_50406.mem)[index_primexp_47337];
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                            
                            double head_res_47340 = ((double *) mem_param_50409.mem)[index_primexp_47337];
                            
                            dummy_47327 = head_res_47338;
                            dummy_47328 = head_res_47339;
                            dummy_47329 = head_res_47340;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
                        for (int64_t nest_i_50897 = 0; nest_i_50897 < greatest_divisor_leq_than_res_46800; nest_i_50897++) {
                            ((int64_t *) mem_50455)[i_50023 * greatest_divisor_leq_than_res_46800 + nest_i_50897] = dummy_47327;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
                        for (int64_t nest_i_50898 = 0; nest_i_50898 < greatest_divisor_leq_than_res_46800; nest_i_50898++) {
                            ((int64_t *) mem_50452)[i_50023 * greatest_divisor_leq_than_res_46800 + nest_i_50898] = dummy_47328;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:26-43
                        for (int64_t nest_i_50899 = 0; nest_i_50899 < greatest_divisor_leq_than_res_46800; nest_i_50899++) {
                            ((double *) mem_50449)[i_50023 * greatest_divisor_leq_than_res_46800 + nest_i_50899] = dummy_47329;
                        }
                        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:102:5-110:29
                        
                        int64_t data_47344;
                        int64_t i_47349 = (int64_t) 0;
                        
                        for (int64_t k_47348 = 0; k_47348 < greatest_divisor_leq_than_res_46800; k_47348++) {
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:103:16-18
                            
                            int64_t j_47353 = sub64(k_47348, i_47349);
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:9-108:20
                            
                            bool cond_47354 = j_47353 == j_m_i_47300;
                            
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:9-108:20
                            
                            bool cond_47355;
                            
                            if (cond_47354) {
                                cond_47355 = 1;
                            } else {
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:30-59
                                
                                bool cond_47356 = slt64(i_47349, j_m_i_47313);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:30-59
                                
                                bool cond_f_res_47357;
                                
                                if (cond_47356) {
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59
                                    
                                    bool x_49772 = sle64((int64_t) 0, j_47353);
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59
                                    
                                    bool y_49773 = slt64(j_47353, j_m_i_47300);
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59
                                    
                                    bool bounds_check_49774 = x_49772 && y_49773;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59
                                    
                                    bool index_certs_49775;
                                    
                                    if (!bounds_check_49774) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_47353, "] out of bounds for array of shape [", (long long) j_m_i_47300, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:55-59\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:8-69\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:375:19-85\n   #8  trmodel_test.fut:33:16-34:24\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54
                                    
                                    bool x_49780 = sle64((int64_t) 0, i_47349);
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54
                                    
                                    bool bounds_check_49781 = cond_47356 && x_49780;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54
                                    
                                    bool index_certs_49782;
                                    
                                    if (!bounds_check_49781) {
                                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_47349, "] out of bounds for array of shape [", (long long) j_m_i_47313, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:50-54\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:8-69\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:375:19-85\n   #8  trmodel_test.fut:33:16-34:24\n"));
                                        err = FUTHARK_PROGRAM_ERROR;
                                        goto cleanup;
                                    }
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
                                    
                                    int64_t index_primexp_49776 = merge_sequential_arg2_47298 + j_47353;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                    
                                    int64_t index_primexp_49777 = start_47052 + index_primexp_49776;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                    
                                    int64_t leq_arg1_49778 = ((int64_t *) mem_param_50403.mem)[index_primexp_49777];
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                    
                                    int64_t leq_arg1_49779 = ((int64_t *) mem_param_50406.mem)[index_primexp_49777];
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
                                    
                                    int64_t index_primexp_49783 = defunc_0_f_res_47289 + i_47349;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                    
                                    int64_t index_primexp_49784 = start_47052 + index_primexp_49783;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                    
                                    int64_t leq_arg0_49785 = ((int64_t *) mem_param_50403.mem)[index_primexp_49784];
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                    
                                    int64_t leq_arg0_49786 = ((int64_t *) mem_param_50406.mem)[index_primexp_49784];
                                    
                                    // ../lib/github.com/diku-dk/sparse/mono.fut:75:41-74
                                    
                                    bool cond_49787 = slt64(leq_arg0_49785, leq_arg1_49778);
                                    
                                    // ../lib/github.com/diku-dk/sparse/mono.fut:75:53-73
                                    
                                    bool cond_49788 = leq_arg0_49785 == leq_arg1_49778;
                                    
                                    // ../lib/github.com/diku-dk/sparse/mono.fut:75:68-73
                                    
                                    bool lifted_lambda_res_f_res_t_res_49789 = sle64(leq_arg0_49786, leq_arg1_49779);
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:46-59
                                    
                                    bool x_49790 = cond_49788 && lifted_lambda_res_f_res_t_res_49789;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:46-59
                                    
                                    bool x_49791 = !cond_49787;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:46-59
                                    
                                    bool y_49792 = x_49790 && x_49791;
                                    
                                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:46-59
                                    
                                    bool lifted_lambda_res_49793 = cond_49787 || y_49792;
                                    
                                    cond_f_res_47357 = lifted_lambda_res_49793;
                                } else {
                                    cond_f_res_47357 = 0;
                                }
                                cond_47355 = cond_f_res_47357;
                            }
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:105:9-108:20
                            
                            int64_t loopres_47380;
                            int64_t loopres_47381;
                            int64_t loopres_47382;
                            double loopres_47383;
                            
                            if (cond_47355) {
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21
                                
                                bool x_49795 = sle64((int64_t) 0, i_47349);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21
                                
                                bool y_49796 = slt64(i_47349, j_m_i_47313);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21
                                
                                bool bounds_check_49797 = x_49795 && y_49796;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21
                                
                                bool index_certs_49798;
                                
                                if (!bounds_check_49797) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) i_47349, "] out of bounds for array of shape [", (long long) j_m_i_47313, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:17-21\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:8-69\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:375:19-85\n   #8  trmodel_test.fut:33:16-34:24\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:106:13-15
                                
                                int64_t tmp_49794 = add64((int64_t) 1, i_47349);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
                                
                                int64_t index_primexp_49799 = defunc_0_f_res_47289 + i_47349;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t index_primexp_49800 = start_47052 + index_primexp_49799;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t tmp_49801 = ((int64_t *) mem_param_50403.mem)[index_primexp_49800];
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t tmp_49802 = ((int64_t *) mem_param_50406.mem)[index_primexp_49800];
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                double tmp_49803 = ((double *) mem_param_50409.mem)[index_primexp_49800];
                                
                                loopres_47380 = tmp_49794;
                                loopres_47381 = tmp_49801;
                                loopres_47382 = tmp_49802;
                                loopres_47383 = tmp_49803;
                            } else {
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19
                                
                                bool x_47394 = sle64((int64_t) 0, j_47353);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19
                                
                                bool y_47395 = slt64(j_47353, j_m_i_47300);
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19
                                
                                bool bounds_check_47396 = x_47394 && y_47395;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19
                                
                                bool index_certs_47397;
                                
                                if (!bounds_check_47396) {
                                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) j_47353, "] out of bounds for array of shape [", (long long) j_m_i_47300, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:108:15-19\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:153:8-69\n   #2  ../lib/github.com/diku-dk/sorts/merge_sort.fut:260:11-59\n   #3  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #5  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #6  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #7  trmodel.fut:375:19-85\n   #8  trmodel_test.fut:33:16-34:24\n"));
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:150:18-155:28
                                
                                int64_t index_primexp_47398 = merge_sequential_arg2_47298 + j_47353;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t index_primexp_47399 = start_47052 + index_primexp_47398;
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t tmp_47400 = ((int64_t *) mem_param_50403.mem)[index_primexp_47399];
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                int64_t tmp_47401 = ((int64_t *) mem_param_50406.mem)[index_primexp_47399];
                                
                                // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:18-260:59
                                
                                double tmp_47402 = ((double *) mem_param_50409.mem)[index_primexp_47399];
                                
                                loopres_47380 = i_47349;
                                loopres_47381 = tmp_47400;
                                loopres_47382 = tmp_47401;
                                loopres_47383 = tmp_47402;
                            }
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:110:11-28
                            ((int64_t *) mem_50455)[i_50023 * greatest_divisor_leq_than_res_46800 + k_47348] = loopres_47381;
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:110:11-28
                            ((int64_t *) mem_50452)[i_50023 * greatest_divisor_leq_than_res_46800 + k_47348] = loopres_47382;
                            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:110:11-28
                            ((double *) mem_50449)[i_50023 * greatest_divisor_leq_than_res_46800 + k_47348] = loopres_47383;
                            
                            int64_t i_tmp_50900 = loopres_47380;
                            
                            i_47349 = i_tmp_50900;
                        }
                        data_47344 = i_47349;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
                    if (memblock_alloc(ctx, &mem_50506, bytes_50448, "mem_50506")) {
                        err = 1;
                        goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
                    lmad_copy_8b(ctx, 2, (uint64_t *) mem_50506.mem, (int64_t) 0, (int64_t []) {greatest_divisor_leq_than_res_46800, (int64_t) 1}, (uint64_t *) mem_50455, (int64_t) 0, (int64_t []) {greatest_divisor_leq_than_res_46800, (int64_t) 1}, (int64_t []) {num_blocks_46999, greatest_divisor_leq_than_res_46800});
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
                    if (memblock_alloc(ctx, &mem_50510, bytes_50448, "mem_50510")) {
                        err = 1;
                        goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
                    lmad_copy_8b(ctx, 2, (uint64_t *) mem_50510.mem, (int64_t) 0, (int64_t []) {greatest_divisor_leq_than_res_46800, (int64_t) 1}, (uint64_t *) mem_50452, (int64_t) 0, (int64_t []) {greatest_divisor_leq_than_res_46800, (int64_t) 1}, (int64_t []) {num_blocks_46999, greatest_divisor_leq_than_res_46800});
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
                    if (memblock_alloc(ctx, &mem_50514, bytes_50448, "mem_50514")) {
                        err = 1;
                        goto cleanup;
                    }
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
                    // ../lib/github.com/diku-dk/sorts/merge_sort.fut:155:11-45
                    lmad_copy_8b(ctx, 2, (uint64_t *) mem_50514.mem, (int64_t) 0, (int64_t []) {greatest_divisor_leq_than_res_46800, (int64_t) 1}, (uint64_t *) mem_50449, (int64_t) 0, (int64_t []) {greatest_divisor_leq_than_res_46800, (int64_t) 1}, (int64_t []) {num_blocks_46999, greatest_divisor_leq_than_res_46800});
                    if (memblock_set(ctx, &ext_mem_50548, &mem_50506, "mem_50506") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_50545, &mem_50510, "mem_50510") != 0)
                        return 1;
                    if (memblock_set(ctx, &ext_mem_50542, &mem_50514, "mem_50514") != 0)
                        return 1;
                }
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_50412, i_50033 * next_stride_46980, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_50542.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {next_stride_46980});
                if (memblock_unref(ctx, &ext_mem_50542, "ext_mem_50542") != 0)
                    return 1;
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_50415, i_50033 * next_stride_46980, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_50545.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {next_stride_46980});
                if (memblock_unref(ctx, &ext_mem_50545, "ext_mem_50545") != 0)
                    return 1;
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_50418, i_50033 * next_stride_46980, (int64_t []) {(int64_t) 1}, (uint64_t *) ext_mem_50548.mem, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {next_stride_46980});
                if (memblock_unref(ctx, &ext_mem_50548, "ext_mem_50548") != 0)
                    return 1;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            
            int64_t flat_dim_47412 = next_stride_46980 * num_merges_46984;
            
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            if (memblock_alloc(ctx, &mem_50563, bytes_50411, "mem_50563")) {
                err = 1;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            lmad_copy_8b(ctx, 2, (uint64_t *) mem_50563.mem, (int64_t) 0, (int64_t []) {next_stride_46980, (int64_t) 1}, (uint64_t *) mem_50418, (int64_t) 0, (int64_t []) {next_stride_46980, (int64_t) 1}, (int64_t []) {num_merges_46984, next_stride_46980});
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            if (memblock_alloc(ctx, &mem_50567, bytes_50411, "mem_50567")) {
                err = 1;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            lmad_copy_8b(ctx, 2, (uint64_t *) mem_50567.mem, (int64_t) 0, (int64_t []) {next_stride_46980, (int64_t) 1}, (uint64_t *) mem_50415, (int64_t) 0, (int64_t []) {next_stride_46980, (int64_t) 1}, (int64_t []) {num_merges_46984, next_stride_46980});
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            if (memblock_alloc(ctx, &mem_50571, bytes_50411, "mem_50571")) {
                err = 1;
                goto cleanup;
            }
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:256:9-260:60
            lmad_copy_8b(ctx, 2, (uint64_t *) mem_50571.mem, (int64_t) 0, (int64_t []) {next_stride_46980, (int64_t) 1}, (uint64_t *) mem_50412, (int64_t) 0, (int64_t []) {next_stride_46980, (int64_t) 1}, (int64_t []) {num_merges_46984, next_stride_46980});
            // ../lib/github.com/diku-dk/sorts/merge_sort.fut:252:18-28
            
            bool loop_cond_47416 = slt64(next_stride_46980, flat_dim_46777);
            
            if (memblock_set(ctx, &mem_param_tmp_50867, &mem_50563, "mem_50563") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_50868, &mem_50567, "mem_50567") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_50869, &mem_50571, "mem_50571") != 0)
                return 1;
            
            int64_t loop_dz2084Uz2082U_tmp_50870 = flat_dim_47412;
            bool loop_while_tmp_50871 = loop_cond_47416;
            int64_t stride_tmp_50875 = next_stride_46980;
            
            if (memblock_set(ctx, &mem_param_50403, &mem_param_tmp_50867, "mem_param_tmp_50867") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_50406, &mem_param_tmp_50868, "mem_param_tmp_50868") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_50409, &mem_param_tmp_50869, "mem_param_tmp_50869") != 0)
                return 1;
            loop_dz2084Uz2082U_46974 = loop_dz2084Uz2082U_tmp_50870;
            loop_while_46975 = loop_while_tmp_50871;
            stride_46979 = stride_tmp_50875;
        }
        if (memblock_set(ctx, &ext_mem_50581, &mem_param_50403, "mem_param_50403") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_50580, &mem_param_50406, "mem_param_50406") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_50579, &mem_param_50409, "mem_param_50409") != 0)
            return 1;
        data_46968 = loop_dz2084Uz2082U_46974;
        data_46969 = loop_while_46975;
        data_46973 = stride_46979;
        if (memblock_unref(ctx, &mem_50391, "mem_50391") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50395, "mem_50395") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50399, "mem_50399") != 0)
            return 1;
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:265:3-14
        
        bool i_p_m_t_s_leq_w_47417 = slt64(zp_lhs_48712, data_46968);
        
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:265:3-14
        
        bool ok_or_empty_47419 = empty_slice_46857 || i_p_m_t_s_leq_w_47417;
        
        // ../lib/github.com/diku-dk/sorts/merge_sort.fut:265:3-14
        
        bool index_certs_47420;
        
        if (!ok_or_empty_47419) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, ":", (long long) replicate_arg0_48713, "] out of bounds for array of shape [", (long long) data_46968, "].", "-> #0  ../lib/github.com/diku-dk/sorts/merge_sort.fut:265:3-14\n   #1  ../lib/github.com/diku-dk/sorts/merge_sort.fut:272:3-75\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:75:5-76:19\n   #3  ../lib/github.com/diku-dk/sparse/mono.fut:89:5-17\n   #4  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #5  trmodel.fut:375:19-85\n   #6  trmodel_test.fut:33:16-34:24\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        if (memblock_set(ctx, &ext_mem_50590, &ext_mem_50581, "ext_mem_50581") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_50587, &ext_mem_50580, "ext_mem_50580") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_50584, &ext_mem_50579, "ext_mem_50579") != 0)
            return 1;
    }
    if (memblock_unref(ctx, &mem_50282, "mem_50282") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50284, "mem_50284") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50286, "mem_50286") != 0)
        return 1;
    // ../lib/github.com/diku-dk/sparse/mono.fut:79:17-81:38
    if (mem_50591_cached_sizze_51088 < replicate_arg0_48713) {
        err = lexical_realloc(ctx, &mem_50591, &mem_50591_cached_sizze_51088, replicate_arg0_48713);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // ../lib/github.com/diku-dk/sparse/mono.fut:79:17-81:38
    for (int64_t i_50039 = 0; i_50039 < replicate_arg0_48713; i_50039++) {
        int64_t eta_p_49141 = ((int64_t *) ext_mem_50590.mem)[i_50039];
        int64_t eta_p_49142 = ((int64_t *) ext_mem_50587.mem)[i_50039];
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:81:23-38
        
        int64_t zv_lhs_49143 = add64((int64_t) -1, i_50039);
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:81:23-38
        
        int64_t tmp_49144 = smod64(zv_lhs_49143, replicate_arg0_48713);
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:81:23-38
        
        int64_t lifted_lambda_res_49145 = ((int64_t *) ext_mem_50590.mem)[tmp_49144];
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:81:23-38
        
        int64_t lifted_lambda_res_49146 = ((int64_t *) ext_mem_50587.mem)[tmp_49144];
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:79:47-63
        
        bool cond_49149 = eta_p_49141 == lifted_lambda_res_49145;
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:79:47-63
        
        bool cond_49150 = !cond_49149;
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:79:59-63
        
        bool lifted_lambda_res_f_res_49151 = eta_p_49142 == lifted_lambda_res_49146;
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:79:59-63
        
        bool lifted_lambda_res_f_res_49152 = !lifted_lambda_res_f_res_49151;
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:79:17-81:38
        
        bool y_49153 = cond_49149 && lifted_lambda_res_f_res_49152;
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:79:17-81:38
        
        bool lifted_lambda_res_49154 = cond_49150 || y_49153;
        
        ((bool *) mem_50591)[i_50039] = lifted_lambda_res_49154;
    }
    // ../lib/github.com/diku-dk/sparse/mono.fut:82:17-83:27
    
    bool cond_47442 = sle64((int64_t) 1, replicate_arg0_48713);
    
    // ../lib/github.com/diku-dk/sparse/mono.fut:89:18-30
    
    bool loop_not_taken_47443 = !cond_47442;
    
    // ../lib/github.com/diku-dk/sparse/mono.fut:89:18-30
    
    bool protect_assert_disj_47444 = y_46801 || loop_not_taken_47443;
    
    // ../lib/github.com/diku-dk/sparse/mono.fut:82:34-55
    
    bool index_certs_47445;
    
    if (!protect_assert_disj_47444) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) (int64_t) 0, "] out of bounds for array of shape [", (long long) replicate_arg0_48713, "].", "-> #0  ../lib/github.com/diku-dk/sparse/mono.fut:82:34-55\n   #1  ../lib/github.com/diku-dk/sparse/mono.fut:89:21-30\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #3  trmodel.fut:375:19-85\n   #4  trmodel_test.fut:33:16-34:24\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // ../lib/github.com/diku-dk/sparse/mono.fut:82:17-83:27
    if (cond_47442) {
        // ../lib/github.com/diku-dk/sparse/mono.fut:82:34-55
        ((bool *) mem_50591)[(int64_t) 0] = 1;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:21:38-28:71
    if (mem_50599_cached_sizze_51089 < bytes_50281) {
        err = lexical_realloc(ctx, &mem_50599, &mem_50599_cached_sizze_51089, bytes_50281);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:21:38-28:71
    if (mem_50600_cached_sizze_51090 < replicate_arg0_48713) {
        err = lexical_realloc(ctx, &mem_50600, &mem_50600_cached_sizze_51090, replicate_arg0_48713);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:21:38-28:71
    
    int64_t discard_50049;
    int64_t scanacc_50043 = (int64_t) 0;
    
    for (int64_t i_50046 = 0; i_50046 < replicate_arg0_48713; i_50046++) {
        // ../lib/github.com/diku-dk/segmented/segmented.fut:26:22-36
        
        int64_t zv_lhs_48814 = add64((int64_t) 1, i_50046);
        
        // ../lib/github.com/diku-dk/segmented/segmented.fut:26:22-36
        
        int64_t tmp_48815 = smod64(zv_lhs_48814, replicate_arg0_48713);
        
        // ../lib/github.com/diku-dk/segmented/segmented.fut:26:22-36
        
        bool lifted_lambda_res_48816 = ((bool *) mem_50591)[tmp_48815];
        
        // ../lib/github.com/diku-dk/segmented/segmented.fut:28:49-57
        
        int64_t bool_res_48818 = btoi_bool_i64(lifted_lambda_res_48816);
        
        // ../lib/github.com/diku-dk/segmented/segmented.fut:28:66-69
        
        int64_t defunc_0_op_res_47481 = add64(bool_res_48818, scanacc_50043);
        
        ((int64_t *) mem_50599)[i_50046] = defunc_0_op_res_47481;
        ((bool *) mem_50600)[i_50046] = lifted_lambda_res_48816;
        
        int64_t scanacc_tmp_50905 = defunc_0_op_res_47481;
        
        scanacc_50043 = scanacc_tmp_50905;
    }
    discard_50049 = scanacc_50043;
    // ../lib/github.com/diku-dk/segmented/segmented.fut:29:36-60
    
    int64_t num_segments_t_res_47482;
    
    if (y_46801) {
        // ../lib/github.com/diku-dk/sparse/mono.fut:85:8-86:49
        
        bool y_49841 = slt64(zp_lhs_48712, replicate_arg0_48713);
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:85:8-86:49
        
        bool index_certs_49842;
        
        if (!y_49841) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) zp_lhs_48712, "] out of bounds for array of shape [", (long long) replicate_arg0_48713, "].", "-> #0  ../lib/github.com/diku-dk/sparse/mono.fut:85:8-86:49\n   #1  ../lib/github.com/diku-dk/sparse/mono.fut:89:21-30\n   #2  ../lib/github.com/diku-dk/sparse/mono.fut:120:34-46\n   #3  trmodel.fut:375:19-85\n   #4  trmodel_test.fut:33:16-34:24\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        // ../lib/github.com/diku-dk/sparse/mono.fut:85:8-86:49
        
        int64_t last_res_49843 = ((int64_t *) mem_50599)[zp_lhs_48712];
        
        num_segments_t_res_47482 = last_res_49843;
    } else {
        num_segments_t_res_47482 = (int64_t) 0;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:29:22-67
    
    int64_t num_segments_47487;
    
    if (y_46801) {
        num_segments_47487 = num_segments_t_res_47482;
    } else {
        num_segments_47487 = (int64_t) 0;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:33:17-42
    
    int64_t bytes_50613 = (int64_t) 8 * num_segments_47487;
    
    // ../lib/github.com/diku-dk/sparse/mono.fut:113:15-48
    
    int64_t bytes_50624 = replicate_arg0_48713 * bytes_50281;
    
    // ../lib/github.com/diku-dk/segmented/segmented.fut:33:17-42
    if (mem_50614_cached_sizze_51091 < bytes_50613) {
        err = lexical_realloc(ctx, &mem_50614, &mem_50614_cached_sizze_51091, bytes_50613);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:33:17-42
    for (int64_t nest_i_50908 = 0; nest_i_50908 < num_segments_47487; nest_i_50908++) {
        ((double *) mem_50614)[nest_i_50908] = 0.0;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:33:17-42
    if (mem_50616_cached_sizze_51092 < bytes_50613) {
        err = lexical_realloc(ctx, &mem_50616, &mem_50616_cached_sizze_51092, bytes_50613);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:33:17-42
    for (int64_t nest_i_50909 = 0; nest_i_50909 < num_segments_47487; nest_i_50909++) {
        ((int64_t *) mem_50616)[nest_i_50909] = (int64_t) 0;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:33:17-42
    if (mem_50618_cached_sizze_51093 < bytes_50613) {
        err = lexical_realloc(ctx, &mem_50618, &mem_50618_cached_sizze_51093, bytes_50613);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:33:17-42
    for (int64_t nest_i_50910 = 0; nest_i_50910 < num_segments_47487; nest_i_50910++) {
        ((int64_t *) mem_50618)[nest_i_50910] = (int64_t) 0;
    }
    // ../lib/github.com/diku-dk/segmented/segmented.fut:37:6-71
    
    bool acc_cert_48825;
    bool acc_cert_48826;
    bool acc_cert_48827;
    
    // ../lib/github.com/diku-dk/segmented/segmented.fut:37:6-71
    
    int64_t inpacc_49830;
    int64_t inpacc_49831;
    double inpacc_49832;
    int64_t inpacc_48978;
    int64_t inpacc_48979;
    double inpacc_48980;
    
    inpacc_48978 = (int64_t) 0;
    inpacc_48979 = (int64_t) 0;
    inpacc_48980 = 0.0;
    for (int64_t i_50103 = 0; i_50103 < replicate_arg0_48713; i_50103++) {
        bool x_50163 = ((bool *) mem_50591)[i_50103];
        int64_t x_50164 = ((int64_t *) ext_mem_50590.mem)[i_50103];
        int64_t x_50165 = ((int64_t *) ext_mem_50587.mem)[i_50103];
        double x_50166 = ((double *) ext_mem_50584.mem)[i_50103];
        
        // ../lib/github.com/diku-dk/segmented/segmented.fut:9:11-13:24
        
        int64_t tmp_50176;
        
        if (x_50163) {
            tmp_50176 = x_50164;
        } else {
            tmp_50176 = (int64_t) 0;
        }
        // ../lib/github.com/diku-dk/segmented/segmented.fut:9:11-13:24
        
        int64_t tmp_50177;
        
        if (x_50163) {
            tmp_50177 = x_50165;
        } else {
            tmp_50177 = (int64_t) 0;
        }
        
        int64_t eta_p_50197 = ((int64_t *) mem_50599)[i_50103];
        bool eta_p_50198 = ((bool *) mem_50600)[i_50103];
        
        // ../lib/github.com/diku-dk/segmented/segmented.fut:9:11-13:24
        
        int64_t tmp_50203;
        
        if (x_50163) {
            tmp_50203 = tmp_50176;
        } else {
            tmp_50203 = inpacc_48978;
        }
        // ../lib/github.com/diku-dk/segmented/segmented.fut:9:11-13:24
        
        int64_t tmp_50204;
        
        if (x_50163) {
            tmp_50204 = tmp_50177;
        } else {
            tmp_50204 = inpacc_48979;
        }
        // ../lib/github.com/diku-dk/segmented/segmented.fut:9:11-13:24
        
        double tmp_50205;
        
        if (x_50163) {
            tmp_50205 = x_50166;
        } else {
            // ../lib/github.com/diku-dk/sparse/mono.fut:85:57-66
            
            double zp_res_50206 = inpacc_48980 + x_50166;
            
            tmp_50205 = zp_res_50206;
        }
        // ../lib/github.com/diku-dk/segmented/segmented.fut:36:19-40
        
        int64_t lifted_index_res_50207;
        
        if (eta_p_50198) {
            // ../lib/github.com/diku-dk/segmented/segmented.fut:36:30-32
            
            int64_t lifted_index_res_t_res_50208 = sub64(eta_p_50197, (int64_t) 1);
            
            lifted_index_res_50207 = lifted_index_res_t_res_50208;
        } else {
            lifted_index_res_50207 = (int64_t) -1;
        }
        // ../lib/github.com/diku-dk/segmented/segmented.fut:37:6-71
        // UpdateAcc
        if (sle64((int64_t) 0, lifted_index_res_50207) && slt64(lifted_index_res_50207, num_segments_47487)) {
            ((int64_t *) mem_50618)[lifted_index_res_50207] = tmp_50203;
        }
        // ../lib/github.com/diku-dk/segmented/segmented.fut:37:6-71
        // UpdateAcc
        if (sle64((int64_t) 0, lifted_index_res_50207) && slt64(lifted_index_res_50207, num_segments_47487)) {
            ((int64_t *) mem_50616)[lifted_index_res_50207] = tmp_50204;
        }
        // ../lib/github.com/diku-dk/segmented/segmented.fut:37:6-71
        // UpdateAcc
        if (sle64((int64_t) 0, lifted_index_res_50207) && slt64(lifted_index_res_50207, num_segments_47487)) {
            ((double *) mem_50614)[lifted_index_res_50207] = tmp_50205;
        }
        // ../lib/github.com/diku-dk/segmented/segmented.fut:9:11-13:24
        
        double tmp_49049;
        
        if (x_50163) {
            tmp_49049 = x_50166;
        } else {
            // ../lib/github.com/diku-dk/sparse/mono.fut:85:57-66
            
            double zp_res_49050 = inpacc_48980 + x_50166;
            
            tmp_49049 = zp_res_49050;
        }
        
        int64_t inpacc_tmp_50911 = tmp_50203;
        int64_t inpacc_tmp_50912 = tmp_50204;
        double inpacc_tmp_50913 = tmp_49049;
        
        inpacc_48978 = inpacc_tmp_50911;
        inpacc_48979 = inpacc_tmp_50912;
        inpacc_48980 = inpacc_tmp_50913;
    }
    inpacc_49830 = inpacc_48978;
    inpacc_49831 = inpacc_48979;
    inpacc_49832 = inpacc_48980;
    if (memblock_unref(ctx, &ext_mem_50584, "ext_mem_50584") != 0)
        return 1;
    if (memblock_unref(ctx, &ext_mem_50587, "ext_mem_50587") != 0)
        return 1;
    if (memblock_unref(ctx, &ext_mem_50590, "ext_mem_50590") != 0)
        return 1;
    // ../lib/github.com/diku-dk/sparse/mono.fut:127:27-47
    if (mem_50620_cached_sizze_51094 < bytes_50281) {
        err = lexical_realloc(ctx, &mem_50620, &mem_50620_cached_sizze_51094, bytes_50281);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // ../lib/github.com/diku-dk/sparse/mono.fut:127:27-47
    for (int64_t nest_i_50917 = 0; nest_i_50917 < replicate_arg0_48713; nest_i_50917++) {
        ((double *) mem_50620)[nest_i_50917] = 0.0;
    }
    // ../lib/github.com/diku-dk/sparse/mono.fut:128:30-43
    if (mem_50622_cached_sizze_51095 < bytes_50281) {
        err = lexical_realloc(ctx, &mem_50622, &mem_50622_cached_sizze_51095, bytes_50281);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // ../lib/github.com/diku-dk/sparse/mono.fut:128:30-43
    for (int64_t nest_i_50918 = 0; nest_i_50918 < replicate_arg0_48713; nest_i_50918++) {
        ((int64_t *) mem_50622)[nest_i_50918] = (int64_t) 0;
    }
    // ../lib/github.com/diku-dk/sparse/mono.fut:127:18-128:50
    
    bool acc_cert_47520;
    bool acc_cert_47529;
    
    // ../lib/github.com/diku-dk/sparse/mono.fut:127:18-128:50
    for (int64_t i_50111 = 0; i_50111 < num_segments_47487; i_50111++) {
        int64_t v_49450 = ((int64_t *) mem_50618)[i_50111];
        double v_49451 = ((double *) mem_50614)[i_50111];
        int64_t v_49453 = ((int64_t *) mem_50616)[i_50111];
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:127:18-54
        // UpdateAcc
        if (sle64((int64_t) 0, v_49450) && slt64(v_49450, replicate_arg0_48713)) {
            ((double *) mem_50620)[v_49450] = v_49451;
        }
        // ../lib/github.com/diku-dk/sparse/mono.fut:128:21-50
        // UpdateAcc
        if (sle64((int64_t) 0, v_49450) && slt64(v_49450, replicate_arg0_48713)) {
            ((int64_t *) mem_50622)[v_49450] = v_49453;
        }
    }
    // ../lib/github.com/diku-dk/sparse/mono.fut:113:15-48
    if (memblock_alloc(ctx, &mem_50625, bytes_50624, "mem_50625")) {
        err = 1;
        goto cleanup;
    }
    // ../lib/github.com/diku-dk/sparse/mono.fut:113:15-48
    for (int64_t nest_i_50921 = 0; nest_i_50921 < replicate_arg0_48713; nest_i_50921++) {
        for (int64_t nest_i_50922 = 0; nest_i_50922 < replicate_arg0_48713; nest_i_50922++) {
            ((double *) mem_50625.mem)[nest_i_50921 * replicate_arg0_48713 + nest_i_50922] = 0.0;
        }
    }
    // ../lib/github.com/diku-dk/sparse/mono.fut:114:10-50
    
    bool acc_cert_48729;
    
    // ../lib/github.com/diku-dk/sparse/mono.fut:114:10-50
    for (int64_t i_50113 = 0; i_50113 < replicate_arg0_48713; i_50113++) {
        int64_t v_48734 = ((int64_t *) mem_50622)[i_50113];
        double v_48735 = ((double *) mem_50620)[i_50113];
        
        // ../lib/github.com/diku-dk/sparse/mono.fut:114:10-50
        // UpdateAcc
        if ((sle64((int64_t) 0, i_50113) && slt64(i_50113, replicate_arg0_48713)) && (sle64((int64_t) 0, v_48734) && slt64(v_48734, replicate_arg0_48713))) {
            ((double *) mem_50625.mem)[i_50113 * replicate_arg0_48713 + v_48734] = v_48735;
        }
    }
    if (memblock_set(ctx, &mem_out_50838, &mem_50625, "mem_50625") != 0)
        return 1;
    prim_out_50839 = replicate_arg0_48713;
    if (memblock_set(ctx, &*mem_out_p_51069, &mem_out_50838, "mem_out_50838") != 0)
        return 1;
    *out_prim_out_51070 = prim_out_50839;
    
  cleanup:
    {
        free(mem_50259);
        free(mem_50278);
        free(mem_50280);
        free(mem_50289);
        free(mem_50292);
        free(mem_50295);
        free(mem_50309);
        free(mem_50311);
        free(mem_50313);
        free(mem_50412);
        free(mem_50415);
        free(mem_50418);
        free(mem_50432);
        free(mem_50434);
        free(mem_50449);
        free(mem_50452);
        free(mem_50455);
        free(mem_50591);
        free(mem_50599);
        free(mem_50600);
        free(mem_50614);
        free(mem_50616);
        free(mem_50618);
        free(mem_50620);
        free(mem_50622);
        if (memblock_unref(ctx, &mem_50625, "mem_50625") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_50869, "mem_param_tmp_50869") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_50868, "mem_param_tmp_50868") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_50867, "mem_param_tmp_50867") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50571, "mem_50571") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50567, "mem_50567") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50563, "mem_50563") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50514, "mem_50514") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50510, "mem_50510") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50506, "mem_50506") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50521, "mem_50521") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50519, "mem_50519") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50517, "mem_50517") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50542, "ext_mem_50542") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50545, "ext_mem_50545") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50548, "ext_mem_50548") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_50409, "mem_param_50409") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_50406, "mem_param_50406") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_50403, "mem_param_50403") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50579, "ext_mem_50579") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50580, "ext_mem_50580") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50581, "ext_mem_50581") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50399, "mem_50399") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50395, "mem_50395") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50391, "mem_50391") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50584, "ext_mem_50584") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50587, "ext_mem_50587") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_50590, "ext_mem_50590") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50286, "mem_50286") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50284, "mem_50284") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50282, "mem_50282") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_50838, "mem_out_50838") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_test_simple_prices(struct futhark_context *ctx, struct memblock *mem_out_p_51096, struct memblock newprices_mem_50257, int64_t c_22326, int64_t n_22327, int64_t Ax_22329)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_50259_cached_sizze_51097 = 0;
    unsigned char *mem_50259 = NULL;
    int64_t mem_50268_cached_sizze_51098 = 0;
    unsigned char *mem_50268 = NULL;
    struct memblock mem_50287;
    
    mem_50287.references = NULL;
    
    struct memblock mem_out_50838;
    
    mem_out_50838.references = NULL;
    // trmodel.fut:180:61-65
    
    int64_t dzlz7bUZLzmZRz20UAxz20U1z7dUzg_39263 = sub64(Ax_22329, (int64_t) 1);
    
    // trmodel.fut:180:28-68
    
    int64_t bytes_50258 = (int64_t) 8 * dzlz7bUZLzmZRz20UAxz20U1z7dUzg_39263;
    
    // trmodel.fut:180:75-181:53
    
    int64_t binop_x_50266 = (int64_t) 8 * c_22326;
    
    // trmodel.fut:180:75-181:53
    
    int64_t bytes_50267 = Ax_22329 * binop_x_50266;
    int64_t binop_x_50285 = (int64_t) 8 * Ax_22329;
    int64_t bytes_50286 = c_22326 * binop_x_50285;
    
    // trmodel.fut:180:28-68
    if (mem_50259_cached_sizze_51097 < bytes_50258) {
        err = lexical_realloc(ctx, &mem_50259, &mem_50259_cached_sizze_51097, bytes_50258);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:180:28-68
    
    double discard_49983;
    double scanacc_49979 = 1.0;
    
    for (int64_t i_49981 = 0; i_49981 < dzlz7bUZLzmZRz20UAxz20U1z7dUzg_39263; i_49981++) {
        // trmodel.fut:180:33-38
        
        double zt_res_39269 = 0.85 * scanacc_49979;
        
        ((double *) mem_50259)[i_49981] = zt_res_39269;
        
        double scanacc_tmp_50839 = zt_res_39269;
        
        scanacc_49979 = scanacc_tmp_50839;
    }
    discard_49983 = scanacc_49979;
    // trmodel.fut:180:75-181:53
    if (mem_50268_cached_sizze_51098 < bytes_50267) {
        err = lexical_realloc(ctx, &mem_50268, &mem_50268_cached_sizze_51098, bytes_50267);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:180:75-181:53
    for (int64_t i_49990 = 0; i_49990 < c_22326; i_49990++) {
        double eta_p_39273 = ((double *) newprices_mem_50257.mem)[i_49990];
        
        // trmodel.fut:181:30-44
        for (int64_t i_49986 = 0; i_49986 < Ax_22329; i_49986++) {
            bool index_concat_cmp_50153 = sle64((int64_t) 1, i_49986);
            double index_concat_branch_50157;
            
            if (index_concat_cmp_50153) {
                int64_t index_concat_i_50154 = sub64(i_49986, (int64_t) 1);
                double index_concat_50155 = ((double *) mem_50259)[index_concat_i_50154];
                
                index_concat_branch_50157 = index_concat_50155;
            } else {
                index_concat_branch_50157 = 1.0;
            }
            // trmodel.fut:181:34-41
            
            double zt_res_39276 = eta_p_39273 * index_concat_branch_50157;
            
            ((double *) mem_50268)[i_49990 * Ax_22329 + i_49986] = zt_res_39276;
        }
    }
    if (memblock_alloc(ctx, &mem_50287, bytes_50286, "mem_50287")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_8b(ctx, 2, (uint64_t *) mem_50287.mem, (int64_t) 0, (int64_t []) {c_22326, (int64_t) 1}, (uint64_t *) mem_50268, (int64_t) 0, (int64_t []) {(int64_t) 1, Ax_22329}, (int64_t []) {Ax_22329, c_22326});
    if (memblock_set(ctx, &mem_out_50838, &mem_50287, "mem_50287") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_51096, &mem_out_50838, "mem_out_50838") != 0)
        return 1;
    
  cleanup:
    {
        free(mem_50259);
        free(mem_50268);
        if (memblock_unref(ctx, &mem_50287, "mem_50287") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_50838, "mem_out_50838") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_test_trade(struct futhark_context *ctx, struct memblock *mem_out_p_51099, int64_t *out_prim_out_51100, int64_t n_26698, int64_t c_26699, int64_t Ax_26700)
{
    (void) ctx;
    
    int err = 0;
    struct memblock mem_50259;
    
    mem_50259.references = NULL;
    
    struct memblock mem_out_50838;
    
    mem_out_50838.references = NULL;
    
    int64_t prim_out_50839;
    
    // trmodel.fut:133:36-39
    
    int64_t zp_lhs_48712 = mul64(c_26699, Ax_26700);
    
    // trmodel.fut:133:39-41
    
    int64_t replicate_arg0_48713 = add64((int64_t) 1, zp_lhs_48712);
    
    // ../lib/github.com/diku-dk/sparse/mono.fut:113:15-48
    
    int64_t binop_x_50257 = (int64_t) 8 * replicate_arg0_48713;
    
    // ../lib/github.com/diku-dk/sparse/mono.fut:113:15-48
    
    int64_t bytes_50258 = replicate_arg0_48713 * binop_x_50257;
    
    // ../lib/github.com/diku-dk/sparse/mono.fut:113:15-48
    if (memblock_alloc(ctx, &mem_50259, bytes_50258, "mem_50259")) {
        err = 1;
        goto cleanup;
    }
    // ../lib/github.com/diku-dk/sparse/mono.fut:113:15-48
    for (int64_t nest_i_50840 = 0; nest_i_50840 < replicate_arg0_48713; nest_i_50840++) {
        for (int64_t nest_i_50841 = 0; nest_i_50841 < replicate_arg0_48713; nest_i_50841++) {
            ((double *) mem_50259.mem)[nest_i_50840 * replicate_arg0_48713 + nest_i_50841] = 0.0;
        }
    }
    // ../lib/github.com/diku-dk/sparse/mono.fut:114:10-50
    
    bool acc_cert_48729;
    
    // ../lib/github.com/diku-dk/sparse/mono.fut:114:10-50
    for (int64_t i_49979 = 0; i_49979 < replicate_arg0_48713; i_49979++) {
        // ../lib/github.com/diku-dk/sparse/mono.fut:114:10-50
        // UpdateAcc
        if ((sle64((int64_t) 0, i_49979) && slt64(i_49979, replicate_arg0_48713)) && (sle64((int64_t) 0, i_49979) && slt64(i_49979, replicate_arg0_48713))) {
            ((double *) mem_50259.mem)[i_49979 * replicate_arg0_48713 + i_49979] = 1.0;
        }
    }
    if (memblock_set(ctx, &mem_out_50838, &mem_50259, "mem_50259") != 0)
        return 1;
    prim_out_50839 = replicate_arg0_48713;
    if (memblock_set(ctx, &*mem_out_p_51099, &mem_out_50838, "mem_out_50838") != 0)
        return 1;
    *out_prim_out_51100 = prim_out_50839;
    
  cleanup:
    {
        if (memblock_unref(ctx, &mem_50259, "mem_50259") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_50838, "mem_out_50838") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_test_utility(struct futhark_context *ctx, struct memblock *mem_out_p_51101, int64_t *out_prim_out_51102, int64_t *out_prim_out_51103, struct memblock newprices_mem_50257, int64_t c_35101, int64_t n_35102, int64_t Ax_35104)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_50285_cached_sizze_51104 = 0;
    unsigned char *mem_50285 = NULL;
    int64_t mem_50294_cached_sizze_51105 = 0;
    unsigned char *mem_50294 = NULL;
    struct memblock ext_mem_50315;
    
    ext_mem_50315.references = NULL;
    
    struct memblock mem_50313;
    
    mem_50313.references = NULL;
    
    struct memblock mem_50283;
    
    mem_50283.references = NULL;
    
    struct memblock mem_50281;
    
    mem_50281.references = NULL;
    
    struct memblock mem_50279;
    
    mem_50279.references = NULL;
    
    struct memblock mem_50277;
    
    mem_50277.references = NULL;
    
    struct memblock mem_50276;
    
    mem_50276.references = NULL;
    
    struct memblock mem_50275;
    
    mem_50275.references = NULL;
    
    struct memblock mem_50274;
    
    mem_50274.references = NULL;
    
    struct memblock mem_50271;
    
    mem_50271.references = NULL;
    
    struct memblock mem_50268;
    
    mem_50268.references = NULL;
    
    struct memblock mem_50265;
    
    mem_50265.references = NULL;
    
    struct memblock mem_50263;
    
    mem_50263.references = NULL;
    
    struct memblock mem_50261;
    
    mem_50261.references = NULL;
    
    struct memblock mem_50259;
    
    mem_50259.references = NULL;
    
    struct memblock mem_out_50838;
    
    mem_out_50838.references = NULL;
    
    int64_t prim_out_50839;
    int64_t prim_out_50840;
    
    // trmodel.fut:123:24-46
    
    int64_t bytes_50258 = (int64_t) 8 * n_35102;
    
    // trmodel.fut:126:24-44
    
    int64_t bytes_50262 = (int64_t) 8 * c_35101;
    
    // trmodel_test.fut:131:49-62
    
    int64_t bytes_50267 = c_35101 * bytes_50258;
    
    // trmodel.fut:180:61-65
    
    int64_t dzlz7bUZLzmZRz20UAxz20U1z7dUzg_39282 = sub64(Ax_35104, (int64_t) 1);
    
    // trmodel.fut:180:28-68
    
    int64_t bytes_50284 = (int64_t) 8 * dzlz7bUZLzmZRz20UAxz20U1z7dUzg_39282;
    
    // trmodel.fut:180:75-181:53
    
    int64_t bytes_50293 = Ax_35104 * bytes_50262;
    
    // trmodel_test.fut:132:7-135:26
    
    int64_t binop_x_50311 = (int64_t) 8 * Ax_35104;
    
    // trmodel_test.fut:132:7-135:26
    
    int64_t bytes_50312 = c_35101 * binop_x_50311;
    
    // trmodel.fut:123:24-46
    if (memblock_alloc(ctx, &mem_50259, bytes_50258, "mem_50259")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:123:24-46
    for (int64_t nest_i_50841 = 0; nest_i_50841 < n_35102; nest_i_50841++) {
        ((double *) mem_50259.mem)[nest_i_50841] = 0.10000000149011612;
    }
    // trmodel.fut:124:47-52
    
    double i64_res_48703 = sitofp_i64_f64(n_35102);
    
    // trmodel.fut:124:39-52
    
    double zs_res_48704 = 1.0 / i64_res_48703;
    
    // trmodel.fut:124:24-52
    if (memblock_alloc(ctx, &mem_50261, bytes_50258, "mem_50261")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:124:24-52
    for (int64_t nest_i_50842 = 0; nest_i_50842 < n_35102; nest_i_50842++) {
        ((double *) mem_50261.mem)[nest_i_50842] = zs_res_48704;
    }
    // trmodel.fut:126:24-44
    if (memblock_alloc(ctx, &mem_50263, bytes_50262, "mem_50263")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:126:24-44
    for (int64_t nest_i_50843 = 0; nest_i_50843 < c_35101; nest_i_50843++) {
        ((double *) mem_50263.mem)[nest_i_50843] = 1.0;
    }
    // trmodel.fut:127:24-44
    if (memblock_alloc(ctx, &mem_50265, bytes_50258, "mem_50265")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:127:24-44
    for (int64_t nest_i_50844 = 0; nest_i_50844 < n_35102; nest_i_50844++) {
        ((double *) mem_50265.mem)[nest_i_50844] = 0.0;
    }
    // trmodel_test.fut:131:49-62
    if (memblock_alloc(ctx, &mem_50268, bytes_50267, "mem_50268")) {
        err = 1;
        goto cleanup;
    }
    // trmodel_test.fut:131:49-62
    for (int64_t nest_i_50845 = 0; nest_i_50845 < n_35102; nest_i_50845++) {
        for (int64_t nest_i_50846 = 0; nest_i_50846 < c_35101; nest_i_50846++) {
            ((double *) mem_50268.mem)[nest_i_50845 * c_35101 + nest_i_50846] = 6.0;
        }
    }
    // trmodel_test.fut:131:49-62
    if (memblock_alloc(ctx, &mem_50271, bytes_50267, "mem_50271")) {
        err = 1;
        goto cleanup;
    }
    // trmodel_test.fut:131:49-62
    for (int64_t nest_i_50847 = 0; nest_i_50847 < n_35102; nest_i_50847++) {
        for (int64_t nest_i_50848 = 0; nest_i_50848 < c_35101; nest_i_50848++) {
            ((double *) mem_50271.mem)[nest_i_50847 * c_35101 + nest_i_50848] = -0.5;
        }
    }
    // trmodel_test.fut:131:49-62
    if (memblock_alloc(ctx, &mem_50274, bytes_50267, "mem_50274")) {
        err = 1;
        goto cleanup;
    }
    // trmodel_test.fut:131:49-62
    for (int64_t nest_i_50849 = 0; nest_i_50849 < n_35102; nest_i_50849++) {
        for (int64_t nest_i_50850 = 0; nest_i_50850 < c_35101; nest_i_50850++) {
            ((double *) mem_50274.mem)[nest_i_50849 * c_35101 + nest_i_50850] = 0.0;
        }
    }
    // trmodel.fut:133:36-39
    
    int64_t zp_lhs_48712 = mul64(c_35101, Ax_35104);
    
    // trmodel.fut:133:39-41
    
    int64_t replicate_arg0_48713 = add64((int64_t) 1, zp_lhs_48712);
    
    // trmodel.fut:133:24-45
    if (memblock_alloc(ctx, &mem_50275, (int64_t) 0, "mem_50275")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:133:24-45
    for (int64_t nest_i_50851 = 0; nest_i_50851 < replicate_arg0_48713; nest_i_50851++) { }
    // trmodel.fut:134:39-41
    
    int64_t replicate_arg0_48715 = add64((int64_t) 2, zp_lhs_48712);
    
    // trmodel.fut:134:24-45
    if (memblock_alloc(ctx, &mem_50276, (int64_t) 0, "mem_50276")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:134:24-45
    for (int64_t nest_i_50852 = 0; nest_i_50852 < replicate_arg0_48715; nest_i_50852++) { }
    // trmodel.fut:135:24-39
    if (memblock_alloc(ctx, &mem_50277, (int64_t) 0, "mem_50277")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:135:24-39
    for (int64_t nest_i_50853 = 0; nest_i_50853 < Ax_35104; nest_i_50853++) { }
    // trmodel.fut:136:24-48
    if (memblock_alloc(ctx, &mem_50279, bytes_50262, "mem_50279")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:136:24-48
    for (int64_t nest_i_50854 = 0; nest_i_50854 < c_35101; nest_i_50854++) {
        ((double *) mem_50279.mem)[nest_i_50854] = -10.0;
    }
    // trmodel.fut:137:24-44
    if (memblock_alloc(ctx, &mem_50281, bytes_50262, "mem_50281")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:137:24-44
    for (int64_t nest_i_50855 = 0; nest_i_50855 < c_35101; nest_i_50855++) {
        ((double *) mem_50281.mem)[nest_i_50855] = 0.0;
    }
    // trmodel.fut:138:24-44
    if (memblock_alloc(ctx, &mem_50283, bytes_50262, "mem_50283")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:138:24-44
    for (int64_t nest_i_50856 = 0; nest_i_50856 < c_35101; nest_i_50856++) {
        ((double *) mem_50283.mem)[nest_i_50856] = 0.0;
    }
    // trmodel.fut:180:28-68
    if (mem_50285_cached_sizze_51104 < bytes_50284) {
        err = lexical_realloc(ctx, &mem_50285, &mem_50285_cached_sizze_51104, bytes_50284);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:180:28-68
    
    double discard_49983;
    double scanacc_49979 = 1.0;
    
    for (int64_t i_49981 = 0; i_49981 < dzlz7bUZLzmZRz20UAxz20U1z7dUzg_39282; i_49981++) {
        // trmodel.fut:180:33-38
        
        double zt_res_39288 = 0.85 * scanacc_49979;
        
        ((double *) mem_50285)[i_49981] = zt_res_39288;
        
        double scanacc_tmp_50857 = zt_res_39288;
        
        scanacc_49979 = scanacc_tmp_50857;
    }
    discard_49983 = scanacc_49979;
    // trmodel.fut:180:75-181:53
    if (mem_50294_cached_sizze_51105 < bytes_50293) {
        err = lexical_realloc(ctx, &mem_50294, &mem_50294_cached_sizze_51105, bytes_50293);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:180:75-181:53
    for (int64_t i_49990 = 0; i_49990 < c_35101; i_49990++) {
        double eta_p_39292 = ((double *) newprices_mem_50257.mem)[i_49990];
        
        // trmodel.fut:181:30-44
        for (int64_t i_49986 = 0; i_49986 < Ax_35104; i_49986++) {
            bool index_concat_cmp_50153 = sle64((int64_t) 1, i_49986);
            double index_concat_branch_50157;
            
            if (index_concat_cmp_50153) {
                int64_t index_concat_i_50154 = sub64(i_49986, (int64_t) 1);
                double index_concat_50155 = ((double *) mem_50285)[index_concat_i_50154];
                
                index_concat_branch_50157 = index_concat_50155;
            } else {
                index_concat_branch_50157 = 1.0;
            }
            // trmodel.fut:181:34-41
            
            double zt_res_39295 = eta_p_39292 * index_concat_branch_50157;
            
            ((double *) mem_50294)[i_49990 * Ax_35104 + i_49986] = zt_res_39295;
        }
    }
    // trmodel_test.fut:132:7-135:26
    if (memblock_alloc(ctx, &mem_50313, bytes_50312, "mem_50313")) {
        err = 1;
        goto cleanup;
    }
    // trmodel_test.fut:132:7-135:26
    // trmodel_test.fut:132:7-135:26
    lmad_copy_8b(ctx, 2, (uint64_t *) mem_50313.mem, (int64_t) 0, (int64_t []) {c_35101, (int64_t) 1}, (uint64_t *) mem_50294, (int64_t) 0, (int64_t []) {(int64_t) 1, Ax_35104}, (int64_t []) {Ax_35104, c_35101});
    // trmodel_test.fut:132:7-135:26
    if (futrts_utility_10336(ctx, &ext_mem_50315, mem_50279, mem_50281, mem_50283, mem_50277, mem_50259, mem_50276, mem_50275, newprices_mem_50257, mem_50263, mem_50265, mem_50261, mem_50268, mem_50271, mem_50274, mem_50313, n_35102, c_35101, Ax_35104, replicate_arg0_48713, replicate_arg0_48715, 0.949999988079071, 1.0, 0.5, (int64_t) 1) != 0) {
        err = 1;
        goto cleanup;
    }
    if (memblock_unref(ctx, &mem_50259, "mem_50259") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50261, "mem_50261") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50263, "mem_50263") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50265, "mem_50265") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50268, "mem_50268") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50271, "mem_50271") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50274, "mem_50274") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50275, "mem_50275") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50276, "mem_50276") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50277, "mem_50277") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50279, "mem_50279") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50281, "mem_50281") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50283, "mem_50283") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50313, "mem_50313") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_50838, &ext_mem_50315, "ext_mem_50315") != 0)
        return 1;
    prim_out_50839 = replicate_arg0_48713;
    prim_out_50840 = replicate_arg0_48715;
    if (memblock_set(ctx, &*mem_out_p_51101, &mem_out_50838, "mem_out_50838") != 0)
        return 1;
    *out_prim_out_51102 = prim_out_50839;
    *out_prim_out_51103 = prim_out_50840;
    
  cleanup:
    {
        free(mem_50285);
        free(mem_50294);
        if (memblock_unref(ctx, &ext_mem_50315, "ext_mem_50315") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50313, "mem_50313") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50283, "mem_50283") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50281, "mem_50281") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50279, "mem_50279") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50277, "mem_50277") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50276, "mem_50276") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50275, "mem_50275") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50274, "mem_50274") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50271, "mem_50271") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50268, "mem_50268") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50265, "mem_50265") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50263, "mem_50263") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50261, "mem_50261") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50259, "mem_50259") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_50838, "mem_out_50838") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_entry_test_utility_2(struct futhark_context *ctx, struct memblock *mem_out_p_51106, int64_t *out_prim_out_51107, int64_t *out_prim_out_51108, struct memblock newprices_mem_50257, struct memblock u_a_sq_mem_50258, int64_t c_35258, int64_t n_35259, int64_t Ax_35261)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_50283_cached_sizze_51109 = 0;
    unsigned char *mem_50283 = NULL;
    int64_t mem_50292_cached_sizze_51110 = 0;
    unsigned char *mem_50292 = NULL;
    struct memblock ext_mem_50313;
    
    ext_mem_50313.references = NULL;
    
    struct memblock mem_50311;
    
    mem_50311.references = NULL;
    
    struct memblock mem_50281;
    
    mem_50281.references = NULL;
    
    struct memblock mem_50279;
    
    mem_50279.references = NULL;
    
    struct memblock mem_50277;
    
    mem_50277.references = NULL;
    
    struct memblock mem_50275;
    
    mem_50275.references = NULL;
    
    struct memblock mem_50274;
    
    mem_50274.references = NULL;
    
    struct memblock mem_50273;
    
    mem_50273.references = NULL;
    
    struct memblock mem_50272;
    
    mem_50272.references = NULL;
    
    struct memblock mem_50269;
    
    mem_50269.references = NULL;
    
    struct memblock mem_50266;
    
    mem_50266.references = NULL;
    
    struct memblock mem_50264;
    
    mem_50264.references = NULL;
    
    struct memblock mem_50262;
    
    mem_50262.references = NULL;
    
    struct memblock mem_50260;
    
    mem_50260.references = NULL;
    
    struct memblock mem_out_50838;
    
    mem_out_50838.references = NULL;
    
    int64_t prim_out_50839;
    int64_t prim_out_50840;
    
    // trmodel.fut:123:24-46
    
    int64_t bytes_50259 = (int64_t) 8 * n_35259;
    
    // trmodel.fut:126:24-44
    
    int64_t bytes_50263 = (int64_t) 8 * c_35258;
    
    // trmodel_test.fut:153:49-62
    
    int64_t bytes_50268 = c_35258 * bytes_50259;
    
    // trmodel.fut:180:61-65
    
    int64_t dzlz7bUZLzmZRz20UAxz20U1z7dUzg_39283 = sub64(Ax_35261, (int64_t) 1);
    
    // trmodel.fut:180:28-68
    
    int64_t bytes_50282 = (int64_t) 8 * dzlz7bUZLzmZRz20UAxz20U1z7dUzg_39283;
    
    // trmodel.fut:180:75-181:53
    
    int64_t bytes_50291 = Ax_35261 * bytes_50263;
    
    // trmodel_test.fut:155:7-158:26
    
    int64_t binop_x_50309 = (int64_t) 8 * Ax_35261;
    
    // trmodel_test.fut:155:7-158:26
    
    int64_t bytes_50310 = c_35258 * binop_x_50309;
    
    // trmodel.fut:123:24-46
    if (memblock_alloc(ctx, &mem_50260, bytes_50259, "mem_50260")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:123:24-46
    for (int64_t nest_i_50841 = 0; nest_i_50841 < n_35259; nest_i_50841++) {
        ((double *) mem_50260.mem)[nest_i_50841] = 0.10000000149011612;
    }
    // trmodel.fut:124:47-52
    
    double i64_res_48703 = sitofp_i64_f64(n_35259);
    
    // trmodel.fut:124:39-52
    
    double zs_res_48704 = 1.0 / i64_res_48703;
    
    // trmodel.fut:124:24-52
    if (memblock_alloc(ctx, &mem_50262, bytes_50259, "mem_50262")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:124:24-52
    for (int64_t nest_i_50842 = 0; nest_i_50842 < n_35259; nest_i_50842++) {
        ((double *) mem_50262.mem)[nest_i_50842] = zs_res_48704;
    }
    // trmodel.fut:126:24-44
    if (memblock_alloc(ctx, &mem_50264, bytes_50263, "mem_50264")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:126:24-44
    for (int64_t nest_i_50843 = 0; nest_i_50843 < c_35258; nest_i_50843++) {
        ((double *) mem_50264.mem)[nest_i_50843] = 1.0;
    }
    // trmodel.fut:127:24-44
    if (memblock_alloc(ctx, &mem_50266, bytes_50259, "mem_50266")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:127:24-44
    for (int64_t nest_i_50844 = 0; nest_i_50844 < n_35259; nest_i_50844++) {
        ((double *) mem_50266.mem)[nest_i_50844] = 0.0;
    }
    // trmodel_test.fut:153:49-62
    if (memblock_alloc(ctx, &mem_50269, bytes_50268, "mem_50269")) {
        err = 1;
        goto cleanup;
    }
    // trmodel_test.fut:153:49-62
    for (int64_t nest_i_50845 = 0; nest_i_50845 < n_35259; nest_i_50845++) {
        for (int64_t nest_i_50846 = 0; nest_i_50846 < c_35258; nest_i_50846++) {
            ((double *) mem_50269.mem)[nest_i_50845 * c_35258 + nest_i_50846] = 6.0;
        }
    }
    // trmodel_test.fut:153:49-62
    if (memblock_alloc(ctx, &mem_50272, bytes_50268, "mem_50272")) {
        err = 1;
        goto cleanup;
    }
    // trmodel_test.fut:153:49-62
    for (int64_t nest_i_50847 = 0; nest_i_50847 < n_35259; nest_i_50847++) {
        for (int64_t nest_i_50848 = 0; nest_i_50848 < c_35258; nest_i_50848++) {
            ((double *) mem_50272.mem)[nest_i_50847 * c_35258 + nest_i_50848] = -0.5;
        }
    }
    // trmodel.fut:133:36-39
    
    int64_t zp_lhs_48712 = mul64(c_35258, Ax_35261);
    
    // trmodel.fut:133:39-41
    
    int64_t replicate_arg0_48713 = add64((int64_t) 1, zp_lhs_48712);
    
    // trmodel.fut:133:24-45
    if (memblock_alloc(ctx, &mem_50273, (int64_t) 0, "mem_50273")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:133:24-45
    for (int64_t nest_i_50849 = 0; nest_i_50849 < replicate_arg0_48713; nest_i_50849++) { }
    // trmodel.fut:134:39-41
    
    int64_t replicate_arg0_48715 = add64((int64_t) 2, zp_lhs_48712);
    
    // trmodel.fut:134:24-45
    if (memblock_alloc(ctx, &mem_50274, (int64_t) 0, "mem_50274")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:134:24-45
    for (int64_t nest_i_50850 = 0; nest_i_50850 < replicate_arg0_48715; nest_i_50850++) { }
    // trmodel.fut:135:24-39
    if (memblock_alloc(ctx, &mem_50275, (int64_t) 0, "mem_50275")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:135:24-39
    for (int64_t nest_i_50851 = 0; nest_i_50851 < Ax_35261; nest_i_50851++) { }
    // trmodel.fut:136:24-48
    if (memblock_alloc(ctx, &mem_50277, bytes_50263, "mem_50277")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:136:24-48
    for (int64_t nest_i_50852 = 0; nest_i_50852 < c_35258; nest_i_50852++) {
        ((double *) mem_50277.mem)[nest_i_50852] = -10.0;
    }
    // trmodel.fut:137:24-44
    if (memblock_alloc(ctx, &mem_50279, bytes_50263, "mem_50279")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:137:24-44
    for (int64_t nest_i_50853 = 0; nest_i_50853 < c_35258; nest_i_50853++) {
        ((double *) mem_50279.mem)[nest_i_50853] = 0.0;
    }
    // trmodel.fut:138:24-44
    if (memblock_alloc(ctx, &mem_50281, bytes_50263, "mem_50281")) {
        err = 1;
        goto cleanup;
    }
    // trmodel.fut:138:24-44
    for (int64_t nest_i_50854 = 0; nest_i_50854 < c_35258; nest_i_50854++) {
        ((double *) mem_50281.mem)[nest_i_50854] = 0.0;
    }
    // trmodel.fut:180:28-68
    if (mem_50283_cached_sizze_51109 < bytes_50282) {
        err = lexical_realloc(ctx, &mem_50283, &mem_50283_cached_sizze_51109, bytes_50282);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:180:28-68
    
    double discard_49983;
    double scanacc_49979 = 1.0;
    
    for (int64_t i_49981 = 0; i_49981 < dzlz7bUZLzmZRz20UAxz20U1z7dUzg_39283; i_49981++) {
        // trmodel.fut:180:33-38
        
        double zt_res_39289 = 0.85 * scanacc_49979;
        
        ((double *) mem_50283)[i_49981] = zt_res_39289;
        
        double scanacc_tmp_50855 = zt_res_39289;
        
        scanacc_49979 = scanacc_tmp_50855;
    }
    discard_49983 = scanacc_49979;
    // trmodel.fut:180:75-181:53
    if (mem_50292_cached_sizze_51110 < bytes_50291) {
        err = lexical_realloc(ctx, &mem_50292, &mem_50292_cached_sizze_51110, bytes_50291);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:180:75-181:53
    for (int64_t i_49990 = 0; i_49990 < c_35258; i_49990++) {
        double eta_p_39293 = ((double *) newprices_mem_50257.mem)[i_49990];
        
        // trmodel.fut:181:30-44
        for (int64_t i_49986 = 0; i_49986 < Ax_35261; i_49986++) {
            bool index_concat_cmp_50153 = sle64((int64_t) 1, i_49986);
            double index_concat_branch_50157;
            
            if (index_concat_cmp_50153) {
                int64_t index_concat_i_50154 = sub64(i_49986, (int64_t) 1);
                double index_concat_50155 = ((double *) mem_50283)[index_concat_i_50154];
                
                index_concat_branch_50157 = index_concat_50155;
            } else {
                index_concat_branch_50157 = 1.0;
            }
            // trmodel.fut:181:34-41
            
            double zt_res_39296 = eta_p_39293 * index_concat_branch_50157;
            
            ((double *) mem_50292)[i_49990 * Ax_35261 + i_49986] = zt_res_39296;
        }
    }
    // trmodel_test.fut:155:7-158:26
    if (memblock_alloc(ctx, &mem_50311, bytes_50310, "mem_50311")) {
        err = 1;
        goto cleanup;
    }
    // trmodel_test.fut:155:7-158:26
    // trmodel_test.fut:155:7-158:26
    lmad_copy_8b(ctx, 2, (uint64_t *) mem_50311.mem, (int64_t) 0, (int64_t []) {c_35258, (int64_t) 1}, (uint64_t *) mem_50292, (int64_t) 0, (int64_t []) {(int64_t) 1, Ax_35261}, (int64_t []) {Ax_35261, c_35258});
    // trmodel_test.fut:155:7-158:26
    if (futrts_utility_10336(ctx, &ext_mem_50313, mem_50277, mem_50279, mem_50281, mem_50275, mem_50260, mem_50274, mem_50273, newprices_mem_50257, mem_50264, mem_50266, mem_50262, mem_50269, mem_50272, u_a_sq_mem_50258, mem_50311, n_35259, c_35258, Ax_35261, replicate_arg0_48713, replicate_arg0_48715, 0.949999988079071, 1.0, 0.5, (int64_t) 1) != 0) {
        err = 1;
        goto cleanup;
    }
    if (memblock_unref(ctx, &mem_50260, "mem_50260") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50262, "mem_50262") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50264, "mem_50264") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50266, "mem_50266") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50269, "mem_50269") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50272, "mem_50272") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50273, "mem_50273") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50274, "mem_50274") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50275, "mem_50275") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50277, "mem_50277") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50279, "mem_50279") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50281, "mem_50281") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_50311, "mem_50311") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_50838, &ext_mem_50313, "ext_mem_50313") != 0)
        return 1;
    prim_out_50839 = replicate_arg0_48713;
    prim_out_50840 = replicate_arg0_48715;
    if (memblock_set(ctx, &*mem_out_p_51106, &mem_out_50838, "mem_out_50838") != 0)
        return 1;
    *out_prim_out_51107 = prim_out_50839;
    *out_prim_out_51108 = prim_out_50840;
    
  cleanup:
    {
        free(mem_50283);
        free(mem_50292);
        if (memblock_unref(ctx, &ext_mem_50313, "ext_mem_50313") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50311, "mem_50311") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50281, "mem_50281") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50279, "mem_50279") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50277, "mem_50277") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50275, "mem_50275") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50274, "mem_50274") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50273, "mem_50273") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50272, "mem_50272") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50269, "mem_50269") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50266, "mem_50266") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50264, "mem_50264") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50262, "mem_50262") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_50260, "mem_50260") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_50838, "mem_out_50838") != 0)
            return 1;
    }
    return err;
}
FUTHARK_FUN_ATTR int futrts_utility_10336(struct futhark_context *ctx, struct memblock *mem_out_p_51111, struct memblock acc_0_mem_50257, struct memblock acc_a_mem_50258, struct memblock acc_even_mem_50259, struct memblock maxage_mem_50260, struct memblock mum_mem_50261, struct memblock nd_mem_50262, struct memblock ns_mem_50263, struct memblock pnew_mem_50264, struct memblock pscrap_mem_50265, struct memblock psych_transcost_mem_50266, struct memblock tw_mem_50267, struct memblock u_0_mem_50268, struct memblock u_a_mem_50269, struct memblock u_a_sq_mem_50270, struct memblock p_mem_50271, int64_t n_34176, int64_t c_34177, int64_t Ax_34178, int64_t ns_34179, int64_t nd_34180, double bet_34184, double sigma_34192, double sigma_s_34193, int64_t tau_34199)
{
    (void) ctx;
    
    int err = 0;
    int64_t mem_50274_cached_sizze_51112 = 0;
    unsigned char *mem_50274 = NULL;
    int64_t mem_50278_cached_sizze_51113 = 0;
    unsigned char *mem_50278 = NULL;
    int64_t mem_50281_cached_sizze_51114 = 0;
    unsigned char *mem_50281 = NULL;
    int64_t mem_50315_cached_sizze_51115 = 0;
    unsigned char *mem_50315 = NULL;
    int64_t mem_50334_cached_sizze_51116 = 0;
    unsigned char *mem_50334 = NULL;
    int64_t mem_50364_cached_sizze_51117 = 0;
    unsigned char *mem_50364 = NULL;
    int64_t mem_50368_cached_sizze_51118 = 0;
    unsigned char *mem_50368 = NULL;
    int64_t mem_50372_cached_sizze_51119 = 0;
    unsigned char *mem_50372 = NULL;
    int64_t mem_50376_cached_sizze_51120 = 0;
    unsigned char *mem_50376 = NULL;
    int64_t mem_50380_cached_sizze_51121 = 0;
    unsigned char *mem_50380 = NULL;
    int64_t mem_50387_cached_sizze_51122 = 0;
    unsigned char *mem_50387 = NULL;
    struct memblock mem_50390;
    
    mem_50390.references = NULL;
    
    struct memblock mem_out_50838;
    
    mem_out_50838.references = NULL;
    // trmodel.fut:301:13-32
    
    bool cond_44328 = sle64((int64_t) 0, tau_34199);
    
    // trmodel.fut:301:29-32
    
    bool tmp_t_res_44329 = slt64(tau_34199, n_34176);
    
    // trmodel.fut:333:35-340:66
    
    bool x_44330 = cond_44328 && tmp_t_res_44329;
    
    // trmodel.fut:323:14-25
    
    bool index_certs_48567;
    
    if (!x_44330) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tau_34199, "] out of bounds for array of shape [", (long long) n_34176, "].", "-> #0  trmodel.fut:323:14-25\n   #1  trmodel.fut:333:35-350:87\n   #2  trmodel.fut:348:17-350:88\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // trmodel.fut:338:8-340:67
    
    int64_t flat_dim_37223 = c_34177 * Ax_34178;
    
    // trmodel.fut:338:8-341:41
    
    int64_t conc_tmp_37229 = (int64_t) 1 + flat_dim_37223;
    bool dim_match_34470 = ns_34179 == conc_tmp_37229;
    bool empty_or_match_cert_34471;
    
    if (!dim_match_34470) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Value of (desugared) shape [", (long long) conc_tmp_37229, "] cannot match shape of type \"[", (long long) ns_34179, "]f64\".", "-> #0  unknown location\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    // trmodel.fut:339:10-356:67
    
    int64_t binop_x_50272 = (int64_t) 8 * c_34177;
    
    // trmodel.fut:339:10-356:67
    
    int64_t bytes_50273 = Ax_34178 * binop_x_50272;
    
    // trmodel.fut:339:10-356:67
    
    int64_t bytes_50277 = ns_34179 * bytes_50273;
    int64_t bytes_50367 = (int64_t) 8 * ns_34179;
    
    // trmodel.fut:359:33-62
    
    int64_t conc_tmp_37867 = (int64_t) 2 + flat_dim_37223;
    bool dim_match_35004 = nd_34180 == conc_tmp_37867;
    bool empty_or_match_cert_35007;
    
    if (!dim_match_35004) {
        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Value of (desugared) shape [", (long long) conc_tmp_37867, "][", (long long) ns_34179, "] cannot match shape of type \"[", (long long) nd_34180, "][", (long long) ns_34179, "]f64\".", "-> #0  unknown location\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t binop_x_50385 = (int64_t) 8 * nd_34180;
    int64_t bytes_50386 = ns_34179 * binop_x_50385;
    int64_t bytes_50389 = nd_34180 * bytes_50367;
    
    // trmodel.fut:324:14-37
    
    double zm_rhs_48569 = ((double *) psych_transcost_mem_50266.mem)[tau_34199];
    
    // trmodel.fut:323:14-25
    
    double zt_lhs_48568 = ((double *) mum_mem_50261.mem)[tau_34199];
    
    // trmodel.fut:339:10-356:67
    if (mem_50274_cached_sizze_51112 < bytes_50273) {
        err = lexical_realloc(ctx, &mem_50274, &mem_50274_cached_sizze_51112, bytes_50273);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:339:10-356:67
    if (mem_50278_cached_sizze_51113 < bytes_50277) {
        err = lexical_realloc(ctx, &mem_50278, &mem_50278_cached_sizze_51113, bytes_50277);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:339:10-356:67
    if (mem_50281_cached_sizze_51114 < bytes_50273) {
        err = lexical_realloc(ctx, &mem_50281, &mem_50281_cached_sizze_51114, bytes_50273);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:339:10-356:67
    
    int64_t lmad_arg_50295 = Ax_34178 * ns_34179;
    
    // trmodel.fut:348:17-350:88
    if (mem_50315_cached_sizze_51115 < bytes_50273) {
        err = lexical_realloc(ctx, &mem_50315, &mem_50315_cached_sizze_51115, bytes_50273);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:347:15-350:89
    if (mem_50334_cached_sizze_51116 < bytes_50273) {
        err = lexical_realloc(ctx, &mem_50334, &mem_50334_cached_sizze_51116, bytes_50273);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:339:10-356:67
    for (int64_t i_50002 = 0; i_50002 < c_34177; i_50002++) {
        // trmodel.fut:339:10-356:67
        for (int64_t i_49992 = 0; i_49992 < Ax_34178; i_49992++) {
            // trmodel.fut:340:56-58
            
            int64_t util_arg3_49192 = add64((int64_t) 1, i_49992);
            
            // trmodel.fut:191:15-36
            
            bool cond_49319 = sle64((int64_t) 0, util_arg3_49192);
            
            // trmodel.fut:191:31-36
            
            bool tmp_t_res_49320 = sle64(util_arg3_49192, Ax_34178);
            
            // trmodel.fut:299:32-312:48
            
            bool x_49321 = cond_49319 && tmp_t_res_49320;
            
            // trmodel.fut:191:7-193:28
            
            bool assert_c_49322;
            
            if (!x_49321) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "Assertion is false: (age >= 0 && age <= Ax)", "-> #0  trmodel.fut:191:7-193:28\n   #1  trmodel.fut:299:32-312:48\n   #2  trmodel.fut:333:35-356:67\n   #3  trmodel.fut:355:10-356:67\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            // trmodel.fut:207:8-208:113
            
            bool cond_49193 = util_arg3_49192 == Ax_34178;
            
            // trmodel.fut:207:8-208:113
            
            double u_car_res_49194;
            
            if (cond_49193) {
                u_car_res_49194 = NAN;
            } else {
                // trmodel.fut:208:16-35
                
                bool index_certs_49199;
                
                if (!x_44330) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tau_34199, ", ", (long long) i_50002, "] out of bounds for array of shape [", (long long) n_34176, "][", (long long) c_34177, "].", "-> #0  trmodel.fut:208:16-35\n   #1  trmodel.fut:299:32-306:42\n   #2  trmodel.fut:333:35-340:66\n   #3  trmodel.fut:339:10-340:66\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                // trmodel.fut:208:16-35
                
                double zp_lhs_49200 = ((double *) u_0_mem_50268.mem)[tau_34199 * c_34177 + i_50002];
                
                // trmodel.fut:208:38-57
                
                double zt_lhs_49201 = ((double *) u_a_mem_50269.mem)[tau_34199 * c_34177 + i_50002];
                
                // trmodel.fut:208:60-67
                
                double i64_res_49202 = sitofp_i64_f64(util_arg3_49192);
                
                // trmodel.fut:208:38-67
                
                double zt_res_49203 = zt_lhs_49201 * i64_res_49202;
                
                // trmodel.fut:208:16-67
                
                double zp_res_49204 = zp_lhs_49200 + zt_res_49203;
                
                // trmodel.fut:208:68-90
                
                double zt_lhs_49205 = ((double *) u_a_sq_mem_50270.mem)[tau_34199 * c_34177 + i_50002];
                
                // trmodel.fut:208:68-101
                
                double zt_res_49206 = i64_res_49202 * zt_lhs_49205;
                
                // trmodel.fut:208:91-111
                
                double zt_res_49207 = i64_res_49202 * zt_res_49206;
                
                // trmodel.fut:208:36-111
                
                double zp_res_49208 = zp_res_49204 + zt_res_49207;
                
                u_car_res_49194 = zp_res_49208;
            }
            // trmodel.fut:207:8-208:113
            
            bool cond_49210 = i_49992 == Ax_34178;
            
            // trmodel.fut:207:8-208:113
            
            double u_car_res_49211;
            
            if (cond_49210) {
                u_car_res_49211 = NAN;
            } else {
                // trmodel.fut:208:16-35
                
                bool index_certs_49216;
                
                if (!x_44330) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tau_34199, ", ", (long long) i_50002, "] out of bounds for array of shape [", (long long) n_34176, "][", (long long) c_34177, "].", "-> #0  trmodel.fut:208:16-35\n   #1  trmodel.fut:299:32-322:33\n   #2  trmodel.fut:333:35-350:87\n   #3  trmodel.fut:348:17-350:88\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                // trmodel.fut:208:16-35
                
                double zp_lhs_49217 = ((double *) u_0_mem_50268.mem)[tau_34199 * c_34177 + i_50002];
                
                // trmodel.fut:208:38-57
                
                double zt_lhs_49218 = ((double *) u_a_mem_50269.mem)[tau_34199 * c_34177 + i_50002];
                
                // trmodel.fut:208:60-67
                
                double i64_res_49219 = sitofp_i64_f64(i_49992);
                
                // trmodel.fut:208:38-67
                
                double zt_res_49220 = zt_lhs_49218 * i64_res_49219;
                
                // trmodel.fut:208:16-67
                
                double zp_res_49221 = zp_lhs_49217 + zt_res_49220;
                
                // trmodel.fut:208:68-90
                
                double zt_lhs_49222 = ((double *) u_a_sq_mem_50270.mem)[tau_34199 * c_34177 + i_50002];
                
                // trmodel.fut:208:68-101
                
                double zt_res_49223 = i64_res_49219 * zt_lhs_49222;
                
                // trmodel.fut:208:91-111
                
                double zt_res_49224 = i64_res_49219 * zt_res_49223;
                
                // trmodel.fut:208:36-111
                
                double zp_res_49225 = zp_res_49221 + zt_res_49224;
                
                u_car_res_49211 = zp_res_49225;
            }
            // trmodel.fut:200:7-201:24
            
            double case_res_49235 = ((double *) p_mem_50271.mem)[i_49992 * c_34177 + i_50002];
            
            // trmodel.fut:323:14-47
            
            double zt_res_49236 = zt_lhs_48568 * case_res_49235;
            
            // trmodel.fut:322:14-323:47
            
            double zm_res_49237 = u_car_res_49211 - zt_res_49236;
            
            // trmodel.fut:322:34-324:37
            
            double zm_res_49238 = zm_res_49237 - zm_rhs_48569;
            
            // trmodel.fut:348:17-350:88
            for (int64_t i_49984 = 0; i_49984 < c_34177; i_49984++) {
                // trmodel.fut:348:17-350:88
                for (int64_t i_49980 = 0; i_49980 < Ax_34178; i_49980++) {
                    // trmodel.fut:350:56-58
                    
                    int64_t util_arg3_49243 = add64((int64_t) 1, i_49980);
                    
                    // trmodel.fut:191:15-36
                    
                    bool cond_49244 = sle64((int64_t) 0, util_arg3_49243);
                    
                    // trmodel.fut:191:31-36
                    
                    bool tmp_t_res_49245 = sle64(util_arg3_49243, Ax_34178);
                    
                    // trmodel.fut:299:32-325:48
                    
                    bool x_49246 = cond_49244 && tmp_t_res_49245;
                    
                    // trmodel.fut:191:7-193:28
                    
                    bool assert_c_49247;
                    
                    if (!x_49246) {
                        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "Assertion is false: (age >= 0 && age <= Ax)", "-> #0  trmodel.fut:191:7-193:28\n   #1  trmodel.fut:299:32-325:48\n   #2  trmodel.fut:333:35-350:87\n   #3  trmodel.fut:348:17-350:88\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    // trmodel.fut:191:7-193:28
                    
                    bool cond_49248 = util_arg3_49243 == Ax_34178;
                    
                    // trmodel.fut:191:7-193:28
                    
                    double case_res_49249;
                    
                    if (cond_49248) {
                        // trmodel.fut:192:26-44
                        
                        double case_res_t_res_49404 = ((double *) pscrap_mem_50265.mem)[i_49984];
                        
                        case_res_49249 = case_res_t_res_49404;
                    } else {
                        // trmodel.fut:193:13-27
                        
                        bool y_49255 = slt64(util_arg3_49243, Ax_34178);
                        
                        // trmodel.fut:193:13-27
                        
                        bool bounds_check_49256 = cond_49244 && y_49255;
                        
                        // trmodel.fut:193:13-27
                        
                        bool index_certs_49261;
                        
                        if (!bounds_check_49256) {
                            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) util_arg3_49243, ", ", (long long) i_49984, "] out of bounds for array of shape [", (long long) Ax_34178, "][", (long long) c_34177, "].", "-> #0  trmodel.fut:193:13-27\n   #1  trmodel.fut:299:32-325:48\n   #2  trmodel.fut:333:35-350:87\n   #3  trmodel.fut:348:17-350:88\n"));
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        // trmodel.fut:193:13-27
                        
                        double case_res_f_res_49262 = ((double *) p_mem_50271.mem)[util_arg3_49243 * c_34177 + i_49984];
                        
                        case_res_49249 = case_res_f_res_49262;
                    }
                    // trmodel.fut:325:14-48
                    
                    double zt_res_49263 = zt_lhs_48568 * case_res_49249;
                    
                    // trmodel.fut:323:48-325:48
                    
                    double zp_res_49264 = zm_res_49238 + zt_res_49263;
                    
                    // trmodel.fut:257:36-258:50
                    
                    double case_res_49265;
                    
                    if (cond_49248) {
                        case_res_49265 = 0.0;
                    } else {
                        // trmodel.fut:252:38-56
                        
                        double case_res_49270 = ((double *) pscrap_mem_50265.mem)[i_49984];
                        
                        // trmodel.fut:191:7-193:28
                        
                        double case_res_49271;
                        
                        if (cond_49248) {
                            case_res_49271 = case_res_49270;
                        } else {
                            // trmodel.fut:193:13-27
                            
                            bool y_49272 = slt64(util_arg3_49243, Ax_34178);
                            
                            // trmodel.fut:193:13-27
                            
                            bool bounds_check_49273 = cond_49244 && y_49272;
                            
                            // trmodel.fut:193:13-27
                            
                            bool index_certs_49275;
                            
                            if (!bounds_check_49273) {
                                set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) util_arg3_49243, ", ", (long long) i_49984, "] out of bounds for array of shape [", (long long) Ax_34178, "][", (long long) c_34177, "].", "-> #0  trmodel.fut:193:13-27\n   #1  trmodel.fut:245:36-253:39\n   #2  trmodel.fut:258:48-50\n   #3  trmodel.fut:299:32-326:33\n   #4  trmodel.fut:333:35-350:87\n   #5  trmodel.fut:348:17-350:88\n"));
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            // trmodel.fut:193:13-27
                            
                            double case_res_f_res_49276 = ((double *) p_mem_50271.mem)[util_arg3_49243 * c_34177 + i_49984];
                            
                            case_res_49271 = case_res_f_res_49276;
                        }
                        // trmodel.fut:254:48-60
                        
                        double zm_res_49277 = case_res_49270 - case_res_49271;
                        
                        // trmodel.fut:254:33-60
                        
                        double zt_res_49278 = zt_lhs_48568 * zm_res_49277;
                        
                        // trmodel.fut:213:8-215:34
                        
                        bool isnan_res_49279 = futrts_isnan64(zt_res_49278);
                        
                        // trmodel.fut:213:8-215:34
                        
                        double nanmax2_res_49280;
                        
                        if (isnan_res_49279) {
                            nanmax2_res_49280 = 0.0;
                        } else {
                            // trmodel.fut:215:27-34
                            
                            double max_res_49281 = fmax64(0.0, zt_res_49278);
                            
                            nanmax2_res_49280 = max_res_49281;
                        }
                        // trmodel.fut:238:11-240:69
                        
                        bool zeze_res_49282 = sigma_s_34193 == 0.0;
                        
                        // trmodel.fut:238:11-240:69
                        
                        double logsum2_res_49283;
                        
                        if (zeze_res_49282) {
                            logsum2_res_49283 = nanmax2_res_49280;
                        } else {
                            // trmodel.fut:239:26-34
                            
                            double zm_res_49284 = 0.0 - nanmax2_res_49280;
                            
                            // trmodel.fut:239:38-46
                            
                            double zs_res_49285 = zm_res_49284 / sigma_s_34193;
                            
                            // trmodel.fut:239:50-53
                            
                            double exp_res_49286 = futrts_exp64(zs_res_49285);
                            
                            // trmodel.fut:239:26-34
                            
                            double zm_res_49287 = zt_res_49278 - nanmax2_res_49280;
                            
                            // trmodel.fut:239:38-46
                            
                            double zs_res_49288 = zm_res_49287 / sigma_s_34193;
                            
                            // trmodel.fut:239:50-53
                            
                            double exp_res_49289 = futrts_exp64(zs_res_49288);
                            
                            // trmodel.fut:222:8-224:30
                            
                            bool isnan_res_49290 = futrts_isnan64(exp_res_49289);
                            
                            // trmodel.fut:222:8-224:30
                            
                            double nansum2_res_49291;
                            
                            if (isnan_res_49290) {
                                nansum2_res_49291 = exp_res_49286;
                            } else {
                                // trmodel.fut:223:20-224:30
                                
                                bool isnan_res_49292 = futrts_isnan64(exp_res_49286);
                                
                                // trmodel.fut:223:20-224:30
                                
                                double nansum2_res_f_res_49293;
                                
                                if (isnan_res_49292) {
                                    nansum2_res_f_res_49293 = exp_res_49289;
                                } else {
                                    // trmodel.fut:224:27-30
                                    
                                    double zp_res_49294 = exp_res_49286 + exp_res_49289;
                                    
                                    nansum2_res_f_res_49293 = zp_res_49294;
                                }
                                nansum2_res_49291 = nansum2_res_f_res_49293;
                            }
                            // trmodel.fut:240:42-45
                            
                            double log_res_49295 = futrts_log64(nansum2_res_49291);
                            
                            // trmodel.fut:240:49-57
                            
                            double zt_res_49296 = sigma_s_34193 * log_res_49295;
                            
                            // trmodel.fut:240:61-69
                            
                            double zp_res_49297 = nanmax2_res_49280 + zt_res_49296;
                            
                            logsum2_res_49283 = zp_res_49297;
                        }
                        case_res_49265 = logsum2_res_49283;
                    }
                    // trmodel.fut:324:38-326:33
                    
                    double zp_res_49298 = zp_res_49264 + case_res_49265;
                    
                    ((double *) mem_50315)[i_49984 * Ax_34178 + i_49980] = zp_res_49298;
                }
            }
            // trmodel.fut:347:15-350:89
            // trmodel.fut:347:15-350:89
            lmad_copy_8b(ctx, 2, (uint64_t *) mem_50334, (int64_t) 0, (int64_t []) {Ax_34178, (int64_t) 1}, (uint64_t *) mem_50315, (int64_t) 0, (int64_t []) {Ax_34178, (int64_t) 1}, (int64_t []) {c_34177, Ax_34178});
            // trmodel.fut:207:8-208:113
            
            double u_car_res_49300;
            
            if (cond_49210) {
                u_car_res_49300 = NAN;
            } else {
                // trmodel.fut:208:16-35
                
                bool index_certs_49302;
                
                if (!x_44330) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) tau_34199, ", ", (long long) i_50002, "] out of bounds for array of shape [", (long long) n_34176, "][", (long long) c_34177, "].", "-> #0  trmodel.fut:208:16-35\n   #1  trmodel.fut:299:32-318:33\n   #2  trmodel.fut:333:35-351:68\n   #3  trmodel.fut:345:9-351:80\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                // trmodel.fut:208:16-35
                
                double zp_lhs_49303 = ((double *) u_0_mem_50268.mem)[tau_34199 * c_34177 + i_50002];
                
                // trmodel.fut:208:38-57
                
                double zt_lhs_49304 = ((double *) u_a_mem_50269.mem)[tau_34199 * c_34177 + i_50002];
                
                // trmodel.fut:208:60-67
                
                double i64_res_49305 = sitofp_i64_f64(i_49992);
                
                // trmodel.fut:208:38-67
                
                double zt_res_49306 = zt_lhs_49304 * i64_res_49305;
                
                // trmodel.fut:208:16-67
                
                double zp_res_49307 = zp_lhs_49303 + zt_res_49306;
                
                // trmodel.fut:208:68-90
                
                double zt_lhs_49308 = ((double *) u_a_sq_mem_50270.mem)[tau_34199 * c_34177 + i_50002];
                
                // trmodel.fut:208:68-101
                
                double zt_res_49309 = i64_res_49305 * zt_lhs_49308;
                
                // trmodel.fut:208:91-111
                
                double zt_res_49310 = i64_res_49305 * zt_res_49309;
                
                // trmodel.fut:208:36-111
                
                double zp_res_49311 = zp_res_49307 + zt_res_49310;
                
                u_car_res_49300 = zp_res_49311;
            }
            // trmodel.fut:318:14-319:47
            
            double zm_res_49312 = u_car_res_49300 - zt_res_49236;
            
            // trmodel.fut:318:34-320:37
            
            double zm_res_49313 = zm_res_49312 - zm_rhs_48569;
            
            // trmodel.fut:345:9-351:80
            for (int64_t nest_i_50847 = 0; nest_i_50847 < (int64_t) 1; nest_i_50847++) {
                ((double *) mem_50278)[i_50002 * lmad_arg_50295 + i_49992 * ns_34179 + flat_dim_37223 + nest_i_50847] = zm_res_49313;
            }
            // trmodel.fut:345:9-351:80
            
            int64_t tmp_offs_50848 = (int64_t) 0;
            
            // trmodel.fut:345:9-351:80
            lmad_copy_8b(ctx, 1, (uint64_t *) mem_50278, i_50002 * lmad_arg_50295 + i_49992 * ns_34179 + tmp_offs_50848, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_50334, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {flat_dim_37223});
            tmp_offs_50848 += flat_dim_37223;
            if (!((i_50002 * lmad_arg_50295 + i_49992 * ns_34179 + tmp_offs_50848) == i_50002 * lmad_arg_50295 + i_49992 * ns_34179 + flat_dim_37223)) {
                // trmodel.fut:345:9-351:80
                lmad_copy_8b(ctx, 1, (uint64_t *) mem_50278, i_50002 * lmad_arg_50295 + i_49992 * ns_34179 + tmp_offs_50848, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_50278, i_50002 * lmad_arg_50295 + i_49992 * ns_34179 + flat_dim_37223, (int64_t []) {(int64_t) 1}, (int64_t []) {(int64_t) 1});
            }
            tmp_offs_50848 += (int64_t) 1;
            // trmodel.fut:191:7-193:28
            
            double case_res_49324;
            
            if (cond_49193) {
                // trmodel.fut:192:26-44
                
                double case_res_t_res_49410 = ((double *) pscrap_mem_50265.mem)[i_50002];
                
                case_res_49324 = case_res_t_res_49410;
            } else {
                // trmodel.fut:193:13-27
                
                bool y_49330 = slt64(util_arg3_49192, Ax_34178);
                
                // trmodel.fut:193:13-27
                
                bool bounds_check_49331 = cond_49319 && y_49330;
                
                // trmodel.fut:193:13-27
                
                bool index_certs_49336;
                
                if (!bounds_check_49331) {
                    set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) util_arg3_49192, ", ", (long long) i_50002, "] out of bounds for array of shape [", (long long) Ax_34178, "][", (long long) c_34177, "].", "-> #0  trmodel.fut:193:13-27\n   #1  trmodel.fut:299:32-312:48\n   #2  trmodel.fut:333:35-356:67\n   #3  trmodel.fut:355:10-356:67\n"));
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                // trmodel.fut:193:13-27
                
                double case_res_f_res_49337 = ((double *) p_mem_50271.mem)[util_arg3_49192 * c_34177 + i_50002];
                
                case_res_49324 = case_res_f_res_49337;
            }
            // trmodel.fut:312:14-48
            
            double zt_res_49338 = zt_lhs_48568 * case_res_49324;
            
            // trmodel.fut:257:36-258:50
            
            double case_res_49339;
            
            if (cond_49193) {
                case_res_49339 = 0.0;
            } else {
                // trmodel.fut:252:38-56
                
                double case_res_49344 = ((double *) pscrap_mem_50265.mem)[i_50002];
                
                // trmodel.fut:191:7-193:28
                
                double case_res_49345;
                
                if (cond_49193) {
                    case_res_49345 = case_res_49344;
                } else {
                    // trmodel.fut:193:13-27
                    
                    bool y_49346 = slt64(util_arg3_49192, Ax_34178);
                    
                    // trmodel.fut:193:13-27
                    
                    bool bounds_check_49347 = cond_49319 && y_49346;
                    
                    // trmodel.fut:193:13-27
                    
                    bool index_certs_49349;
                    
                    if (!bounds_check_49347) {
                        set_error(ctx, msgprintf("Error: %s%lld%s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [", (long long) util_arg3_49192, ", ", (long long) i_50002, "] out of bounds for array of shape [", (long long) Ax_34178, "][", (long long) c_34177, "].", "-> #0  trmodel.fut:193:13-27\n   #1  trmodel.fut:245:36-253:39\n   #2  trmodel.fut:258:48-50\n   #3  trmodel.fut:299:32-313:33\n   #4  trmodel.fut:333:35-356:67\n   #5  trmodel.fut:355:10-356:67\n"));
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    // trmodel.fut:193:13-27
                    
                    double case_res_f_res_49350 = ((double *) p_mem_50271.mem)[util_arg3_49192 * c_34177 + i_50002];
                    
                    case_res_49345 = case_res_f_res_49350;
                }
                // trmodel.fut:254:48-60
                
                double zm_res_49351 = case_res_49344 - case_res_49345;
                
                // trmodel.fut:254:33-60
                
                double zt_res_49352 = zt_lhs_48568 * zm_res_49351;
                
                // trmodel.fut:213:8-215:34
                
                bool isnan_res_49353 = futrts_isnan64(zt_res_49352);
                
                // trmodel.fut:213:8-215:34
                
                double nanmax2_res_49354;
                
                if (isnan_res_49353) {
                    nanmax2_res_49354 = 0.0;
                } else {
                    // trmodel.fut:215:27-34
                    
                    double max_res_49355 = fmax64(0.0, zt_res_49352);
                    
                    nanmax2_res_49354 = max_res_49355;
                }
                // trmodel.fut:238:11-240:69
                
                bool zeze_res_49356 = sigma_s_34193 == 0.0;
                
                // trmodel.fut:238:11-240:69
                
                double logsum2_res_49357;
                
                if (zeze_res_49356) {
                    logsum2_res_49357 = nanmax2_res_49354;
                } else {
                    // trmodel.fut:239:26-34
                    
                    double zm_res_49358 = 0.0 - nanmax2_res_49354;
                    
                    // trmodel.fut:239:38-46
                    
                    double zs_res_49359 = zm_res_49358 / sigma_s_34193;
                    
                    // trmodel.fut:239:50-53
                    
                    double exp_res_49360 = futrts_exp64(zs_res_49359);
                    
                    // trmodel.fut:239:26-34
                    
                    double zm_res_49361 = zt_res_49352 - nanmax2_res_49354;
                    
                    // trmodel.fut:239:38-46
                    
                    double zs_res_49362 = zm_res_49361 / sigma_s_34193;
                    
                    // trmodel.fut:239:50-53
                    
                    double exp_res_49363 = futrts_exp64(zs_res_49362);
                    
                    // trmodel.fut:222:8-224:30
                    
                    bool isnan_res_49364 = futrts_isnan64(exp_res_49363);
                    
                    // trmodel.fut:222:8-224:30
                    
                    double nansum2_res_49365;
                    
                    if (isnan_res_49364) {
                        nansum2_res_49365 = exp_res_49360;
                    } else {
                        // trmodel.fut:223:20-224:30
                        
                        bool isnan_res_49366 = futrts_isnan64(exp_res_49360);
                        
                        // trmodel.fut:223:20-224:30
                        
                        double nansum2_res_f_res_49367;
                        
                        if (isnan_res_49366) {
                            nansum2_res_f_res_49367 = exp_res_49363;
                        } else {
                            // trmodel.fut:224:27-30
                            
                            double zp_res_49368 = exp_res_49360 + exp_res_49363;
                            
                            nansum2_res_f_res_49367 = zp_res_49368;
                        }
                        nansum2_res_49365 = nansum2_res_f_res_49367;
                    }
                    // trmodel.fut:240:42-45
                    
                    double log_res_49369 = futrts_log64(nansum2_res_49365);
                    
                    // trmodel.fut:240:49-57
                    
                    double zt_res_49370 = sigma_s_34193 * log_res_49369;
                    
                    // trmodel.fut:240:61-69
                    
                    double zp_res_49371 = nanmax2_res_49354 + zt_res_49370;
                    
                    logsum2_res_49357 = zp_res_49371;
                }
                case_res_49339 = logsum2_res_49357;
            }
            // trmodel.fut:312:26-313:33
            
            double zp_res_49372 = zt_res_49338 + case_res_49339;
            
            ((double *) mem_50274)[i_50002 * Ax_34178 + i_49992] = zp_res_49372;
            ((double *) mem_50281)[i_50002 * Ax_34178 + i_49992] = u_car_res_49194;
        }
    }
    // trmodel.fut:338:8-340:67
    if (mem_50364_cached_sizze_51117 < bytes_50273) {
        err = lexical_realloc(ctx, &mem_50364, &mem_50364_cached_sizze_51117, bytes_50273);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:338:8-340:67
    // trmodel.fut:338:8-340:67
    lmad_copy_8b(ctx, 2, (uint64_t *) mem_50364, (int64_t) 0, (int64_t []) {Ax_34178, (int64_t) 1}, (uint64_t *) mem_50281, (int64_t) 0, (int64_t []) {Ax_34178, (int64_t) 1}, (int64_t []) {c_34177, Ax_34178});
    if (mem_50368_cached_sizze_51118 < bytes_50367) {
        err = lexical_realloc(ctx, &mem_50368, &mem_50368_cached_sizze_51118, bytes_50367);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    for (int64_t nest_i_50849 = 0; nest_i_50849 < (int64_t) 1; nest_i_50849++) {
        ((double *) mem_50368)[flat_dim_37223 + nest_i_50849] = NAN;
    }
    
    int64_t tmp_offs_50850 = (int64_t) 0;
    
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_50368, tmp_offs_50850, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_50364, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {flat_dim_37223});
    tmp_offs_50850 += flat_dim_37223;
    if (!(tmp_offs_50850 == flat_dim_37223)) {
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_50368, tmp_offs_50850, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_50368, flat_dim_37223, (int64_t []) {(int64_t) 1}, (int64_t []) {(int64_t) 1});
    }
    tmp_offs_50850 += (int64_t) 1;
    // trmodel.fut:344:7-351:81
    if (mem_50372_cached_sizze_51119 < bytes_50277) {
        err = lexical_realloc(ctx, &mem_50372, &mem_50372_cached_sizze_51119, bytes_50277);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:344:7-351:81
    // trmodel.fut:344:7-351:81
    lmad_copy_8b(ctx, 3, (uint64_t *) mem_50372, (int64_t) 0, (int64_t []) {ns_34179 * Ax_34178, ns_34179, (int64_t) 1}, (uint64_t *) mem_50278, (int64_t) 0, (int64_t []) {lmad_arg_50295, ns_34179, (int64_t) 1}, (int64_t []) {c_34177, Ax_34178, ns_34179});
    // trmodel.fut:354:8-356:68
    if (mem_50376_cached_sizze_51120 < bytes_50273) {
        err = lexical_realloc(ctx, &mem_50376, &mem_50376_cached_sizze_51120, bytes_50273);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    // trmodel.fut:354:8-356:68
    // trmodel.fut:354:8-356:68
    lmad_copy_8b(ctx, 2, (uint64_t *) mem_50376, (int64_t) 0, (int64_t []) {Ax_34178, (int64_t) 1}, (uint64_t *) mem_50274, (int64_t) 0, (int64_t []) {Ax_34178, (int64_t) 1}, (int64_t []) {c_34177, Ax_34178});
    if (mem_50380_cached_sizze_51121 < bytes_50367) {
        err = lexical_realloc(ctx, &mem_50380, &mem_50380_cached_sizze_51121, bytes_50367);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    for (int64_t nest_i_50851 = 0; nest_i_50851 < (int64_t) 1; nest_i_50851++) {
        ((double *) mem_50380)[flat_dim_37223 + nest_i_50851] = 0.0;
    }
    
    int64_t tmp_offs_50852 = (int64_t) 0;
    
    lmad_copy_8b(ctx, 1, (uint64_t *) mem_50380, tmp_offs_50852, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_50376, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {flat_dim_37223});
    tmp_offs_50852 += flat_dim_37223;
    if (!(tmp_offs_50852 == flat_dim_37223)) {
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_50380, tmp_offs_50852, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_50380, flat_dim_37223, (int64_t []) {(int64_t) 1}, (int64_t []) {(int64_t) 1});
    }
    tmp_offs_50852 += (int64_t) 1;
    if (mem_50387_cached_sizze_51122 < bytes_50386) {
        err = lexical_realloc(ctx, &mem_50387, &mem_50387_cached_sizze_51122, bytes_50386);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    for (int64_t nest_i_50853 = 0; nest_i_50853 < (int64_t) 1; nest_i_50853++) {
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_50387, nest_i_50853 * ns_34179, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_50368, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {ns_34179});
    }
    for (int64_t nest_i_50854 = 0; nest_i_50854 < (int64_t) 1; nest_i_50854++) {
        lmad_copy_8b(ctx, 1, (uint64_t *) mem_50387, ns_34179 * ((int64_t) 1 + flat_dim_37223) + nest_i_50854 * ns_34179, (int64_t []) {(int64_t) 1}, (uint64_t *) mem_50380, (int64_t) 0, (int64_t []) {(int64_t) 1}, (int64_t []) {ns_34179});
    }
    
    int64_t tmp_offs_50855 = (int64_t) 0;
    
    if (!(ns_34179 * tmp_offs_50855 == (int64_t) 0)) {
        lmad_copy_8b(ctx, 2, (uint64_t *) mem_50387, ns_34179 * tmp_offs_50855, (int64_t []) {ns_34179, (int64_t) 1}, (uint64_t *) mem_50387, (int64_t) 0, (int64_t []) {ns_34179, (int64_t) 1}, (int64_t []) {(int64_t) 1, ns_34179});
    }
    tmp_offs_50855 += (int64_t) 1;
    lmad_copy_8b(ctx, 2, (uint64_t *) mem_50387, ns_34179 * tmp_offs_50855, (int64_t []) {ns_34179, (int64_t) 1}, (uint64_t *) mem_50372, (int64_t) 0, (int64_t []) {ns_34179, (int64_t) 1}, (int64_t []) {flat_dim_37223, ns_34179});
    tmp_offs_50855 += flat_dim_37223;
    if (!(ns_34179 * tmp_offs_50855 == ns_34179 * ((int64_t) 1 + flat_dim_37223))) {
        lmad_copy_8b(ctx, 2, (uint64_t *) mem_50387, ns_34179 * tmp_offs_50855, (int64_t []) {ns_34179, (int64_t) 1}, (uint64_t *) mem_50387, ns_34179 * ((int64_t) 1 + flat_dim_37223), (int64_t []) {ns_34179, (int64_t) 1}, (int64_t []) {(int64_t) 1, ns_34179});
    }
    tmp_offs_50855 += (int64_t) 1;
    if (memblock_alloc(ctx, &mem_50390, bytes_50389, "mem_50390")) {
        err = 1;
        goto cleanup;
    }
    lmad_copy_8b(ctx, 2, (uint64_t *) mem_50390.mem, (int64_t) 0, (int64_t []) {nd_34180, (int64_t) 1}, (uint64_t *) mem_50387, (int64_t) 0, (int64_t []) {(int64_t) 1, ns_34179}, (int64_t []) {ns_34179, nd_34180});
    if (memblock_set(ctx, &mem_out_50838, &mem_50390, "mem_50390") != 0)
        return 1;
    if (memblock_set(ctx, &*mem_out_p_51111, &mem_out_50838, "mem_out_50838") != 0)
        return 1;
    
  cleanup:
    {
        free(mem_50274);
        free(mem_50278);
        free(mem_50281);
        free(mem_50315);
        free(mem_50334);
        free(mem_50364);
        free(mem_50368);
        free(mem_50372);
        free(mem_50376);
        free(mem_50380);
        free(mem_50387);
        if (memblock_unref(ctx, &mem_50390, "mem_50390") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_50838, "mem_out_50838") != 0)
            return 1;
    }
    return err;
}

int futhark_entry_test_acc_prob(struct futhark_context *ctx, struct futhark_f64_1d **out0, const int64_t in0, const int64_t in1, const int64_t in2)
{
    int64_t n_29367 = (int64_t) 0;
    int64_t c_29368 = (int64_t) 0;
    int64_t Ax_29369 = (int64_t) 0;
    int64_t prim_out_50839 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_50838;
    
    mem_out_50838.references = NULL;
    n_29367 = in0;
    c_29368 = in1;
    Ax_29369 = in2;
    if (ret == 0) {
        ret = futrts_entry_test_acc_prob(ctx, &mem_out_50838, &prim_out_50839, n_29367, c_29368, Ax_29369);
        if (ret == 0) {
            assert((*out0 = (struct futhark_f64_1d *) malloc(sizeof(struct futhark_f64_1d))) != NULL);
            (*out0)->mem = mem_out_50838;
            (*out0)->shape[0] = prim_out_50839;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_test_acc_prob_mat(struct futhark_context *ctx, struct futhark_f64_2d **out0, const int64_t in0, const int64_t in1, const int64_t in2)
{
    int64_t n_29623 = (int64_t) 0;
    int64_t c_29624 = (int64_t) 0;
    int64_t Ax_29625 = (int64_t) 0;
    int64_t prim_out_50839 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_50838;
    
    mem_out_50838.references = NULL;
    n_29623 = in0;
    c_29624 = in1;
    Ax_29625 = in2;
    if (ret == 0) {
        ret = futrts_entry_test_acc_prob_mat(ctx, &mem_out_50838, &prim_out_50839, n_29623, c_29624, Ax_29625);
        if (ret == 0) {
            assert((*out0 = (struct futhark_f64_2d *) malloc(sizeof(struct futhark_f64_2d))) != NULL);
            (*out0)->mem = mem_out_50838;
            (*out0)->shape[0] = prim_out_50839;
            (*out0)->shape[1] = prim_out_50839;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_test_bellman(struct futhark_context *ctx, struct futhark_f64_1d **out0, const int64_t in0, const struct futhark_f64_1d *in1, const int64_t in2)
{
    int64_t c_36762 = (int64_t) 0;
    int64_t n_36763 = (int64_t) 0;
    int64_t Ax_36765 = (int64_t) 0;
    int64_t prim_out_50839 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_50838;
    
    mem_out_50838.references = NULL;
    
    struct memblock newprices_mem_50257;
    
    newprices_mem_50257.references = NULL;
    n_36763 = in0;
    newprices_mem_50257 = in1->mem;
    c_36762 = in1->shape[0];
    Ax_36765 = in2;
    if (!(c_36762 == in1->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_test_bellman(ctx, &mem_out_50838, &prim_out_50839, newprices_mem_50257, c_36762, n_36763, Ax_36765);
        if (ret == 0) {
            assert((*out0 = (struct futhark_f64_1d *) malloc(sizeof(struct futhark_f64_1d))) != NULL);
            (*out0)->mem = mem_out_50838;
            (*out0)->shape[0] = prim_out_50839;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_test_bellmanN(struct futhark_context *ctx, struct futhark_f64_1d **out0, const int64_t in0, const struct futhark_f64_1d *in1, const int64_t in2, const int64_t in3)
{
    int64_t c_36886 = (int64_t) 0;
    int64_t n_36887 = (int64_t) 0;
    int64_t Ax_36889 = (int64_t) 0;
    int64_t N_36890 = (int64_t) 0;
    int64_t prim_out_50839 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_50838;
    
    mem_out_50838.references = NULL;
    
    struct memblock newprices_mem_50257;
    
    newprices_mem_50257.references = NULL;
    n_36887 = in0;
    newprices_mem_50257 = in1->mem;
    c_36886 = in1->shape[0];
    Ax_36889 = in2;
    N_36890 = in3;
    if (!(c_36886 == in1->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_test_bellmanN(ctx, &mem_out_50838, &prim_out_50839, newprices_mem_50257, c_36886, n_36887, Ax_36889, N_36890);
        if (ret == 0) {
            assert((*out0 = (struct futhark_f64_1d *) malloc(sizeof(struct futhark_f64_1d))) != NULL);
            (*out0)->mem = mem_out_50838;
            (*out0)->shape[0] = prim_out_50839;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_test_carprice_buy(struct futhark_context *ctx, struct futhark_f64_1d **out0, const int64_t in0, const struct futhark_f64_1d *in1, const int64_t in2)
{
    int64_t c_29010 = (int64_t) 0;
    int64_t n_29011 = (int64_t) 0;
    int64_t Ax_29013 = (int64_t) 0;
    int64_t prim_out_50839 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_50838;
    
    mem_out_50838.references = NULL;
    
    struct memblock newprices_mem_50257;
    
    newprices_mem_50257.references = NULL;
    n_29011 = in0;
    newprices_mem_50257 = in1->mem;
    c_29010 = in1->shape[0];
    Ax_29013 = in2;
    if (!(c_29010 == in1->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_test_carprice_buy(ctx, &mem_out_50838, &prim_out_50839, newprices_mem_50257, c_29010, n_29011, Ax_29013);
        if (ret == 0) {
            assert((*out0 = (struct futhark_f64_1d *) malloc(sizeof(struct futhark_f64_1d))) != NULL);
            (*out0)->mem = mem_out_50838;
            (*out0)->shape[0] = prim_out_50839;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_test_carprice_sell(struct futhark_context *ctx, struct futhark_f64_1d **out0, const int64_t in0, const struct futhark_f64_1d *in1, const int64_t in2)
{
    int64_t c_27423 = (int64_t) 0;
    int64_t n_27424 = (int64_t) 0;
    int64_t Ax_27426 = (int64_t) 0;
    int64_t prim_out_50839 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_50838;
    
    mem_out_50838.references = NULL;
    
    struct memblock newprices_mem_50257;
    
    newprices_mem_50257.references = NULL;
    n_27424 = in0;
    newprices_mem_50257 = in1->mem;
    c_27423 = in1->shape[0];
    Ax_27426 = in2;
    if (!(c_27423 == in1->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_test_carprice_sell(ctx, &mem_out_50838, &prim_out_50839, newprices_mem_50257, c_27423, n_27424, Ax_27426);
        if (ret == 0) {
            assert((*out0 = (struct futhark_f64_1d *) malloc(sizeof(struct futhark_f64_1d))) != NULL);
            (*out0)->mem = mem_out_50838;
            (*out0)->shape[0] = prim_out_50839;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_test_ev_scrap(struct futhark_context *ctx, struct futhark_f64_1d **out0, const int64_t in0, const struct futhark_f64_1d *in1, const int64_t in2)
{
    int64_t c_28302 = (int64_t) 0;
    int64_t n_28303 = (int64_t) 0;
    int64_t Ax_28305 = (int64_t) 0;
    int64_t prim_out_50839 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_50838;
    
    mem_out_50838.references = NULL;
    
    struct memblock newprices_mem_50257;
    
    newprices_mem_50257.references = NULL;
    n_28303 = in0;
    newprices_mem_50257 = in1->mem;
    c_28302 = in1->shape[0];
    Ax_28305 = in2;
    if (!(c_28302 == in1->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_test_ev_scrap(ctx, &mem_out_50838, &prim_out_50839, newprices_mem_50257, c_28302, n_28303, Ax_28305);
        if (ret == 0) {
            assert((*out0 = (struct futhark_f64_1d *) malloc(sizeof(struct futhark_f64_1d))) != NULL);
            (*out0)->mem = mem_out_50838;
            (*out0)->shape[0] = prim_out_50839;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_test_notrade(struct futhark_context *ctx, struct futhark_f64_2d **out0, const int64_t in0, const int64_t in1, const int64_t in2)
{
    int64_t n_26596 = (int64_t) 0;
    int64_t c_26597 = (int64_t) 0;
    int64_t Ax_26598 = (int64_t) 0;
    int64_t prim_out_50839 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_50838;
    
    mem_out_50838.references = NULL;
    n_26596 = in0;
    c_26597 = in1;
    Ax_26598 = in2;
    if (ret == 0) {
        ret = futrts_entry_test_notrade(ctx, &mem_out_50838, &prim_out_50839, n_26596, c_26597, Ax_26598);
        if (ret == 0) {
            assert((*out0 = (struct futhark_f64_2d *) malloc(sizeof(struct futhark_f64_2d))) != NULL);
            (*out0)->mem = mem_out_50838;
            (*out0)->shape[0] = prim_out_50839;
            (*out0)->shape[1] = prim_out_50839;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_test_simple_prices(struct futhark_context *ctx, struct futhark_f64_2d **out0, const int64_t in0, const struct futhark_f64_1d *in1, const int64_t in2)
{
    int64_t c_22326 = (int64_t) 0;
    int64_t n_22327 = (int64_t) 0;
    int64_t Ax_22329 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_50838;
    
    mem_out_50838.references = NULL;
    
    struct memblock newprices_mem_50257;
    
    newprices_mem_50257.references = NULL;
    n_22327 = in0;
    newprices_mem_50257 = in1->mem;
    c_22326 = in1->shape[0];
    Ax_22329 = in2;
    if (!(c_22326 == in1->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_test_simple_prices(ctx, &mem_out_50838, newprices_mem_50257, c_22326, n_22327, Ax_22329);
        if (ret == 0) {
            assert((*out0 = (struct futhark_f64_2d *) malloc(sizeof(struct futhark_f64_2d))) != NULL);
            (*out0)->mem = mem_out_50838;
            (*out0)->shape[0] = Ax_22329;
            (*out0)->shape[1] = c_22326;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_test_trade(struct futhark_context *ctx, struct futhark_f64_2d **out0, const int64_t in0, const int64_t in1, const int64_t in2)
{
    int64_t n_26698 = (int64_t) 0;
    int64_t c_26699 = (int64_t) 0;
    int64_t Ax_26700 = (int64_t) 0;
    int64_t prim_out_50839 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_50838;
    
    mem_out_50838.references = NULL;
    n_26698 = in0;
    c_26699 = in1;
    Ax_26700 = in2;
    if (ret == 0) {
        ret = futrts_entry_test_trade(ctx, &mem_out_50838, &prim_out_50839, n_26698, c_26699, Ax_26700);
        if (ret == 0) {
            assert((*out0 = (struct futhark_f64_2d *) malloc(sizeof(struct futhark_f64_2d))) != NULL);
            (*out0)->mem = mem_out_50838;
            (*out0)->shape[0] = prim_out_50839;
            (*out0)->shape[1] = prim_out_50839;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_test_utility(struct futhark_context *ctx, struct futhark_f64_2d **out0, const int64_t in0, const struct futhark_f64_1d *in1, const int64_t in2)
{
    int64_t c_35101 = (int64_t) 0;
    int64_t n_35102 = (int64_t) 0;
    int64_t Ax_35104 = (int64_t) 0;
    int64_t prim_out_50839 = (int64_t) 0;
    int64_t prim_out_50840 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_50838;
    
    mem_out_50838.references = NULL;
    
    struct memblock newprices_mem_50257;
    
    newprices_mem_50257.references = NULL;
    n_35102 = in0;
    newprices_mem_50257 = in1->mem;
    c_35101 = in1->shape[0];
    Ax_35104 = in2;
    if (!(c_35101 == in1->shape[0])) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_test_utility(ctx, &mem_out_50838, &prim_out_50839, &prim_out_50840, newprices_mem_50257, c_35101, n_35102, Ax_35104);
        if (ret == 0) {
            assert((*out0 = (struct futhark_f64_2d *) malloc(sizeof(struct futhark_f64_2d))) != NULL);
            (*out0)->mem = mem_out_50838;
            (*out0)->shape[0] = prim_out_50839;
            (*out0)->shape[1] = prim_out_50840;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_test_utility_2(struct futhark_context *ctx, struct futhark_f64_2d **out0, const int64_t in0, const struct futhark_f64_1d *in1, const int64_t in2, const struct futhark_f64_2d *in3)
{
    int64_t c_35258 = (int64_t) 0;
    int64_t n_35259 = (int64_t) 0;
    int64_t Ax_35261 = (int64_t) 0;
    int64_t prim_out_50839 = (int64_t) 0;
    int64_t prim_out_50840 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_50838;
    
    mem_out_50838.references = NULL;
    
    struct memblock u_a_sq_mem_50258;
    
    u_a_sq_mem_50258.references = NULL;
    
    struct memblock newprices_mem_50257;
    
    newprices_mem_50257.references = NULL;
    n_35259 = in0;
    newprices_mem_50257 = in1->mem;
    c_35258 = in1->shape[0];
    Ax_35261 = in2;
    u_a_sq_mem_50258 = in3->mem;
    c_35258 = in3->shape[1];
    if (!(c_35258 == in1->shape[0] && (n_35259 == in3->shape[0] && c_35258 == in3->shape[1]))) {
        ret = 1;
        set_error(ctx, msgprintf("Error: entry point arguments have invalid sizes.\n"));
    }
    if (ret == 0) {
        ret = futrts_entry_test_utility_2(ctx, &mem_out_50838, &prim_out_50839, &prim_out_50840, newprices_mem_50257, u_a_sq_mem_50258, c_35258, n_35259, Ax_35261);
        if (ret == 0) {
            assert((*out0 = (struct futhark_f64_2d *) malloc(sizeof(struct futhark_f64_2d))) != NULL);
            (*out0)->mem = mem_out_50838;
            (*out0)->shape[0] = prim_out_50839;
            (*out0)->shape[1] = prim_out_50840;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
  
